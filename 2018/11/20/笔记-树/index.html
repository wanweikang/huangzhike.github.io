<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-树 | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-树">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-树</h2>
				
				<div>
					<div class="post-time">2018-11-20</div>
				</div>
				
				<div class="article-content">
				<p><strong>代码来源：《学习JavaScript数据结构与算法》 By <a href="https://github.com/loiane" target="_blank" rel="noopener">Loiane Groner</a></strong></p>
<p>2019年11月20日更新</p>
<hr>
<p>二叉搜索树（BST）：</p>
<ul>
<li><p>节点最多只能有两个子节点（左侧和右侧）；</p>
</li>
<li><p>每个节点包含两个指针，一个指向左侧子节点，另一个指向右侧子节点；</p>
</li>
<li><p>在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或等于）的值；</p>
</li>
</ul>
<p>二分查找可以缩短查找的时间，但是要求数据必须是有序的，于是有了二叉树，提高查找效率。</p>
<p>所以二叉树的中序遍历一定是从小到大的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.key&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向树中插入一个新的节点</span></span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="comment">// special case: first key</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果插入的节点是树的第一个节点，就将根节点指向新节点</span></span><br><span class="line">            <span class="keyword">this</span>.root = <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将节点加在非根节点的其他位置</span></span><br><span class="line">            <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入当前节点（第一次是根节点）和要插入的节点的值</span></span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="comment">// 新节点的值小于当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 当前节点还没有左侧子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 插入</span></span><br><span class="line">                node.left = <span class="keyword">new</span> Node(key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 已经有左侧子节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归下一层</span></span><br><span class="line">                <span class="keyword">this</span>.insertNode(node.left, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新节点的值大于等于当前节点的值</span></span><br><span class="line">        <span class="comment">// 右侧没有子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            node.right = <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 右侧已经有了，从右侧继续递归</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.insertNode(node.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找一棵树的一个节点</span></span><br><span class="line">    search(key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(<span class="keyword">this</span>.root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点的子树开始寻找</span></span><br><span class="line">    searchNode(node, key) &#123;</span><br><span class="line">        <span class="comment">// 到底了还没找到，叶子节点，递归终点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找的值比当前节点的值小</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 递归，从左侧子树继续找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.left, key);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 找的值比当前节点的值大</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 递归，从右侧子树继续找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.searchNode(node.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// element is equal to node.item</span></span><br><span class="line">        <span class="comment">// 找的值和当前节点的值相等，返回找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.minNode(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定节点开始寻找最小的节点，即最左的节点</span></span><br><span class="line">    minNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxNode(<span class="keyword">this</span>.root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxNode(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> current = node;</span><br><span class="line">        <span class="comment">// 要找到最大的键，要沿着树的右边进行遍历，直到找到最右端的节点</span></span><br><span class="line">        <span class="comment">// 寻找最小值，沿着树的左边，寻找最大值，沿着树的右边</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            current = current.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove(key) &#123;</span><br><span class="line">        <span class="comment">// 从根节点开始，返回删除后的根节点</span></span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从指定的树中移除某个节点，二叉树有两个子节点，还有大小顺序，不像链表那么简单</span></span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为null，说明已经到了叶子节点还没找到，递归结束</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值比查找的值大</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 沿着该节点的左侧子节点继续递归，返回执行删除后的该节点的左侧子节点，并更新</span></span><br><span class="line">            node.left = <span class="keyword">this</span>.removeNode(node.left, key);</span><br><span class="line">            <span class="comment">// 返回更新后的该节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点的值比查找的值小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 沿着该节点的右侧子节点继续递归，返回执行删除后的该节点的右侧子节点，并更新</span></span><br><span class="line">            node.right = <span class="keyword">this</span>.removeNode(node.right, key);</span><br><span class="line">            <span class="comment">// 返回更新后的该节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key is equal to node.item handle 3 special conditions</span></span><br><span class="line">        <span class="comment">// 1 - a leaf node 移除一个叶节点</span></span><br><span class="line">        <span class="comment">// 2 - a node with only 1 child 移除有一个左侧或右侧子节点的节点</span></span><br><span class="line">        <span class="comment">// 3 - a node with 2 children 移除有两个子节点的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前节点的值等于要找的值，则找到了要删除的节点，处理三种情况</span></span><br><span class="line">        <span class="comment">// case 1 要移除的节点是没有左右侧子节点的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接将该节点置空，就是删除</span></span><br><span class="line">            node = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="comment">// 返回undefined，因为还要置空父节点对它的指针</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 2 要移除的节点只有右侧一个子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用右侧的子节点代替该节点，直接顶上去，因为节点右侧的所有子孙节点都是大于该节点的</span></span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 2 要移除的节点只有左侧一个子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用左侧的子节点代替该节点</span></span><br><span class="line">            node = node.left;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 3 要移除的节点有两个子节点</span></span><br><span class="line">        <span class="comment">// 先找到它右边子树中最小的节点，即最小的大于它的节点，这个节点肯定是个叶子节点</span></span><br><span class="line">        <span class="keyword">const</span> aux = <span class="keyword">this</span>.minNode(node.right);</span><br><span class="line">        <span class="comment">// 用该节点替换需要移除的节点</span></span><br><span class="line">        node.key = aux.key;</span><br><span class="line">        <span class="comment">// 把右侧子树中的最小节点移除，因为它已经被移到要移除的节点的位置了，并更新右侧子节点，把树连起来</span></span><br><span class="line">        node.right = <span class="keyword">this</span>.removeNode(node.right, aux.key);</span><br><span class="line">        <span class="comment">// 向它的父节点返回更新后节点的引用</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历树的所有节点有三种方式：中序、先序和后序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历：上行顺序访问BST所有节点，也就是以从小到大的顺序访问所有节点，可以对树排序</span></span><br><span class="line">inOrderTraverse(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inOrderTraverseNode(<span class="keyword">this</span>.root, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inOrderTraverseNode(node, callback) &#123;</span><br><span class="line">    <span class="comment">// 停止递归的判断条件</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归访问左侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverseNode(node.left, callback);</span><br><span class="line">        <span class="comment">// 对这个节点进行操作（callback）</span></span><br><span class="line">        callback(node.key);</span><br><span class="line">        <span class="comment">// 再访问右侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.inOrderTraverseNode(node.right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历：以优先于后代节点的顺序访问每个节点，可以打印结构化的文档</span></span><br><span class="line">preOrderTraverse(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.preOrderTraverseNode(<span class="keyword">this</span>.root, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preOrderTraverseNode(node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先序遍历会先访问节点本身</span></span><br><span class="line">        callback(node.key);</span><br><span class="line">        <span class="comment">// 然后再访问它的左侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.left, callback);</span><br><span class="line">        <span class="comment">// 最后是右侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.preOrderTraverseNode(node.right, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历：先访问节点的后代节点，再访问节点本身，可以计算一个目录和子目录中所有文件空间的大小</span></span><br><span class="line">postOrderTraverse(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.postOrderTraverseNode(<span class="keyword">this</span>.root, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postOrderTraverseNode(node, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 先访问左侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverseNode(node.left, callback);</span><br><span class="line">        <span class="comment">// 然后是右侧子节点</span></span><br><span class="line">        <span class="keyword">this</span>.postOrderTraverseNode(node.right, callback);</span><br><span class="line">        <span class="comment">// 最后是父节点本身</span></span><br><span class="line">        callback(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/inOrderTraverseNode.PNG" alt="中序遍历 by huangzhike"></p>
<p><code>inOrderTraverseNode(node.left, callback);</code>一直向左往里边走，到了最小的Node3，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，<code>node.right==null</code>，这个节点的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点Node5执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback)</code>，进入右边的Node6，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，<code>node.right==null</code>，这个节点的<code>inOrderTraverseNode</code>结束；Node5的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点Node7执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，进入右边的节点Node9，进入左边的节点Node8，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，略。。。</p>
<p>面试题：将一个二叉树变为排序的双向链表，要求不能创建任何新的结点，只调整指针的指向。</p>
<p>答案：将这棵树中序遍历，每遍历到一个节点就将该节点的左指针指向上一个遍历的节点，并将上一个遍历的节点的右指针指向当前遍历的节点，当遍历完整棵树后，双向链表就完成了。</p>
<hr>
<p>BST问题：极端情况下，树的一条边可能会非常深，变成一个链表，操作的效率下降。</p>
<p>AVL树解决了这个问题。</p>
<p>AVL树是自平衡二叉搜索树，任何一个节点左右两侧子树的高度之差最多为1，这种树会在添加或移除节点时尽量成为一棵完全树。</p>
<p>平衡二叉树要么是一棵空树，要么保证左右子树的高度之差不大于1，子树也必须是一颗平衡二叉树。</p>
<p>AVL树我没看，代码就不贴了。</p>
<!-- 
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BalanceFactor = &#123;</span><br><span class="line">    UNBALANCED_RIGHT: <span class="number">1</span>,</span><br><span class="line">    SLIGHTLY_UNBALANCED_RIGHT: <span class="number">2</span>,</span><br><span class="line">    BALANCED: <span class="number">3</span>,</span><br><span class="line">    SLIGHTLY_UNBALANCED_LEFT: <span class="number">4</span>,</span><br><span class="line">    UNBALANCED_LEFT: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> <span class="keyword">extends</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(compareFn = defaultCompare) &#123;</span><br><span class="line">        <span class="keyword">super</span>(compareFn);</span><br><span class="line">        <span class="keyword">this</span>.compareFn = compareFn;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getNodeHeight(node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="keyword">this</span>.getNodeHeight(node.left), <span class="keyword">this</span>.getNodeHeight(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Left left case: rotate right</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *       b                           a</span></span><br><span class="line"><span class="comment">   *      / \                         / \</span></span><br><span class="line"><span class="comment">   *     a   e -&gt; rotationLL(b) -&gt;   c   b</span></span><br><span class="line"><span class="comment">   *    / \                             / \</span></span><br><span class="line"><span class="comment">   *   c   d                           d   e</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationLL(node) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = node.left;</span><br><span class="line">        node.left = tmp.right;</span><br><span class="line">        tmp.right = node;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Right right case: rotate left</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *     a                              b</span></span><br><span class="line"><span class="comment">   *    / \                            / \</span></span><br><span class="line"><span class="comment">   *   c   b   -&gt; rotationRR(a) -&gt;    a   e</span></span><br><span class="line"><span class="comment">   *      / \                        / \</span></span><br><span class="line"><span class="comment">   *     d   e                      c   d</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationRR(node) &#123;</span><br><span class="line">        <span class="keyword">const</span> tmp = node.right;</span><br><span class="line">        node.right = tmp.left;</span><br><span class="line">        tmp.left = node;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Left right case: rotate left then right</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationLR(node) &#123;</span><br><span class="line">        node.left = <span class="keyword">this</span>.rotationRR(node.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rotationLL(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Right left case: rotate right then left</span></span><br><span class="line"><span class="comment">   * @param node Node&lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    rotationRL(node) &#123;</span><br><span class="line">        node.right = <span class="keyword">this</span>.rotationLL(node.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rotationRR(node);</span><br><span class="line">    &#125;</span><br><span class="line">    getBalanceFactor(node) &#123;</span><br><span class="line">        <span class="keyword">const</span> heightDifference = <span class="keyword">this</span>.getNodeHeight(node.left) - <span class="keyword">this</span>.getNodeHeight(node.right);</span><br><span class="line">        <span class="keyword">switch</span> (heightDifference) &#123;</span><br><span class="line">        <span class="keyword">case</span> - <span class="number">2</span> : <span class="keyword">return</span> BalanceFactor.UNBALANCED_RIGHT;</span><br><span class="line">        <span class="keyword">case</span> - <span class="number">1</span> : <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> BalanceFactor.UNBALANCED_LEFT;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> BalanceFactor.BALANCED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(key) &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">this</span>.insertNode(<span class="keyword">this</span>.root, key);</span><br><span class="line">    &#125;</span><br><span class="line">    insertNode(node, key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">            node.left = <span class="keyword">this</span>.insertNode(node.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">            node.right = <span class="keyword">this</span>.insertNode(node.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node; <span class="comment">// duplicated key</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// verify if tree is balanced</span></span><br><span class="line">        <span class="keyword">const</span> balanceFactor = <span class="keyword">this</span>.getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123;</span><br><span class="line">                <span class="comment">// Left left case</span></span><br><span class="line">                node = <span class="keyword">this</span>.rotationLL(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Left right case</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLR(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123;</span><br><span class="line">                <span class="comment">// Right right case</span></span><br><span class="line">                node = <span class="keyword">this</span>.rotationRR(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Right left case</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRL(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    removeNode(node, key) &#123;</span><br><span class="line">        node = <span class="keyword">super</span>.removeNode(node, key); <span class="comment">// &#123;1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// verify if tree is balanced</span></span><br><span class="line">        <span class="keyword">const</span> balanceFactor = <span class="keyword">this</span>.getBalanceFactor(node);</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</span><br><span class="line">            <span class="comment">// Left left case</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.left) === BalanceFactor.BALANCED || <span class="keyword">this</span>.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLL(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Left right case</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationLR(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</span><br><span class="line">            <span class="comment">// Right right case</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.right) === BalanceFactor.BALANCED || <span class="keyword">this</span>.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRR(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Right left case</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.rotationRL(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
<!--  -->
<hr>
<p>二叉树的性能取决于树的高度，最好的情况是完全二叉树，复杂度O(logN)，最差的情况是链表，复杂度O(N)。</p>
<p>红黑树是一种特殊的二叉树（可以自平衡），又称为对称二叉B树（Symmetric Binary B-Tree），可以进行高效的中序遍历，复杂度O(logN)。</p>
<p>红黑树不是标准平衡二叉树，但是统计性能要好于平衡二叉树（AVL树），因此，Java中的TreeMap，JDK1.8中的HashMap都使用了红黑树。</p>
<p>HashMap在哈希冲突严重时，链表过长导致查找效率降低，红黑树可以解决这个问题。</p>
<p>TreeMap：相等不保存，使用二叉树排序。</p>
<p>自平衡：将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。</p>
<p>红黑树本质上是二叉树，但在二叉树的基础上加了一个标记（颜色），规则：</p>
<ol>
<li><p>每个节点是红色或者黑色；</p>
</li>
<li><p>根节点是黑色的；</p>
</li>
<li><p>所有的叶子节点都是是黑色的（这里的叶子节点是NIL节点，即空节点）；</p>
</li>
<li><p>红色节点的两个子节点都是黑色的（从叶子节点到根节点的所有路径上不能有两个连续的红色节点）；</p>
</li>
<li><p>从任一节点到其子树的每个叶子节点的简单路径都包含相同数量的黑色节点（关键的平衡条件，黑高）；</p>
</li>
</ol>
<p>黑色高度：从根节点到叶节点的路径上黑色节点的个数。</p>
<p>根据规则4和规则5，可以知道，任意节点到其每个叶子节点路径最长不会超过最短路径的两倍：</p>
<ul>
<li><p>当某条路径最短时，这条路径必然全都由黑色节点构成，假设黑色节点数量为N，则路径长度为N；</p>
</li>
<li><p>当某条路径最长时，这条路径必然由红色和黑色节点相间构成（规则4和规则5，不能出现两个连续的红色节点，任一节点到其每个叶子节点的所有路径必须黑色节点数量相同），则路径长为2N。</p>
</li>
</ul>
<p>具体过程可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noopener">这个动画</a>。</p>
<ul>
<li><p>右旋：将某个节点旋转为其左孩子的右孩子（爷爷👴变孙子），同时把其左孩子的右孩子（如果有）变成自己的左孩子（孙子变儿子）；</p>
</li>
<li><p>左旋：将某个节点旋转为其右孩子的左孩子，以此类推；</p>
</li>
</ul>
<p>孙子：👴您不要脸我还要脸呢。</p>
<p>红黑树的插入：</p>
<ul>
<li><p>首先和二叉树一样，查找、插入；</p>
</li>
<li><p>然后调整结构（旋转）和重新着色，保证满足规则：</p>
</li>
</ul>
<p>第4条规定，红色节点的左右孩子一定都是黑色节点，当给一个红色节点插入一个红色子节点时，会违背这条规定。</p>
<p>第5条规定，任一节点到它子树的每个叶子节点的路径中都包含同样数量的黑色节点，当往红黑树中插入一个黑色节点时，会违背这条规定。</p>
<p>那么插入时只要将插入的节点设为红色，就不会影响规则5，只要满足规则4就行了。</p>
<p>这样只要保证父节点不是红色就可以了，如果是红的，把父节点变成黑色，或者换一个黑色节点当父亲（认黑叔叔当爹）。</p>
<p><img src="/imgs/RedBlackTree_Process.png" alt="插入过程 by huangzhike"></p>
<!-- ![插入的三种情况 by huangzhike](/imgs/RedBlackTree_Condiction.png) -->
<p><img src="/imgs/RedBlackTree_Condiction.png" alt="插入的三种情况 by huangzhike" width="60%"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RedBlackTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 红黑树的节点有红色和黑色两种</span></span><br><span class="line">    <span class="keyword">let</span> Colors = &#123;</span><br><span class="line">        RED: <span class="number">0</span>,</span><br><span class="line">        BLACK: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">key, color</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换节点的颜色</span></span><br><span class="line">        <span class="keyword">this</span>.flipColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = <span class="keyword">this</span>.color === Colors.RED ? Colors.BLACK : Colors.RED;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> root = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点是红色节点</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isRed</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// NIL节点</span></span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.color === Colors.RED;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别反转节点的左右子节点的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flipColors</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        node.left.flipColor();</span><br><span class="line">        node.right.flipColor();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自平衡，左旋某节点</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rotateLeft</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = node.right;</span><br><span class="line">        <span class="keyword">if</span> (temp !== <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = temp.left;</span><br><span class="line">            temp.left = node;</span><br><span class="line">            temp.color = node.color;</span><br><span class="line">            node.color = Colors.RED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自平衡，右旋某节点，就是将它变成原来的左孩子的右孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">rotateRight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 节点的左孩子节点</span></span><br><span class="line">        <span class="keyword">let</span> temp = node.left;</span><br><span class="line">        <span class="comment">// 首先得有个左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (temp !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置自己的左孩子为原来的左孩子的右孩子</span></span><br><span class="line">            node.left = temp.right;</span><br><span class="line">            <span class="comment">// 将节点设为原来的左孩子的右孩子</span></span><br><span class="line">            temp.right = node;</span><br><span class="line">            <span class="comment">// 原本的左孩子继承该节点的颜色</span></span><br><span class="line">            temp.color = node.color;</span><br><span class="line">            <span class="comment">// 再把该节点设为红色</span></span><br><span class="line">            node.color = Colors.RED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右旋后，它的左孩子就取代了该节点的位置</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点到一棵子树</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insertNode</span>(<span class="params">node, element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 要插入到一个没有根节点的树</span></span><br><span class="line">        <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回树的根节点，执行真正的插入，新插入的节点为红色</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(element, Colors.RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要插入的子树的根节点</span></span><br><span class="line">        <span class="keyword">let</span> newRoot = node;</span><br><span class="line">        <span class="comment">// 插入的节点小于当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (element &lt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 递归，从左侧子节点开始，返回插入后的左侧子节点，并更新</span></span><br><span class="line">            node.left = insertNode(node.left, element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入的节点大于当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element &gt; node.key) &#123;</span><br><span class="line">            <span class="comment">// 递归，从到右侧子节点开始，返回插入后的右侧子节点，并更新</span></span><br><span class="line">            node.right = insertNode(node.right, element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刚好等于，更不更新值都行，反正都相等</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 意思一下</span></span><br><span class="line">            node.key = element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还要调整一下，为了描述方便，后面用根指代这棵子树的根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根的右孩子是红色 &amp;&amp; 根的左孩子是黑色（或者没有左孩子，NIL）</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">            <span class="comment">// 把根左旋，返回新的子树的根</span></span><br><span class="line">            newRoot = rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根的左孩子是红色 &amp;&amp; 根的左孩子的左孩子也是红色</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">            <span class="comment">// 把根右旋，返回新的子树的根</span></span><br><span class="line">            newRoot = rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根的左孩子是红色 &amp;&amp; 根的右孩子也是红色</span></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">            <span class="comment">// 直接反转左右节点的颜色为黑色</span></span><br><span class="line">            flipColors(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的根</span></span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点到树</span></span><br><span class="line">    <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 插入节点，并返回新的根节点</span></span><br><span class="line">        root = insertNode(root, element);</span><br><span class="line">        <span class="comment">// 根节点必须是黑色</span></span><br><span class="line">        root.color = Colors.BLACK;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>红黑树的删除：和二叉树的删除一样，但是之后需要调整结构。</p>
<ul>
<li><p>要删除的节点是叶子节点，直接删除，不需要再处理；</p>
</li>
<li><p>只有单个子节点，直接把子节点顶上去就行；</p>
</li>
<li><p>有两个子节点，需要选一个子节点作为新的根节点，称为继承节点；</p>
</li>
</ul>
<p>结构调整</p>
<ul>
<li><p>如果删除的节点是红色的，没有任何影响；</p>
</li>
<li><p>如果删除的节点是黑色的，需要进一步调整；</p>
</li>
</ul>
<p>删除黑色节点后，该节点的子树就比旁边的子树少一个黑色节点，关键在于平衡。</p>
<p>吭，时间比较赶，红黑树的删除部分我就不看了，我是个爱学习的好孩子。</p>
<hr>
<p>除了B树，还有B-树、B+树、B*树，不过这些已经不是二叉树了，有兴趣的可以了解，我是没兴趣:)。</p>
<p>如果我还是个学生，大概会挺感兴趣吧，不过现在嘛，主要还是由投入和产出驱动的，不然就没完没了了😬。</p>
<p>而且算法这些，不经常用很快就忘了，必须得反复练习，即使今天看明白了，过两天如果面试官说：喂，手写一个红黑树给我看看？</p>
<p>那我的表情就是：😲😕😨😰。</p>
<p>我对自己的要求是：看懂就行。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
