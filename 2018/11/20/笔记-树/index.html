<!DOCTYPE HTML>
<html>

<head>
    <script>
        var timeStart = new Date();
    </script>
    <meta charset="utf-8">
    
    <title>[笔记]-树 | 草木禾</title>
    
    <meta name="author" content="huangzhike">
    
    
    <meta name="description"
        content="代码来源：《学习JavaScript数据结构与算法》 By Loiane Groner
2019年11月20日更新

二叉搜索树（BST）：

节点最多只能有两个子节点（左侧和右侧）；

每个节点包含两个指针，一个指向左侧子节点，另一个指向右侧子节点；

在左侧节点存放（比父节点）小的值，在右侧节点">
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta property="og:title" content="[笔记]-树" />
    
    <meta property="og:site_name" content="草木禾" />
    
    
    <!-- favicon -->
    <link rel="icon" type="image/ico" href="/logo.ico" sizes="32x32">
    <meta name="msapplication-TileColor" content="#009688">
    <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
    <meta name="theme-color" content="#009688">
    <!-- favicon end -->
    <!-- <link href="//ok.ico" rel="icon"> -->
    

    <!-- <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" title="早く来い、クラウド" href="/">Reunion...</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-树</h2>
				
				<div>
					<div class="post-time">2018-11-20</div>
				</div>
				
				<div class="article-content">
				<p><strong>代码来源：《学习JavaScript数据结构与算法》 By <a href="https://github.com/loiane" target="_blank" rel="noopener">Loiane Groner</a></strong></p>
<p>2019年11月20日更新</p>
<hr>
<p>二叉搜索树（BST）：</p>
<ul>
<li><p>节点最多只能有两个子节点（左侧和右侧）；</p>
</li>
<li><p>每个节点包含两个指针，一个指向左侧子节点，另一个指向右侧子节点；</p>
</li>
<li><p>在左侧节点存放（比父节点）小的值，在右侧节点存放（比父节点）大（或等于）的值；</p>
</li>
</ul>
<p>二分查找可以缩短查找的时间，但是要求数据必须是有序的，于是有了二叉树，提高查找效率。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 向树中插入一个新的节点</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// special case: first key</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果插入的节点是树的第一个节点，就将根节点指向新节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 将节点加在非根节点的其他位置</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 传入当前节点（第一次是根节点）和要插入的节点的值</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 新节点的值小于当前节点的值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 当前节点还没有左侧子节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 插入</span>
                node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 已经有左侧子节点</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 递归下一层</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 新节点的值大于等于当前节点的值</span>
        <span class="token comment" spellcheck="true">// 右侧没有子节点</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 插入</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 右侧已经有了，从右侧继续递归</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 寻找一棵树的一个节点</span>
    <span class="token function">search</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 从节点的子树开始寻找</span>
    <span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 到底了还没找到，叶子节点，递归终点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 找的值比当前节点的值小</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 递归，从左侧子树继续找</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token comment" spellcheck="true">// 找的值比当前节点的值大</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 递归，从右侧子树继续找</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// element is equal to node.item</span>
        <span class="token comment" spellcheck="true">// 找的值和当前节点的值相等，返回找到</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 从指定节点开始寻找最小的节点，即最左的节点</span>
    <span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> current<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">maxNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">maxNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> current <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 要找到最大的键，要沿着树的右边进行遍历，直到找到最右端的节点</span>
        <span class="token comment" spellcheck="true">// 寻找最小值，沿着树的左边，寻找最大值，沿着树的右边</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> current<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 从根节点开始，返回删除后的根节点</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 从指定的子树中移除某个节点，返回删除后的子树的新的根节点</span>
    <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果当前节点为null，说明已经到了叶子节点还没找到，递归结束</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> undefined<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果查找的值比当前节点的值小</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 沿着该节点的左侧子节点继续递归，返回执行删除后的该节点的左侧子节点，并更新</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 返回更新后的该节点</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果查找的值比当前节点的值大</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">></span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 沿着该节点的右侧子节点继续递归，返回执行删除后的该节点的右侧子节点，并更新</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 返回更新后的该节点</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// key is equal to node.item handle 3 special conditions</span>
        <span class="token comment" spellcheck="true">// 1 - a leaf node 移除一个叶子节点</span>
        <span class="token comment" spellcheck="true">// 2 - a node with only 1 child 移除只有一个子节点的节点</span>
        <span class="token comment" spellcheck="true">// 3 - a node with 2 children 移除有两个子节点的节点</span>

        <span class="token comment" spellcheck="true">// 如果当前节点的值等于要找的值，则找到了要删除的节点，处理三种情况</span>
        <span class="token comment" spellcheck="true">// case 1 要移除的节点是没有左右侧子节点的叶子节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 直接将该节点置空删除</span>
            node <span class="token operator">=</span> undefined<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 返回undefined，因为还要置空父节点对它的指针</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// case 2 要移除的节点只有一个子节点，直接用该子节点顶上替代就好</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 用右侧的子节点代替该节点，直接顶上去，因为节点右侧的所有子孙节点都是大于该节点的</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// case 3 要移除的节点有两个子节点</span>
        <span class="token comment" spellcheck="true">// 先找到它右边子树中最小的节点，即最小的大于它的节点，这个后继节点肯定没有左孩子</span>
        <span class="token comment" spellcheck="true">// 当然也可以找到左边子树的最大节点，即最大的小于它的节点，通过前驱节点来删除，毕竟是对称的</span>
        <span class="token keyword">const</span> aux <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 先替换掉值，这样节点就算删掉了，但是现在就有了两份后继节点的值</span>
        node<span class="token punctuation">.</span>key <span class="token operator">=</span> aux<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 从右侧子树中把多余的后继节点删除，并更新右侧子节点，把树连起来</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> aux<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 向它的父节点返回更新后节点的引用</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li><p>先序遍历：</p>
<ul>
<li><p>先遍历当前节点，再遍历左侧节点，最后遍历右侧节点；</p>
</li>
<li><p>可以打印结构化的文档；</p>
</li>
</ul>
</li>
<li><p>中序遍历：</p>
<ul>
<li><p>先遍历左侧节点，再遍历当前节点，最后遍历右侧节点；</p>
</li>
<li><p>特点是按从小到大的顺序访问所有节点，如排序；</p>
</li>
</ul>
</li>
<li><p>后序遍历：</p>
<ul>
<li><p>先遍历左侧节点，再遍历右侧节点，最后遍历当前节点；</p>
</li>
<li><p>可以计算一个目录和子目录中所有文件空间的大小；</p>
</li>
</ul>
</li>
</ul>
<p>以递归方式实现为例</p>
<pre class=" language-javascript"><code class="language-javascript">    <span class="token comment" spellcheck="true">// 中序遍历</span>
    <span class="token function">inOrderTraverse</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 停止递归的判断条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 递归访问左侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 对这个节点进行操作（callback）</span>
            <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 再访问右侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 先序遍历</span>
    <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 先序遍历会先访问节点本身</span>
            <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 然后再访问它的左侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 最后是右侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 后序遍历</span>
    <span class="token function">postOrderTraverse</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 先访问左侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 然后是右侧子节点</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 最后是父节点本身</span>
            <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span></code></pre>
<p>上面是以递归的方式实现的，但是递归消耗栈空间，直到结束才释放，而且有栈深度的限制，所以元素多时比较危险，非递归的实现，可以参考TreeMap。</p>
<p>遍历树还有广度优先的方式，不过不常用，有兴趣自己查资料。</p>
<p><img src="/imgs/inOrderTraverseNode.PNG" alt="中序遍历 by huangzhike"></p>
<p><code>inOrderTraverseNode(node.left, callback);</code>一直向左往里边走，到了最小的Node3，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，<code>node.right==null</code>，这个节点的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点Node5执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback)</code>，进入右边的Node6，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，<code>node.right==null</code>，这个节点的<code>inOrderTraverseNode</code>结束；Node5的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点Node7执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，进入右边的节点Node9，进入左边的节点Node8，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，略。。。</p>
<p>面试题：将一个二叉树变为排序的双向链表，要求不能创建任何新的结点，只调整指针的指向。</p>
<p>答案：将这棵树中序遍历，每遍历到一个节点就将该节点的左指针指向上一个遍历的节点，并将上一个遍历的节点的右指针指向当前遍历的节点，当遍历完整棵树后，双向链表就完成了。</p>
<hr>
<p>BST问题：极端情况下，二叉树的一条边可能会非常深，变成一个链表，操作的效率下降。</p>
<p>AVL树解决了这个问题。</p>
<p>AVL树是自平衡二叉搜索树，任何一个节点左右两侧子树的高度之差最多为1，这种树会在添加或移除节点时尽量成为一棵完全树。</p>
<p>自平衡：将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。</p>
<p>平衡二叉树必须保证左右子树的高度之差不大于1，子树也必须是一颗平衡二叉树。</p>
<p>AVL树我没看，代码就不贴了。</p>
<!-- 
```javascript
const BalanceFactor = {
    UNBALANCED_RIGHT: 1,
    SLIGHTLY_UNBALANCED_RIGHT: 2,
    BALANCED: 3,
    SLIGHTLY_UNBALANCED_LEFT: 4,
    UNBALANCED_LEFT: 5
};

class AVLTree extends BinarySearchTree {
    constructor(compareFn = defaultCompare) {
        super(compareFn);
        this.compareFn = compareFn;
        this.root = null;
    }
    getNodeHeight(node) {
        if (node == null) {
            return - 1;
        }
        return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;
    }
    /**
   * Left left case: rotate right
   *
   *       b                           a
   *      / \                         / \
   *     a   e -> rotationLL(b) ->   c   b
   *    / \                             / \
   *   c   d                           d   e
   *
   * @param node Node<T>
   */
    rotationLL(node) {
        const tmp = node.left;
        node.left = tmp.right;
        tmp.right = node;
        return tmp;
    }
    /**
   * Right right case: rotate left
   *
   *     a                              b
   *    / \                            / \
   *   c   b   -> rotationRR(a) ->    a   e
   *      / \                        / \
   *     d   e                      c   d
   *
   * @param node Node<T>
   */
    rotationRR(node) {
        const tmp = node.right;
        node.right = tmp.left;
        tmp.left = node;
        return tmp;
    }
    /**
   * Left right case: rotate left then right
   * @param node Node<T>
   */
    rotationLR(node) {
        node.left = this.rotationRR(node.left);
        return this.rotationLL(node);
    }
    /**
   * Right left case: rotate right then left
   * @param node Node<T>
   */
    rotationRL(node) {
        node.right = this.rotationLL(node.right);
        return this.rotationRR(node);
    }
    getBalanceFactor(node) {
        const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);
        switch (heightDifference) {
        case - 2 : return BalanceFactor.UNBALANCED_RIGHT;
        case - 1 : return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;
        case 1:
            return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;
        case 2:
            return BalanceFactor.UNBALANCED_LEFT;
        default:
            return BalanceFactor.BALANCED;
        }
    }
    insert(key) {
        this.root = this.insertNode(this.root, key);
    }
    insertNode(node, key) {
        if (node == null) {
            return new Node(key);
        } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
            node.left = this.insertNode(node.left, key);
        } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
            node.right = this.insertNode(node.right, key);
        } else {
            return node; // duplicated key
        }
        // verify if tree is balanced
        const balanceFactor = this.getBalanceFactor(node);
        if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
            if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) {
                // Left left case
                node = this.rotationLL(node);
            } else {
                // Left right case
                return this.rotationLR(node);
            }
        }
        if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
            if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) {
                // Right right case
                node = this.rotationRR(node);
            } else {
                // Right left case
                return this.rotationRL(node);
            }
        }
        return node;
    }
    removeNode(node, key) {
        node = super.removeNode(node, key); // {1}
        if (node == null) {
            return node;
        }
        // verify if tree is balanced
        const balanceFactor = this.getBalanceFactor(node);
        if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
            // Left left case
            if (this.getBalanceFactor(node.left) === BalanceFactor.BALANCED || this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {
                return this.rotationLL(node);
            }
            // Left right case
            if (this.getBalanceFactor(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {
                return this.rotationLR(node.left);
            }
        }
        if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
            // Right right case
            if (this.getBalanceFactor(node.right) === BalanceFactor.BALANCED || this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {
                return this.rotationRR(node);
            }
            // Right left case
            if (this.getBalanceFactor(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {
                return this.rotationRL(node.right);
            }
        }
        return node;
    }
}
```
-->

<!--  -->

<hr>
<p>二叉树的性能取决于树的高度，最好的情况是完全二叉树，复杂度O(logN)，最差的情况是链表，复杂度O(N)。</p>
<p>红黑树是特殊的二叉树（可以自平衡），又称为对称二叉B树（Symmetric Binary B-Tree），可以进行高效的中序遍历，复杂度O(logN)。</p>
<p>红黑树不是标准平衡二叉树，不保证节点的左右子树的高度差不超过1，但不会超过一倍，因此，Java的TreeMap，JDK1.8中的HashMap都使用了红黑树。</p>
<p>HashMap在哈希冲突严重时，链表过长导致查找效率降低，红黑树可以解决这个问题。</p>
<p>TreeMap不保存相等节点，使用红黑树排序。</p>
<p>红黑树在二叉树的基础上加了一个标记（颜色），规则：</p>
<ol>
<li><p>每个节点是红色或者黑色；</p>
</li>
<li><p>根节点是黑色的；</p>
</li>
<li><p>所有的叶子节点都是是黑色的（这里的叶子节点是NIL节点，即空节点）；</p>
</li>
<li><p>红色节点的两个子节点都是黑色的（路径上不能有两个连续的红色节点）；</p>
</li>
<li><p>从任一节点到其子树的每个叶子节点的简单路径的黑色节点数量都相同（关键的平衡条件）；</p>
</li>
</ol>
<p>黑色高度：从根节点到叶子节点的路径上黑色节点的个数。</p>
<p>根据规则4和规则5，可以知道，任意节点到其每个叶子节点路径最长不会超过最短路径的两倍：</p>
<ul>
<li><p>当某条路径最短时，这条路径一定全都由黑色节点构成，假设黑色节点数量为N，则路径长度为N；</p>
</li>
<li><p>当某条路径最长时，这条路径一定由红色和黑色节点相间构成（规则4和规则5，不能出现两个连续的红色节点，任一节点到其每个叶子节点的所有路径黑色节点数量相同），则路径长为2N。</p>
</li>
</ul>
<p>旋转其实就是平衡左右子树的高度，高的变低，低的变高。</p>
<ul>
<li><p>右旋：将某个节点旋转为其左孩子的右孩子，同时把其左孩子的右孩子（如果有）变成自己的左孩子；</p>
</li>
<li><p>左旋：将某个节点旋转为其右孩子的左孩子，同时把其右孩子的左孩子（如果有）变成自己的右孩子；</p>
</li>
</ul>
<p>红黑树的插入和二叉树一样，查找、插入，然后调整结构（旋转）和重新着色，保证满足规则。</p>
<ul>
<li><p>当给一个红色节点插入一个红色子节点时，会违背规则4（连续的红色节点）。</p>
</li>
<li><p>当给一个节点插入一个黑色节点时，会违背规则5（另一边的路径黑色不平衡）。</p>
</li>
</ul>
<p>那么插入时只要将插入的节点设为红色，就不会影响规则5，只要满足规则4就行了。</p>
<p>红黑树的删除和二叉树类似，根据要删除的节点有没有子节点分为三种情况：没有子节点，只有一个子节点，有两个子节点。</p>
<p>对于有两个子节点的情况，先从右侧子树向左找到最小的节点，称为继承节点，那么该节点最多只有一个右孩子，用该节点的值替代要删除的节点的值，然后再删除该继承节点就行了，这样就转为了上面的两种情况。</p>
<ul>
<li><p>如果删除的节点是红色的，没有影响；</p>
</li>
<li><p>如果删除的节点是黑色的，需要调整；</p>
</li>
</ul>
<p>删除黑节点的时候，会使得该分支的黑色高度下降，使得两边的黑色高度不相等，需要重新平衡。</p>
<p>那么，问题就可以简化为，删除的节点是黑色，并且删除的节点有一个或没有子节点的情况就好了。</p>
<ul>
<li><p>如果删除的节点有一个子节点，那么会少一个黑色，子节点作为替代品处理黑色的平衡。</p>
</li>
<li><p>如果删除的节点没有子节点，那么先把要删除的节点作为虚拟的替代，平衡后另一侧就会多出一个黑色，此时再删除节点，两边正好平衡，问题再次简化。</p>
</li>
</ul>
<p><del>吭，时间比较赶，红黑树的删除部分我就不看了，我是个爱学习的好孩子。</del></p>
<p>好吧，我还是看了（不，一点也不香）。代码和图见TreeMap的笔记。</p>
<p>插入的关键是红色连续的重平衡，删除的关键是黑色数量的重平衡。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">RedBlackTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 红黑树的节点有红色和黑色两种</span>
    <span class="token keyword">let</span> Colors <span class="token operator">=</span> <span class="token punctuation">{</span>
        RED<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
        BLACK<span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 节点</span>
    <span class="token keyword">function</span> <span class="token function">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 切换节点的颜色</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>flipColor <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">===</span> Colors<span class="token punctuation">.</span>RED <span class="token operator">?</span> Colors<span class="token punctuation">.</span>BLACK <span class="token punctuation">:</span> Colors<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 节点是红色节点</span>
    <span class="token keyword">function</span> <span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// NIL节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>color <span class="token operator">===</span> Colors<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 分别反转节点的左右子节点的颜色</span>
    <span class="token keyword">function</span> <span class="token function">flipColors</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">flipColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">flipColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 自平衡，左旋某节点</span>
    <span class="token keyword">function</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            temp<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
            temp<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
            node<span class="token punctuation">.</span>color <span class="token operator">=</span> Colors<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 自平衡，右旋某节点，就是将它变成原来的左孩子的右孩子</span>
    <span class="token keyword">function</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 节点的左孩子节点</span>
        <span class="token keyword">let</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 首先得有个左孩子</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 设置自己的左孩子为原来的左孩子的右孩子</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> temp<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 将节点设为原来的左孩子的右孩子</span>
            temp<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 原本的左孩子继承该节点的颜色</span>
            temp<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 再把该节点设为红色</span>
            node<span class="token punctuation">.</span>color <span class="token operator">=</span> Colors<span class="token punctuation">.</span>RED<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 右旋后，它的左孩子就取代了该节点的位置</span>
        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 插入节点到一棵子树</span>
    <span class="token keyword">function</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 要插入到一个没有根节点的树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 返回树的根节点，执行真正的插入，新插入的节点为红色</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> Colors<span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 要插入的子树的根节点</span>
        <span class="token keyword">let</span> newRoot <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 插入的节点小于当前节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 递归，从左侧子节点开始，返回插入后的左侧子节点，并更新</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 插入的节点大于当前节点</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">></span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 递归，从到右侧子节点开始，返回插入后的右侧子节点，并更新</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 刚好等于，更不更新值都行，反正都相等</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 意思一下</span>
            node<span class="token punctuation">.</span>key <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 还要调整一下，为了描述方便，后面用根指代这棵子树的根节点</span>

        <span class="token comment" spellcheck="true">// 根的右孩子是红色 &amp;&amp; 根的左孩子是黑色（或者没有左孩子，NIL）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 把根左旋，返回新的子树的根</span>
            newRoot <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 根的左孩子是红色 &amp;&amp; 根的左孩子的左孩子也是红色</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 把根右旋，返回新的子树的根</span>
            newRoot <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 根的左孩子是红色 &amp;&amp; 根的右孩子也是红色</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 直接反转左右节点的颜色为黑色</span>
            <span class="token function">flipColors</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 新的根</span>
        <span class="token keyword">return</span> newRoot<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 插入节点到树</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>insert <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 插入节点，并返回新的根节点</span>
        root <span class="token operator">=</span> <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 根节点必须是黑色</span>
        root<span class="token punctuation">.</span>color <span class="token operator">=</span> Colors<span class="token punctuation">.</span>BLACK<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>除了B树，还有B-树、B+树、B*树，不过这些已经不是二叉树了，有兴趣的可以了解，我是没兴趣:)。</p>
<p>如果我还是个学生，大概会挺感兴趣吧，不过现在嘛，主要还是由投入和产出驱动的，不然就没完没了了😬。</p>
<p>而且算法这些，不经常用很快就忘了，必须得反复练习，即使今天看明白了，过两天如果面试官说：喂，手写一个红黑树的增删改查给我看看？</p>
<p>我：😲😕😨😰。</p>
<p>毕竟我也不是算法工程师，我对自己的要求是：看懂就行。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>

    <script src="/js/prism.js"></script>
</body>
</html>
