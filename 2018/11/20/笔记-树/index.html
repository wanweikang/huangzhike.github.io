<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-树 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-树"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-树</h2>
				
				<div>
					<span class="post-time">2018-11-20 20:15</span>
				</div>	
				
				<div class="article-content">
				<p>树的节点分为内部节点和外部节点。</p>
<p>至少有一个子节点的节点称为内部节点。</p>
<p>没有子元素的节点称为外部节点或叶节点。</p>
<p>树顶部的节点叫作根节点。</p>
<p>节点可以有祖先和后代。</p>
<p>节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。</p>
<p>节点的后代包括子节点、孙子节点、曾孙节点等。</p>
<p>子树由节点和它的后代构成。</p>
<p>节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。</p>
<p>二叉搜索树（BST）：节点最多只能有两个子节点，一个是左侧子节点，另一个是右侧子节点。在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。</p>
<p>每个节点包含两个指针，一个指向左侧子节点，另一个指向右侧子节点。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div></pre></td><td class="code"><pre><div class="line">class BinarySearchTree &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        this.root = undefined;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 向树中插入一个新的节点</div><div class="line">    insert(key) &#123;</div><div class="line">        // special case: first key</div><div class="line">        if (this.root == null) &#123;</div><div class="line">            // 如果插入的节点是树的第一个节点，就将根节点指向新节点</div><div class="line">            this.root = new <span class="keyword">Node</span><span class="title">(key</span>);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 将节点加在非根节点的其他位置</div><div class="line">            this.insertNode(this.root, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 传入当前节点（第一次是根节点）和要插入的节点</div><div class="line">    insertNode(<span class="keyword">node</span><span class="title">, key</span>) &#123;</div><div class="line">        // 新节点的键小于当前节点的键</div><div class="line">        if (key <span class="tag">&lt; node.key) &#123;</span></div><div class="line">            if (node.left == null) &#123;</div><div class="line">                node.left = new Node(key);</div><div class="line">            &#125; else &#123;</div><div class="line">                // 不断递归下一层</div><div class="line">                this.insertNode(node.left, key);</div><div class="line">            &#125;</div><div class="line">        &#125; else if (node.right == null) &#123;</div><div class="line">            node.right = new Node(key);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.insertNode(node.right, key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getRoot() &#123;</div><div class="line">        return this.root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 寻找一棵树或它的任意子树中的一个特定的值</div><div class="line">    search(key) &#123;</div><div class="line">        return this.searchNode(this.root, key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    searchNode(node, key) &#123;</div><div class="line">        if (node == null) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (key &lt; node.key) &#123;</div><div class="line">            return this.searchNode(node.left, key);</div><div class="line">        &#125; else if (key &gt; <span class="keyword">node</span>.<span class="title">key</span>) &#123;</div><div class="line">            return this.searchNode(<span class="keyword">node</span>.<span class="title">right</span>, key);</div><div class="line">        &#125;</div><div class="line">        // element is equal to <span class="keyword">node</span>.<span class="title">item</span></div><div class="line">        // 找的键和当前节点的键相等，返回<span class="literal">true</span>来表示找到</div><div class="line">        return <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 访问树的所有节点有三种方式：中序、先序和后序</div><div class="line">    // 中序遍历：上行顺序访问BST所有节点，也就是以从小到大的顺序访问所有节点，可以对树排序</div><div class="line">    inOrderTraverse(callback) &#123;</div><div class="line">        this.inOrderTraverseNode(this.root, callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    inOrderTraverseNode(<span class="keyword">node</span><span class="title">, callback</span>) &#123;</div><div class="line">        // 停止递归的判断条件</div><div class="line">        if (<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</div><div class="line">            // 递归访问左侧子节点 </div><div class="line">            this.inOrderTraverseNode(<span class="keyword">node</span>.<span class="title">left</span>, callback);</div><div class="line">            // 对这个节点进行操作（callback）</div><div class="line">            callback(<span class="keyword">node</span>.<span class="title">key</span>);</div><div class="line">            // 再访问右侧子节点</div><div class="line">            this.inOrderTraverseNode(<span class="keyword">node</span>.<span class="title">right</span>, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 先序遍历：以优先于后代节点的顺序访问每个节点，可以打印结构化的文档</div><div class="line">    preOrderTraverse(callback) &#123;</div><div class="line">        this.preOrderTraverseNode(this.root, callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    preOrderTraverseNode(<span class="keyword">node</span><span class="title">, callback</span>) &#123;</div><div class="line">        if (<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</div><div class="line">            // 先序遍历会先访问节点本身</div><div class="line">            callback(<span class="keyword">node</span>.<span class="title">key</span>);</div><div class="line">            // 然后再访问它的左侧子节点</div><div class="line">            this.preOrderTraverseNode(<span class="keyword">node</span>.<span class="title">left</span>, callback);</div><div class="line">            // 最后是右侧子节点</div><div class="line">            this.preOrderTraverseNode(<span class="keyword">node</span>.<span class="title">right</span>, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 后序遍历：先访问节点的后代节点，再访问节点本身，可以计算一个目录和子目录中所有文件空间的大小</div><div class="line">    postOrderTraverse(callback) &#123;</div><div class="line">        this.postOrderTraverseNode(this.root, callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    postOrderTraverseNode(<span class="keyword">node</span><span class="title">, callback</span>) &#123;</div><div class="line">        if (<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</div><div class="line">            // 先访问左侧子节点</div><div class="line">            this.postOrderTraverseNode(<span class="keyword">node</span>.<span class="title">left</span>, callback);</div><div class="line">            // 然后是右侧子节点</div><div class="line">            this.postOrderTraverseNode(<span class="keyword">node</span>.<span class="title">right</span>, callback);</div><div class="line">            // 最后是父节点本身</div><div class="line">            callback(<span class="keyword">node</span>.<span class="title">key</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    min() &#123;</div><div class="line">        return this.minNode(this.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从树中任意一个节点开始寻找最小的键</div><div class="line">    minNode(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        let current = <span class="keyword">node</span><span class="title">;</span></div><div class="line">        while (current != null &amp;&amp; current.left != null) &#123;</div><div class="line">            current = current.left;</div><div class="line">        &#125;</div><div class="line">        return current;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    max() &#123;</div><div class="line">        return this.maxNode(this.root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    maxNode(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        let current = <span class="keyword">node</span><span class="title">;</span></div><div class="line">        // 要找到最大的键，要沿着树的右边进行遍历，直到找到最右端的节点</div><div class="line">        // 寻找最小值，沿着树的左边，寻找最大值，沿着树的右边</div><div class="line">        while (current != null &amp;&amp; current.right != null) &#123;</div><div class="line">            current = current.right;</div><div class="line">        &#125;</div><div class="line">        return current;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    remove(key) &#123;</div><div class="line">        this.root = this.removeNode(this.root, key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 传入root和要移除的键作为参数</div><div class="line">    removeNode(<span class="keyword">node</span><span class="title">, key</span>) &#123;</div><div class="line">        // 如果正在检测的节点是null，那么说明键不存在于树中</div><div class="line">        if (<span class="keyword">node</span> <span class="title">== null</span>) &#123;</div><div class="line">            return undefined;</div><div class="line">        &#125;</div><div class="line">        // 如果要找的键比当前节点的值小</div><div class="line"></div><div class="line">        if (key <span class="tag">&lt; node.key) &#123;</span></div><div class="line">            // 沿着树的左边找到下一个节点</div><div class="line">            node.left = this.removeNode(node.left, key);</div><div class="line">            // 更新了节点左右指针的值，返回了更新后的节点，因为是引用类型</div><div class="line">            return node;</div><div class="line">        &#125;</div><div class="line">        // 如果要找的键比当前节点的值大</div><div class="line">        else if (key &gt; <span class="keyword">node</span>.<span class="title">key</span>) &#123;</div><div class="line">            // 沿着树的右边找到下一个节点</div><div class="line">            <span class="keyword">node</span>.<span class="title">right</span> = this.removeNode(<span class="keyword">node</span>.<span class="title">right</span>, key);</div><div class="line">            // 更新了节点左右指针的值，返回了更新后的节点</div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div><div class="line">        // key is equal to <span class="keyword">node</span>.<span class="title">item</span> handle <span class="number">3</span> special conditions</div><div class="line">        // <span class="number">1</span> - a leaf <span class="keyword">node</span> <span class="title">移除一个叶节点</span></div><div class="line">        // 2 - a <span class="keyword">node</span> <span class="title">with</span> only <span class="number">1</span> child 移除有一个左侧或右侧子节点的节点</div><div class="line">        // <span class="number">3</span> - a <span class="keyword">node</span> <span class="title">with</span> <span class="number">2</span> children 移除有两个子节点的节点</div><div class="line">        // 如果找到了要找的键（键和<span class="keyword">node</span>.<span class="title">key</span>相等），就要处理三种情况</div><div class="line">        // case <span class="number">1</span> 该节点是没有左右侧子节点的叶节点</div><div class="line">        if (<span class="keyword">node</span>.<span class="title">left</span> == null &amp;&amp; <span class="keyword">node</span>.<span class="title">right</span> == null) &#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= undefined</span>;</div><div class="line">            // 返回undefined来将对应的父节点指针赋予null值</div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div><div class="line">        // case <span class="number">2</span> 移除有一个左侧子节点或右侧子节点的节点</div><div class="line">        if (<span class="keyword">node</span>.<span class="title">left</span> == null) &#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= node</span>.right;</div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div><div class="line">        // case <span class="number">3</span> 要移除的节点有两个子节点——左侧子节点和右侧子节点</div><div class="line">        else if (<span class="keyword">node</span>.<span class="title">right</span> == null) &#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= node</span>.left;</div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div><div class="line">        // 找到了需要移除的节点后，需要找到它右边子树中最小的节点</div><div class="line">        const aux = this.minNode(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        // 用它右侧子树中最小节点的键去更新这个节点的值，节点被移除了</div><div class="line">        <span class="keyword">node</span>.<span class="title">key</span> = aux.key;</div><div class="line">        // 把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了</div><div class="line">        <span class="keyword">node</span>.<span class="title">right</span> = this.removeNode(<span class="keyword">node</span>.<span class="title">right</span>, aux.key);</div><div class="line">        // 向它的父节点返回更新后节点的引用</div><div class="line">        return <span class="keyword">node</span><span class="title">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <img src="/imgs/inOrderTraverseNode.PNG" alt="inOrderTraverseNode  by huangzhike"></p>
<p><code>inOrderTraverseNode(node.left, callback);</code>一直向左往里边走，到了最小的 node 3 ，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>,<code>node.right==null</code>, 这个节点的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点 node 5 执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback)</code> ，进入右边的 node 6，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>,<code>node.right==null</code>, 这个节点的<code>inOrderTraverseNode</code>结束；node 5 的<code>inOrderTraverseNode</code>结束；</p>
<p>原路返回，对上一个节点 node 7 执行<code>callback(node.key)</code>，然后<code>inOrderTraverseNode(node.right, callback);</code>，进入右边的节点 node 9，进入左边的节点 node 8 ，<code>node.left==null</code>，结束，执行<code>callback(node.key);</code>，略。。。</p>
<p>BST问题：取决于添加的节点数，树的一条边可能会非常深，阿德尔森-维尔斯和兰迪斯树（AVL树）解决了这个问题。</p>
<p>AVL树是自平衡二叉搜索树，任何一个节点左右两侧子树的高度之差最多为1，这种树会在添加或移除节点时尽量试着成为一棵完全树。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">const BalanceFactor = &#123;</div><div class="line">    UNBALANCED_RIGHT: <span class="number">1</span>,</div><div class="line">    SLIGHTLY_UNBALANCED_RIGHT: <span class="number">2</span>,</div><div class="line">    BALANCED: <span class="number">3</span>,</div><div class="line">    SLIGHTLY_UNBALANCED_LEFT: <span class="number">4</span>,</div><div class="line">    UNBALANCED_LEFT: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line">class AVLTree extends BinarySearchTree &#123;</div><div class="line">    constructor(compareFn = defaultCompare) &#123;</div><div class="line">        super(compareFn);</div><div class="line">        this.compareFn = compareFn;</div><div class="line">        this.root = null;</div><div class="line">    &#125;</div><div class="line">    getNodeHeight(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        if (<span class="keyword">node</span> <span class="title">== null</span>) &#123;</div><div class="line">            return - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        return Math.max(this.getNodeHeight(<span class="keyword">node</span>.<span class="title">left</span>), this.getNodeHeight(<span class="keyword">node</span>.<span class="title">right</span>)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">   * Left left case: rotate right</div><div class="line">   *</div><div class="line">   *       b                           a</div><div class="line">   *      / \                         / \</div><div class="line">   *     a   e -&gt; rotationLL(b) -&gt;   c   b</div><div class="line">   *    / \                             / \</div><div class="line">   *   c   d                           d   e</div><div class="line">   *</div><div class="line">   * @param <span class="keyword">node</span> <span class="title">Node</span><span class="tag">&lt;T&gt;</span></div><div class="line">   */</div><div class="line">    rotationLL(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        const tmp = <span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">        <span class="keyword">node</span>.<span class="title">left</span> = tmp.right;</div><div class="line">        tmp.right = <span class="keyword">node</span><span class="title">;</span></div><div class="line">        return tmp;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">   * Right right case: rotate left</div><div class="line">   *</div><div class="line">   *     a                              b</div><div class="line">   *    / \                            / \</div><div class="line">   *   c   b   -&gt; rotationRR(a) -&gt;    a   e</div><div class="line">   *      / \                        / \</div><div class="line">   *     d   e                      c   d</div><div class="line">   *</div><div class="line">   * @param <span class="keyword">node</span> <span class="title">Node</span><span class="tag">&lt;T&gt;</span></div><div class="line">   */</div><div class="line">    rotationRR(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        const tmp = <span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">        <span class="keyword">node</span>.<span class="title">right</span> = tmp.left;</div><div class="line">        tmp.left = <span class="keyword">node</span><span class="title">;</span></div><div class="line">        return tmp;</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">   * Left right case: rotate left then right</div><div class="line">   * @param <span class="keyword">node</span> <span class="title">Node</span><span class="tag">&lt;T&gt;</span></div><div class="line">   */</div><div class="line">    rotationLR(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        node.left = this.rotationRR(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">        return this.rotationLL(<span class="keyword">node</span><span class="title">);</span></div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">   * Right left case: rotate right then left</div><div class="line">   * @param <span class="keyword">node</span> <span class="title">Node</span><span class="tag">&lt;T&gt;</span></div><div class="line">   */</div><div class="line">    rotationRL(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        node.right = this.rotationLL(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        return this.rotationRR(<span class="keyword">node</span><span class="title">);</span></div><div class="line">    &#125;</div><div class="line">    getBalanceFactor(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">        const heightDifference = this.getNodeHeight(<span class="keyword">node</span>.<span class="title">left</span>) - this.getNodeHeight(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">        switch (heightDifference) &#123;</div><div class="line">        case - <span class="number">2</span> : return BalanceFactor.UNBALANCED_RIGHT;</div><div class="line">        case - <span class="number">1</span> : return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;</div><div class="line">        case <span class="number">1</span>:</div><div class="line">            return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;</div><div class="line">        case <span class="number">2</span>:</div><div class="line">            return BalanceFactor.UNBALANCED_LEFT;</div><div class="line">        default:</div><div class="line">            return BalanceFactor.BALANCED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    insert(key) &#123;</div><div class="line">        this.root = this.insertNode(this.root, key);</div><div class="line">    &#125;</div><div class="line">    insertNode(<span class="keyword">node</span><span class="title">, key</span>) &#123;</div><div class="line">        if (<span class="keyword">node</span> <span class="title">== null</span>) &#123;</div><div class="line">            return new <span class="keyword">Node</span><span class="title">(key</span>);</div><div class="line">        &#125; else if (this.compareFn(key, <span class="keyword">node</span>.<span class="title">key</span>) === Compare.LESS_THAN) &#123;</div><div class="line">            <span class="keyword">node</span>.<span class="title">left</span> = this.insertNode(<span class="keyword">node</span>.<span class="title">left</span>, key);</div><div class="line">        &#125; else if (this.compareFn(key, <span class="keyword">node</span>.<span class="title">key</span>) === Compare.BIGGER_THAN) &#123;</div><div class="line">            <span class="keyword">node</span>.<span class="title">right</span> = this.insertNode(<span class="keyword">node</span>.<span class="title">right</span>, key);</div><div class="line">        &#125; else &#123;</div><div class="line">            return <span class="keyword">node</span><span class="title">; // duplicated</span> key</div><div class="line">        &#125;</div><div class="line">        // verify if tree is balanced</div><div class="line">        const balanceFactor = this.getBalanceFactor(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</div><div class="line">            if (this.compareFn(key, <span class="keyword">node</span>.<span class="title">left</span>.key) === Compare.LESS_THAN) &#123;</div><div class="line">                // Left left case</div><div class="line">                <span class="keyword">node</span> <span class="title">= this</span>.rotationLL(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125; else &#123;</div><div class="line">                // Left right case</div><div class="line">                return this.rotationLR(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</div><div class="line">            if (this.compareFn(key, <span class="keyword">node</span>.<span class="title">right</span>.key) === Compare.BIGGER_THAN) &#123;</div><div class="line">                // Right right case</div><div class="line">                <span class="keyword">node</span> <span class="title">= this</span>.rotationRR(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125; else &#123;</div><div class="line">                // Right left case</div><div class="line">                return this.rotationRL(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return <span class="keyword">node</span><span class="title">;</span></div><div class="line">    &#125;</div><div class="line">    removeNode(<span class="keyword">node</span><span class="title">, key</span>) &#123;</div><div class="line">        <span class="keyword">node</span> <span class="title">= super</span>.removeNode(<span class="keyword">node</span><span class="title">, key</span>); // &#123;<span class="number">1</span>&#125;</div><div class="line">        if (<span class="keyword">node</span> <span class="title">== null</span>) &#123;</div><div class="line">            return <span class="keyword">node</span><span class="title">;</span></div><div class="line">        &#125;</div><div class="line">        // verify if tree is balanced</div><div class="line">        const balanceFactor = this.getBalanceFactor(<span class="keyword">node</span><span class="title">);</span></div><div class="line">        if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123;</div><div class="line">            // Left left case</div><div class="line">            if (this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">left</span>) === BalanceFactor.BALANCED || this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">left</span>) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</div><div class="line">                return this.rotationLL(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125;</div><div class="line">            // Left right case</div><div class="line">            if (this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">left</span>) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</div><div class="line">                return this.rotationLR(<span class="keyword">node</span>.<span class="title">left</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123;</div><div class="line">            // Right right case</div><div class="line">            if (this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">right</span>) === BalanceFactor.BALANCED || this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">right</span>) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123;</div><div class="line">                return this.rotationRR(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            &#125;</div><div class="line">            // Right left case</div><div class="line">            if (this.getBalanceFactor(<span class="keyword">node</span>.<span class="title">right</span>) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123;</div><div class="line">                return this.rotationRL(<span class="keyword">node</span>.<span class="title">right</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return <span class="keyword">node</span><span class="title">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>红黑树是一种特殊的二叉树，可以进行高效的中序遍历。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">function RedBlackTree() &#123;</div><div class="line"></div><div class="line">	let Colors = &#123;</div><div class="line">		RED: <span class="number">0</span>,</div><div class="line">		BLACK: <span class="number">1</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function <span class="keyword">Node</span><span class="title">(key</span>, color) &#123;</div><div class="line">		this.key = key;</div><div class="line">		this.left = null;</div><div class="line">		this.right = null;</div><div class="line">		this.color = color;</div><div class="line"></div><div class="line">		this.flipColor = function() &#123;</div><div class="line">			if (this.color === Colors.RED) &#123;</div><div class="line">				this.color = Colors.BLACK;</div><div class="line">			&#125; else &#123;</div><div class="line">				this.color = Colors.RED;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	let root = null;</div><div class="line"></div><div class="line">	this.getRoot = function() &#123;</div><div class="line">		return root;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function isRed(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">		if (!<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">			return <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		return <span class="keyword">node</span>.<span class="title">color</span> === Colors.RED;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function flipColors(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">		node.left.flipColor();</div><div class="line">		<span class="keyword">node</span>.<span class="title">right</span>.flipColor();</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function rotateLeft(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">		let temp = <span class="keyword">node</span>.<span class="title">right</span>;</div><div class="line">		if (temp !== null) &#123;</div><div class="line">			<span class="keyword">node</span>.<span class="title">right</span> = temp.left;</div><div class="line">			temp.left = <span class="keyword">node</span><span class="title">;</span></div><div class="line">			temp.color = <span class="keyword">node</span>.<span class="title">color</span>;</div><div class="line">			<span class="keyword">node</span>.<span class="title">color</span> = Colors.RED;</div><div class="line">		&#125;</div><div class="line">		return temp;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function rotateRight(<span class="keyword">node</span><span class="title">) &#123;</span></div><div class="line">		let temp = <span class="keyword">node</span>.<span class="title">left</span>;</div><div class="line">		if (temp !== null) &#123;</div><div class="line">			<span class="keyword">node</span>.<span class="title">left</span> = temp.right;</div><div class="line">			temp.right = <span class="keyword">node</span><span class="title">;</span></div><div class="line">			temp.color = <span class="keyword">node</span>.<span class="title">color</span>;</div><div class="line">			<span class="keyword">node</span>.<span class="title">color</span> = Colors.RED;</div><div class="line">		&#125;</div><div class="line">		return temp;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	function insertNode(<span class="keyword">node</span><span class="title">, element</span>) &#123;</div><div class="line"></div><div class="line">		if (<span class="keyword">node</span> <span class="title">=== null</span>) &#123;</div><div class="line">			return new <span class="keyword">Node</span><span class="title">(element</span>, Colors.RED);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		let newRoot = <span class="keyword">node</span><span class="title">;</span></div><div class="line"></div><div class="line">		if (element <span class="tag">&lt; node.key) &#123;</span></div><div class="line"></div><div class="line">			node.left = insertNode(node.left, element);</div><div class="line"></div><div class="line">		&#125; else if (element &gt; <span class="keyword">node</span>.<span class="title">key</span>) &#123;</div><div class="line"></div><div class="line">			<span class="keyword">node</span>.<span class="title">right</span> = insertNode(<span class="keyword">node</span>.<span class="title">right</span>, element);</div><div class="line"></div><div class="line">		&#125; else &#123;</div><div class="line">			<span class="keyword">node</span>.<span class="title">key</span> = element;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (isRed(<span class="keyword">node</span>.<span class="title">right</span>) &amp;&amp; !isRed(<span class="keyword">node</span>.<span class="title">left</span>)) &#123;</div><div class="line">			newRoot = rotateLeft(<span class="keyword">node</span><span class="title">);</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		if (isRed(<span class="keyword">node</span>.<span class="title">left</span>) &amp;&amp; isRed(<span class="keyword">node</span>.<span class="title">left</span>.left)) &#123;</div><div class="line">			newRoot = rotateRight(<span class="keyword">node</span><span class="title">);</span></div><div class="line">		&#125;</div><div class="line">		if (isRed(<span class="keyword">node</span>.<span class="title">left</span>) &amp;&amp; isRed(<span class="keyword">node</span>.<span class="title">right</span>)) &#123;</div><div class="line">			flipColors(<span class="keyword">node</span><span class="title">);</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return newRoot;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	this.insert = function(element) &#123;</div><div class="line">		root = insertNode(root, element);</div><div class="line">		root.color = Colors.BLACK;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2018 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
