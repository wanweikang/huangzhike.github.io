<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-JMM | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-JMM">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-JMM</h2>
				
				<div>
					<div class="post-time">2018-11-17</div>
				</div>
				
				<div class="article-content">
				<p>计算机内存模型</p>
<p>计算机指令是在CPU中执行的，程序运行的临时数据是放在主存（物理内存）当中的，CPU执行速度比内存读写快得多，如果任何操作都通过内存进行，会大大降低速度。</p>
<p>因此运行过程中，会从主存复制一份到CPU的高速缓存当中，直接从高速缓存读写数据，结束之后再将高速缓存中的数据刷新到主存当中。</p>
<p>如：<code>i = i + 1</code>;</p>
<p>先从主存读取i的值，然后复制一份到高速缓存，然后 CPU 执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存。</p>
<p>比如同时有两个线程执行这段代码，假如初始时i的值为0，希望两个线程执行完之后i的值变为2。</p>
<p>缓存一致性问题：初始时，两个线程分别读取i的值存入各自所在的 CPU 的高速缓存当中，然后线程1 进行加1操作，然后把i的最新值1写入到内存。</p>
<p>此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存，最终结果i的值是1，而不是2。</p>
<p>通常有两种解决方法（硬件层面）：</p>
<ul>
<li><p>在总线加LOCK#锁</p>
<ul>
<li>CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。</li>
</ul>
</li>
<li><p>通过缓存一致性协议</p>
<ul>
<li><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。</p>
</li>
<li><p>当其他CPU需要读取这个变量时，发现自己缓存中该变量是无效的，就会从内存重新读取。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>Java内存模型</p>
<p>Java Memory Model 屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问效果。</p>
<p>系统存在一个主内存，Java中所有实例变量都储存在主存中，对于所有线程都是共享的。</p>
<p>每条线程都有自己的工作内存，线程对变量的操作（读取、赋值等）都在工作内存中进行，不能直接对主存进行操作。</p>
<p>不同的线程间无法直接访问对方工作内存，线程间变量值的传递通过主内存完成。</p>
<p>工作内存由缓存和堆栈两部分组成。</p>
<ul>
<li><p>缓存中保存的是主存中变量的拷贝，缓存可能并不和主存同步，缓存中变量的修改可能没有立刻写到主存中；</p>
</li>
<li><p>堆栈中保存的是线程的局部变量，线程之间无法相互直接访问堆栈中的变量。</p>
</li>
</ul>
<p>假设线程访问一个10MB的对象，不会把这10MB的内存复制一份，但是这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，不会把整个对象拷贝一次。</p>
<p>Java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>如：<code>i = 10;</code>，执行线程先在自己的工作线程中对变量i所在的缓存行进行赋值，再写入主存，而不是直接写入主存。 </p>
<p>Java中，对基本数据类型的变量的读取和赋值操作是原子性操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = 10; // 原子性</span><br><span class="line"> </span><br><span class="line">y = x; // 非原子性，包含2个操作，先读取x的值，再将x的值写入工作内存</span><br><span class="line"> </span><br><span class="line">x++; // 非原子性</span><br><span class="line"> </span><br><span class="line">x = x + 1; // 非原子性</span><br></pre></td></tr></table></figure>
<p>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>JMM只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过加锁来实现。</p>
<p><code>synchronized</code>和<code>Lock</code>能够保证任一时刻只有一个线程执行该代码块，自然就不存在原子性问题。</p>
<hr>
<p>可见性：多个线程访问同一个变量时，一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的（可见）。</p>
<p><code>synchronized</code>，<code>final</code>，<code>volatile</code>能实现可见性。</p>
<p>假如线程1先执行，线程2后执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 线程1</span><br><span class="line">boolean stop = false;</span><br><span class="line">while (!stop) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">// 线程2</span><br><span class="line">stop = true;</span><br></pre></td></tr></table></figure></p>
<p>每个线程在运行过程中都有自己的工作内存，线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，线程1不知道线程2对stop变量的更改，还会一直循环下去。</p>
<p><code>volatile</code>会强制将修改的值立即写入主存，当线程2修改stop值时（包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存）会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效），线程1会等待缓存行对应的主存地址被更新之后，然后去主存读取最新的值。</p>
<p>当一个共享变量被<code>volatile</code>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，会去内存中读取新值。</p>
<p>普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，无法保证可见性。</p>
<p><code>synchronized</code>和<code>Lock</code>也能够保证可见性，同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。</p>
<p><code>volatile</code>第二个语义是禁止指令重排序优化。</p>
<p><code>volatile</code>关键字能禁止指令重排序，所以<code>volatile</code>能在一定程度上保证有序性。</p>
<p><code>volatile</code>会多出一个<code>lock</code>前缀指令<code>lock</code>前缀指令，相当于一个内存屏障：</p>
<ul>
<li><p>指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面（执行到内存屏障这句指令时，它前面的操作已经全部完成）；</p>
</li>
<li><p>强制将对缓存的修改操作立即写入主存，写操作会导致其他CPU中对应的缓存行无效。</p>
</li>
<li><p>对一个<code>volatile</code>变量的读，总是能看到（任意线程）对这个<code>volatile</code>变量最后的写入。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1; // 1</span><br><span class="line">int b = 2; // 2</span><br><span class="line">int c = a + b; // 3</span><br></pre></td></tr></table></figure>
<p>理想情况下执行顺序是： 1 &gt; 2 &gt; 3。但可能经过 JVM 优化之后的执行顺序变为了 2 &gt; 1 &gt; 3。</p>
<p>不管怎么优化，前提都是单线程中最终结果不变的情况下进行的。</p>
<p>有序性：</p>
<ul>
<li><p>如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；</p>
</li>
<li><p>如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序、工作内存与主内存同步延迟）。</p>
</li>
</ul>
<p><code>volatile</code>和<code>synchronized</code>可以保证线程之间操作的有序性。</p>
<ul>
<li><p><code>volatile</code>：就包含了禁止指令重排序的语义。</p>
</li>
<li><p><code>synchronized</code>：一个变量在同一个时刻只允许一条线程对其进行lock操作，持有同一个锁的两个同步块只能串行地进入。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// x、y为非volatile变量</span><br><span class="line">// flag为volatile变量</span><br><span class="line"></span><br><span class="line">x = 2; // 语句1</span><br><span class="line"></span><br><span class="line">y = 0; // 语句2</span><br><span class="line"></span><br><span class="line">flag = true; // 语句3</span><br><span class="line"></span><br><span class="line">x = 4; // 语句4</span><br><span class="line"></span><br><span class="line">y = - 1; // 语句5</span><br></pre></td></tr></table></figure>
<p>由于flag变量<code>volatile</code>变量，在指令重排序的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。</p>
<p>但是语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p><code>volatile</code>能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<ul>
<li><p>当第二个操作是<code>volatile</code>写时，不管第一个操作是什么，都不能重排序，确保<code>volatile</code>写之前的操作不会被重排序到<code>volatile</code>写之后。</p>
</li>
<li><p>当第一个操作是<code>volatile</code>读时，不管第二个操作是什么，都不能重排序，确保<code>volatile</code>读之后的操作不会被重排序到<code>volatile</code>读之前。</p>
</li>
<li><p>当第一个操作是<code>volatile</code>写，第二个操作是<code>volatile</code>读时，不能重排序。</p>
</li>
</ul>
<ul>
<li><p>线程A写一个<code>volatile</code>变量，实质上是线程A向接下来将要读这个<code>volatile</code>变量的某个线程发出了（其对共享变量所在修改的）消息。</p>
</li>
<li><p>线程B读一个<code>volatile</code>变量，实质上是线程B接收了之前某个线程发出的（在写这个<code>volatile</code>变量之前对共享变量所做修改的）消息。</p>
</li>
<li><p>线程A写一个<code>volatile</code>变量，随后线程B读这个<code>volatile</code>变量，实质上是线程A通过主内存向线程B发送消息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">    int x = 0, y = 0;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        int r1 = y;</span><br><span class="line">        int r2 = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在两个并发线程中执行这段代码，读取Y变量将会得到2这个值。</p>
<p>因为这个写入比写到X变量更晚一些，程序员可能认为读取X变量将肯定会得到1。</p>
<p>但是，写入操作可能被重排序过。如果重排序发生了，可能是r1变量的值是2，但是r2变量的值为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    volatile boolean v = false;</span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        x = 42;</span><br><span class="line">        v = true;</span><br><span class="line">    &#125;</span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (v == true) &#123;</span><br><span class="line">            // uses x - guaranteed to see 42.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设一个线程叫做“writer”，另外一个线程叫做“reader”。</p>
<p>对变量v的写操作会等到变量x写入到内存之后，然后读线程就可以看见v的值。</p>
<p>因此，如果reader线程看到了v的值为true，那么也保证能够看到在之前发生的写入42这个操作。</p>
<p>如果v不是<code>volatile</code>变量，编译器可以在writer线程中重排序写入操作，reader线程中的读取x变量的操作可能会看到0。</p>
<p>假如有两个线程分别读写<code>volatile</code>变量时，线程 A 写入了某<code>volatile</code>变量，线程 B 在读取该<code>volatile</code>变量时，便能看到线程 A 对该<code>volatile</code>变量的写入操作，它不仅会看到对该<code>volatile</code>变量的写入操作，A 线程在写<code>volatile</code>变量之前所有可见的共享变量，在 B 线程读同一个<code>volatile</code>变量后，都立即变得对 B 线程可见。</p>
<p>同步块<code>synchronized</code>的可见性：对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</p>
<p><code>volatile</code>变量只能保证可见性，不能保证对变量的操作是原子性，在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性。</p>
<ul>
<li><p>运算结果不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他的状态变量共同参与不变约束。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread() &#123;</span><br><span class="line">                ()-&gt; &#123;</span><br><span class="line">                   for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                        test.increase();</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            .start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">            Thread.yield(); // 保证前面的线程都执行完</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可见性只能保证每次读取的是最新的值，但<code>volatile</code>没法保证对变量的操作的原子性。</p>
<p>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。</p>
<p>自增操作的三个子操作可能会分割开执行，可能出现：</p>
<ul>
<li><p>假如某个时刻变量inc的值为10，线程1对变量进行自增操作：线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
</li>
<li><p>然后线程2对变量进行自增操作：线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，不会导致线程2的工作内存中缓存变量inc的缓存行无效，线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
</li>
<li><p>线程1接着进行加1操作，由于已经读取了inc的值，此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
</li>
<li><p>两个线程分别进行了一次自增操作后，inc只增加了1。</p>
</li>
</ul>
<p>解决方法：对提供原子性的自增操作即可（<code>java.util.concurrent.atomic</code>）。</p>
<p>atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<hr>
<p>JMM中定义了 8 种操作来完成主内存与工作内存之间交互：</p>
<ul>
<li><p>lock（锁定）：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。</p>
</li>
<li><p>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>
</li>
<li><p>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便随后的 load 动作使用。</p>
</li>
<li><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时将会执行这个操作。</p>
</li>
<li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
</li>
<li><p>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的 write 操作使用。</p>
</li>
<li><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存的变量中。</p>
</li>
</ul>
<hr>
<p>当一个变量被定义成<code>volatile</code>之后，他将具备两种特性：</p>
<ul>
<li><p>保证此变量对所有线程的可见性。<code>volatile</code>变量的写操作除了对它本身的读操作可见外，<code>volatile</code>写操作之前的所有共享变量均对<code>volatile</code>读操作之后的操作可见。</p>
</li>
<li><p>禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致，在单线程中是无法感知这一点的。</p>
</li>
</ul>
<hr>
<ul>
<li><p><code>volatile</code>变量是一种稍弱的同步机制，在访问<code>volatile</code>变量时不会执行加锁操作，因此也就不会使执行线程阻塞。</p>
</li>
<li><p>从内存可见性的角度看，写入<code>volatile</code>变量相当于退出同步代码块，而读取<code>volatile</code>变量相当于进入同步代码块。</p>
</li>
<li><p>加锁机制（同步机制）既可以确保可见性又可以确保原子性，而<code>volatile</code>变量只能确保可见性。</p>
</li>
<li><p>当且仅当满足以下条件时，才使用<code>volatile</code>变量：</p>
<ul>
<li><p>对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><code>final</code>域是不能修改的，在JMM中，<code>final</code>域能确保初始化过程的安全性，在共享这些对象时无须同步。</p>
<p><code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>this</code>的引用传递出去（<code>this</code>引用逃逸是很危险的，其他线程有可能通过这个引用访问到初始化未完成的对象），在其他线程中就能看到<code>final</code>字段的值。</p>
<ul>
<li><p>在构造函数内对一个<code>final</code>域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
</li>
<li><p>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序。</p>
</li>
</ul>
<p><code>final</code>域是基础数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class FinalExample &#123;</span><br><span class="line">    static FinalExample obj;</span><br><span class="line">    int i; // 普通变量 </span><br><span class="line">    final int j; // final 变量 </span><br><span class="line">    public void FinalExample() &#123; // 构造函数 </span><br><span class="line">        i = 1; // 写普通域 </span><br><span class="line">        j = 2; // 写 final 域 </span><br><span class="line">    &#125;</span><br><span class="line">    public static void writer() &#123; // 写线程 A 执行 </span><br><span class="line">        obj = new FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void reader() &#123; // 读线程 B 执行 </span><br><span class="line">        FinalExample object = obj; // 读对象引用 </span><br><span class="line">        int a = object.i; // 读普通域 </span><br><span class="line">        int b = object.j; // 读 final 域 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设一个线程 A 执行<code>writer()</code>方法，随后另一个线程 B 执行<code>reader()</code>方法，假设线程 B 读对象引用与读对象的成员域之间没有重排序。</p>
<p>writer ()：<code>finalExample = new FinalExample ()</code>：</p>
<ul>
<li><p>构造一个 FinalExample 类型的对象；</p>
</li>
<li><p>把这个对象的引用赋值给引用变量 obj。</p>
</li>
</ul>
<p>写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。</p>
<p>写<code>final</code>域的操作，被写<code>final</code>域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了<code>final</code>变量初始化之后的值。</p>
<p>写<code>final</code>域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的<code>final</code>域已经被正确初始化过了，而普通域不具有这个保障。</p>
<p>reader()：</p>
<ul>
<li><p>初次读引用变量 obj;</p>
</li>
<li><p>初次读引用变量 obj 指向对象的普通域 j。</p>
</li>
<li><p>初次读引用变量 obj 指向对象的 final 域 i。</p>
</li>
</ul>
<p>假设写线程 A 没有发生任何重排序。</p>
<p>读对象的普通域的操作被处理器重排序到读对象引用之前。</p>
<p>读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。</p>
<p>读<code>final</code>域的重排序规则会把读对象<code>final</code>域的操作“限定”在读对象引用之后，此时该<code>final</code>域已经被 A 线程初始化过了，这是一个正确的读取操作。</p>
<p>读<code>final</code>域的重排序规则可以确保：在读一个对象的<code>final</code>域之前，一定会先读包含这个<code>final</code>域的对象的引用。</p>
<p><code>final</code>域是引用类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceExample &#123;</span><br><span class="line">    static FinalReferenceExample obj;</span><br><span class="line">    final int[] intArray; // final 是引用类型 </span><br><span class="line"></span><br><span class="line">    public FinalReferenceExample() &#123; // 构造函数 </span><br><span class="line">        intArray = new int[1]; // 1</span><br><span class="line">        intArray[0] = 1; // 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writerOne() &#123; // 写线程 A 执行 </span><br><span class="line">        obj = new FinalReferenceExample(); // 3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writerTwo() &#123; // 写线程 B 执行 </span><br><span class="line">        obj.intArray[0] = 2; // 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123; // 读线程 C 执行 </span><br><span class="line">        if (obj != null) &#123; // 5</span><br><span class="line">            int temp1 = obj.intArray[0]; // 6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数内对一个<code>final</code>引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
<p>首先线程 A 执行<code>writerOne()</code>方法，执行完后线程 B 执行<code>writerTwo()</code>方法，执行完后线程 C 执行 <code>reader()</code>方法。</p>
<p>1 是对<code>final</code>域的写入，2 是对这个<code>final</code>域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。</p>
<p>1 不能和 3 重排序，2 和 3 也不能重排序。</p>
<p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对<code>final</code>引用对象的成员域的写入，即 C 至少能看到数组下标 0 的值为 1。</p>
<p>而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。</p>
<p>JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p>
<p>如果想要确保读线程 C 看到写线程 B 对数组元素的写入，写线程 B 和读线程 C 之间需要使用同步来确保内存可见性。</p>
<p>写<code>final</code>域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的<code>final</code>域已经在构造函数中被正确初始化过了。</p>
<p>前提：对象引用不能在构造函数中“逸出”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FinalReferenceEscapeExample &#123;</span><br><span class="line">    static FinalReferenceEscapeExample obj;</span><br><span class="line">    final int i;</span><br><span class="line"></span><br><span class="line">    public FinalReferenceEscapeExample() &#123;</span><br><span class="line">        i = 1; // 1 写 final 域 </span><br><span class="line">        obj = this; // 2 this 引用在此“逸出”</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void writer() &#123;</span><br><span class="line">        new FinalReferenceEscapeExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void reader() &#123;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            int temp = obj.i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>先行发生原则</p>
<p>操作A先行发生于操作B，就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int value = 0;</span><br><span class="line"></span><br><span class="line">pubilc void setValue(int value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设存在线程A和B，线程A先（时间上的先后）调用了“setValue”，然后线程B调用了同一个对象的“getValue”，线程B收到的返回值是不确定的。</p>
<p>要么把getter/setter方法都定义为<code>synchronized</code>方法，要么把value定义为<code>volatile</code>变量，setter方法对value的修改不依赖value的原值。</p>
<hr>
<p>线程安全的实现方法</p>
<p>1.互斥同步（Mutual Exclusion＆Synchronization）</p>
<p>同步是指在多个线程并发访问共享数据时，共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。</p>
<p>互斥是实现同步的手段，临界区（CriticalSection）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p>
<ul>
<li><p>最基本的互斥同步就是<code>synchronized</code>，编译后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。</p>
<ul>
<li><p>对于同步方法，锁是当前实例对象的reference。</p>
</li>
<li><p>对于静态同步方法，锁是当前对象的Class对象的reference。</p>
</li>
<li><p>对于同步方法块，锁是<code>synchronized</code>括号里配置的对象的reference。</p>
</li>
</ul>
</li>
<li><p>执行<code>monitorenter</code>指令时，首先要尝试获取对象的锁。</p>
</li>
<li><p>如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行<code>monitorexit</code>指令时会将锁计数器减1，当计数器为0时，锁就被释放。</p>
</li>
<li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
</li>
<li><p><code>synchronized</code>同步块对同一条线程来说是可重入的，不会把自己锁死，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</p>
</li>
<li><p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞，然而，由于锁是可重入的，因此如果线程试图获得一个已经由它自己持有的锁，请求就会成功。</p>
</li>
<li><p>重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。</p>
<ul>
<li><p>当计数值为 0 时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1。</p>
</li>
<li><p>如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。</p>
</li>
<li><p>当计数值为 0 时，这个锁将被释放。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    public synchronized void doSomething() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Father &#123;</span><br><span class="line">    public synchronized void doSomething() &#123;</span><br><span class="line">        super.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类覆写了父类的同步方法，然后调用父类中的方法，如果没有可重入锁，将产生死锁。</p>
<p><code>Father</code>和<code>Child</code>中的<code>doSomething</code>方法都是<code>synchronized</code>方法，因此每个<code>doSomething</code>方法在执行前都会获取<code>Child</code>对象实例上的锁。</p>
<p>如果内置锁不是可重入的，在调用<code>super.doSomething</code>时将无法获得该<code>Child</code>对象上的互斥锁，因为这个锁已经被持有，线程会阻塞下去等待一个永远也无法获取的锁。</p>
<p>Java的线程是映射到操作系统的原生线程上的，阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，状态转换需要耗费很多的处理器时间。</p>
<p>互斥同步属于悲观的并发策略，认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的会竞争，都要进行加锁（概念模型，虚拟机会优化掉不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<p>2.非阻塞同步（Non-Blocking Synchronization）</p>
<p>随着硬件指令集的发展，有了另外一个选择：基于冲突检测的乐观并发策略。</p>
<ul>
<li><p>先进行操作，如果没有其他线程争用共享数据，那操作就成功了；</p>
</li>
<li><p>如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（不断地重试，直到成功）。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    for ( ; ) &#123;</span><br><span class="line">        int current = get();</span><br><span class="line">        int next = current + 1;</span><br><span class="line">        if(compareAndSet(current, next))</span><br><span class="line">           return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementAndGet</code>方法在一个循环中，不断尝试将一个比当前值大1的新值赋给自己，如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。</p>
<p>尽管CAS看起来很美，但是存在漏洞（“ABA”问题）：</p>
<ul>
<li><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那能说它的值没有被其他线程改变过了吗？</p>
</li>
<li><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。</p>
</li>
</ul>
<p>3.无同步</p>
<p>要保证线程安全，并不是一定就要进行同步，同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，就无须任何同步。</p>
<p>线程本地存储（Thread Local Storage）：</p>
<ul>
<li><p>如果一个变量要被某个线程独享，可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能。</p>
</li>
<li><p>每个<code>Thread</code>线程对象都有一个<code>ThreadLocalMap</code>对象，当在某个线程中访问时，会取出这个线程自己的<code>ThreadLocalMap</code>并且用当前<code>ThreadLocal</code>对象做索引（<code>threadLocalHashCode</code>）来取出相对应的Value值，从而达到不同线程不同值的效果。</p>
</li>
<li><p><code>ThreadLocalMap</code>里的<code>Entry</code>对象是一个<code>WeakReference&lt;ThreadLocal&gt;</code> ，对<code>ThreadLocal</code>对象的弱引用，如果<code>ThreadLocal</code>对象没有外部强引用指向它，该<code>ThreadLocal</code>随时可能会被回收，导致Value的Key是<code>null</code>（需要把这样的<code>Entry</code>给remove掉，避免内存泄漏)，而程序中也无法访问这些key为null的<code>Entry</code>，如果当前线程不结束的话（尤其是线程池线程复用），这个key为null的<code>Entry</code>的value就会一直存在从GCRoots过来的强引用链，即在threadLocal设为<code>null</code>和线程结束前这段时间内<code>Entry</code>不会被回收，造成了内存泄漏。</p>
</li>
<li><p>因为线程的声明周期是长于<code>ThreadLocal</code>对象的，当此对象不再需要的时候如果线程中还持有它的引用也会产生内存泄漏的问题，所以应该是用弱引用来进行key的保存。</p>
</li>
<li><p>建议将<code>ThreadLocal</code>变量定义为<code>private static</code>，这样<code>ThreadLocal</code>对象的生命周期就长（一直存在<code>ThreadLocal</code>对象的强引用，所以它不会被回收），从而能保证任何时候都能根据<code>ThreadLocal</code>的弱引用访问到<code>Entry</code>的value值，在用完后调用<code>remove</code>方法删除它。</p>
</li>
</ul>
<hr>
<p>DCL（双重检查加锁）单例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line">    private int someField;</span><br><span class="line">    private static LazySingleton instance;</span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">        this.someField = new Random().nextInt(200) + 1; // (1)</span><br><span class="line">    &#125;</span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123; // (2)</span><br><span class="line">            synchronized (LazySingleton.class) &#123;  // (3)</span><br><span class="line">                if (instance == null) &#123; // (4)</span><br><span class="line">                    instance = new LazySingleton(); // (5)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance; // (6)</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSomeField() &#123;</span><br><span class="line">        return this.someField; // (7)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到单一的<code>instance</code>实例是没有问题的，尽管得到了<code>Singleton</code>的正确引用，但是却有可能访问到其成员变量的不正确值。</p>
<p><code>Singleton.getInstance().getSomeField()</code>有可能返回<code>someField</code>的默认值 0。</p>
<ul>
<li><p>假设线程Ⅰ是初次调用<code>getInstance()</code>方法，紧接着线程Ⅱ也调用了<code>getInstance()</code>方法和<code>getSomeField()</code>方法，</p>
</li>
<li><p>线程Ⅱ在执行<code>getInstance()</code>方法的语句(2)时，由于对<code>instance</code>的访问并没有处于同步块中，线程Ⅱ可能观察到也可能观察不到线程Ⅰ在语句(5)时对<code>instance</code>的写入，<code>instance</code>的值可能为空也可能为非空。</p>
<ul>
<li><p>假设<code>instance</code>的值非空，也就观察到了线程Ⅰ对<code>instance</code>的写入，这时线程Ⅱ就会执行语句(6)直接返回<code>instance</code>的值，然后对<code>instance</code>调用<code>getSomeField()</code>方法，该方法也是在没有同步情况被调用，因此线程Ⅱ在执行语句(7)完全有可能观测不到线程Ⅰ在语句(1)处对<code>someFiled</code>写入的值，这就是 DCL 的问题。</p>
</li>
<li><p>假设<code>instance</code>的值观察到空值，那它要进入同步块执行语句(4)，在语句(4)处线程Ⅱ不可能读到<code>instance</code>的空值，因为这时对<code>instance</code>的写和读都是发生在同一个锁的同步块中，这时读到的数据是最新的数据。</p>
</li>
<li><p>线程Ⅱ在语句(3)处会执行一个<code>lock</code>操作，而线程Ⅰ在语句(5)后会执行一个<code>unlock</code>操作，这两个操作都是针对同一个锁–<code>Singleton.class</code>，</p>
</li>
<li><p>线程Ⅰ的<code>unlock</code>操作<code>happen - before</code>线程Ⅱ的<code>lock</code>操作，<code>线程Ⅰ的语句(5) -&gt; 线程Ⅰ的 unlock 操作</code>，<code>线程Ⅱ的 lock操作 -&gt; 线程Ⅱ的语句(4)</code>，根据传递规则，就有<code>线程Ⅰ的语句(5) -&gt; 线程Ⅱ的语句(4)</code>，线程Ⅱ在执行语句(4)时能够观测到线程Ⅰ在语句(5)时对<code>Singleton</code>的写入值。</p>
</li>
<li><p>接着对返回的<code>instance</code>调用<code>getSomeField()</code>方法时，<code>线程Ⅰ的语句(1) -&gt; 线程Ⅱ的语句(7)</code>（线程Ⅱ有进入<code>synchronized</code>块），表明这时<code>getSomeField</code>能够得到正确的值。</p>
</li>
</ul>
</li>
</ul>
<p>对引用（包括对象引用和数组引用）的非同步访问，即使得到该引用的最新值，却并不能保证也能得到其成员变量（对数组而言就是每个数组元素）的最新值。</p>
<p>最简单安全的方法是使用<code>static</code>内部类：一个类直到被使用时才被初始化，而类初始化的过程是非并行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton  &#123;</span><br><span class="line">    private Singleton() &#123;&#125; // Lazy initialization holder class idiom for static fields</span><br><span class="line">    private static class InstanceHolder &#123;</span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getSingleton() &#123;</span><br><span class="line">        return InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DCL的问题正好在于看到对象的成员变量的默认值，因此可以将<code>LazySingleton</code>的<code>someField</code>变量设置成<code>final</code>。</p>
<p>另外，可以将<code>instance</code>声明为<code>volatile</code>;</p>
<p><code>线程Ⅰ的语句(5) -&gt; 线程Ⅱ的语句(2)</code>，根据单线程规则，<code>线程Ⅰ的语句(1) -&gt; 线程Ⅰ的语句(5)</code>和<code>语线程Ⅱ的句(2) -&gt; 语线程Ⅱ的句(7)</code>，再根据传递规则就有<code>线程Ⅰ的语句(1) -&gt; 语线程Ⅱ的句(7)</code>，这表示线程Ⅱ能够观察到线程Ⅰ在语句(1)时对<code>someFiled</code>的写入值，程序能够得到正确的行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    // volatile 关键字主要是为了防止指令重排</span><br><span class="line">    private static volatile Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton == null) &#123;</span><br><span class="line">                    // 防止指令重排</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不用<code>volatile</code> ，<code>singleton = newSingleton();</code>这段代码其实是分为三步：</p>
<ul>
<li><p>分配内存。</p>
</li>
<li><p>初始化对象。</p>
</li>
<li><p>将<code>singleton</code>对象指向分配的内存地址。</p>
</li>
</ul>
<p>加上<code>volatile</code>是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的。</p>
<p>上面好像有两种说法，我比较倾向于第一种。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
