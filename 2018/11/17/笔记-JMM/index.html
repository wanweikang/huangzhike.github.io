<!DOCTYPE HTML>
<html>

<head>
    <script>
        var timeStart = new Date();
    </script>
    <meta charset="utf-8">
    
    <title>[笔记]-JMM | Reunion...</title>
    
    <meta name="author" content="huangzhike">
    
    
    <meta name="description"
        content="2019-12-14更新
最近看到Oracle的Java语言和虚拟机规范，发觉Oracle的这个官方文档真的是个宝库，还是有代码例子的那种。
简单地翻了一下，我觉得完全可以作为Java的教材了，包含了入门到高级的知识，可惜是英文的，虽然我也能看，但是阅读这种专业文档还是挺吃力的，这个时候就不得不感叹">
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta property="og:title" content="[笔记]-JMM" />
    
    <meta property="og:site_name" content="Reunion..." />
    
    
    <!-- favicon -->
    <link rel="icon" type="image/ico" href="/logo.ico" sizes="32x32">
    <meta name="msapplication-TileColor" content="#009688">
    <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
    <meta name="theme-color" content="#009688">
    <!-- favicon end -->
    <!-- <link href="//ok.ico" rel="icon"> -->
    

    <!-- <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" title="早く来い、クラウド" href="/">Reunion...</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-JMM</h2>
				
				<div>
					<div class="post-time">2018-11-17</div>
				</div>
				
				<div class="article-content">
				<p>2019-12-14更新</p>
<p>最近看到Oracle的<a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">Java语言和虚拟机规范</a>，发觉Oracle的这个官方文档真的是个宝库，还是有代码例子的那种。</p>
<p>简单地翻了一下，我觉得完全可以作为Java的教材了，包含了入门到高级的知识，可惜是英文的，虽然我也能看，但是阅读这种专业文档还是挺吃力的，这个时候就不得不感叹西方人学习是多么方便了。</p>
<p>不止计算机科学，整个近代人类文明，也基本都是建立在西方文明的基础上，到了现代，这个情况还是没有改变，虽然中国在科研领域已经取得了很多成就，但是，还远远不够。</p>
<p>在学习上，就体现为，难以获取第一手的知识，毕竟语言不通，所以大部分人只能通过翻译过的版本获取，但是这个翻译后再传播，可能就经过了好几个人的理解，而且不一定完整和及时。</p>
<p>所以挺尴尬的。</p>
<p>另外内存模型这里我查了挺多资料，但是对于具体的实现细节大多是模棱两可，或者是各有说法，所以也就看个结论吧，我也无法判断对错，挺多疑问的。</p>
<p>往下看就是虚拟机的实现甚至更底层的了，现在还是力有未逮。</p>
<hr>
<p>计算机内存模型</p>
<p>计算机指令是在CPU中执行的，程序运行的临时数据是放在主存中的，因为CPU执行速度比内存读写快得多，因此运行过程中，会从主存复制一份到CPU的高速缓存当中，直接从高速缓存读写数据，结束后再将高速缓存中的数据刷回主存。</p>
<p>如：<code>i = i + 1;</code>，先从主存读取i的值，然后复制一份到高速缓存，CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存。</p>
<p>缓存一致性问题：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。</p>
<p>此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存，最终结果i的值是1，而不是2。</p>
<p>通常有两种解决方法（硬件层面）：</p>
<ul>
<li><p>在总线加LOCK#锁</p>
<ul>
<li>CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。</li>
</ul>
</li>
<li><p>通过缓存一致性协议</p>
<ul>
<li><p>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。</p>
</li>
<li><p>当其他CPU需要读取这个变量时，发现自己缓存中该变量是无效的，就会从内存重新读取。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>Java Memory Model</p>
<p>Java内存模型屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各平台下都能达到一致的内存访问效果。</p>
<p>Java中所有实例变量都储存在主存中，对于所有线程都是共享的。</p>
<p>每条线程都有自己的工作内存，线程对变量的操作（读取、赋值等）都在工作内存中进行，不能直接对主存进行操作。</p>
<p>这里的工作内存是个抽象，不同的线程间无法直接访问对方工作内存，线程间通过主内存传递变量值。</p>
<hr>
<p>JMM中定义了8种操作处理主内存与工作内存之间的交互：</p>
<ul>
<li><p>lock（锁定）：作用于主内存，把一个变量标识为线程独占。</p>
</li>
<li><p>unlock（解锁）：作用于主内存，把一个独占状态的变量释放。</p>
</li>
<li><p>read（读取）：作用于主内存，把一个变量的值从主内存传输到工作内存中，以便之后load。</p>
</li>
<li><p>load（载入）：作用于工作内存，把read操作的变量值放入工作内存的变量副本中。</p>
</li>
<li><p>use（使用）：作用于工作内存，把工作内存中的一个变量的值传递给执行引擎。</p>
</li>
<li><p>assign（赋值）：作用于工作内存，把一个从执行引擎接收到的值赋给工作内存的变量。</p>
</li>
<li><p>store（存储）：作用于工作内存，把工作内存中的一个变量的值传递到主内存中，以便之后write。</p>
</li>
<li><p>write（写入）：作用于主内存，把store操作的变量值放入主内存的变量中。</p>
</li>
</ul>
<p>基本规则：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现，即不允许出现从主内存读取了而工作内存不接受，或者从工作内存回写了但主内存不接受的情况出现；</p>
</li>
<li><p>不允许一个线程丢弃它最近的assign操作，即变量在工作内存变化了必须把该变化同步回主内存；</p>
</li>
<li><p>不允许一个线程无原因地（即未发生过assign操作）把一个变量从工作内存同步回主内存；</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存中直接使用一个未被初始化（load或assign）过的变量，换句话说就是对一个变量的use和store操作之前必须执行过load和assign操作；</p>
</li>
<li><p>一个变量同一时刻只允许一个线程对其进行lock操作，但lock操作可以被同一个线程执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才能被解锁。</p>
</li>
<li><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值；</p>
</li>
<li><p>如果一个变量没有被lock操作锁定，则不允许对其执行unlock操作，也不允许unlock一个其它线程锁定的变量；</p>
</li>
<li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中，即执行store和write操作；</p>
</li>
</ul>
<p>变量从主内存放入工作内存变量副本中实际是分为两步的，先把主内存的值放在工作内存中，再把放在工作内存的值放入变量副本中，以此类推，这样是为了提高CPU效率，不等待主内存写入完成。</p>
<p>read、load操作和store、write操作必须按顺序执行，但不需要连续执行。</p>
<p>如果要把变量从主内存复制到工作内存，那就要按顺序执行read和load操作。</p>
<p>如果要把变量从工作内存同步回主内存，就就要按顺序执行store和write操作。</p>
<p>比如，对主内存中的变量a和b的访问，可能按照以下顺序执行：read a -&gt; read b -&gt; load b -&gt; load a。</p>
<hr>
<p>如：<code>i = 10;</code>，执行线程先在自己的工作内存中对变量i所在的缓存行进行赋值，再写入主存，而不是直接写入主存。</p>
<p>Java中，对基本数据类型的变量的读取和赋值操作是原子性操作。</p>
<pre class=" language-java"><code class="language-java">x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 原子</span>

y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非原子，包含2个操作，先读取x的值，再将x的值写入工作内存</span>

x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非原子，包含3个操作，解决方法，加锁或原子类</span>

x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 非原子</span></code></pre>
<p>只有简单的读取、赋值（变量之间的相互赋值不是原子操作）才是原子操作（<code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code>、<code>store</code>、<code>write</code>），如果要实现更大范围操作的原子性，可以通过加锁来实现。</p>
<p><code>synchronized</code>能够保证同一时刻只有一个线程执行该代码块（<code>lock</code>和<code>unlock</code>），不存在原子性问题。</p>
<p><code>monitorenter</code>和<code>monitorexit</code>与<code>lock</code>和<code>unlock</code>具体的关系是？</p>
<hr>
<p>重排序：</p>
<ul>
<li><p>编译器优化：代码重排序；</p>
</li>
<li><p>指令重排序：指令重排序；</p>
</li>
<li><p>内存重排序：处理器使用缓存和缓冲，外部对内存的操作可能观察到乱序；</p>
</li>
</ul>
<p>重排序条件：</p>
<ul>
<li><p>在单线程下不能影响程序运行的结果；</p>
</li>
<li><p>存在依赖关系的不允许重排序；</p>
</li>
</ul>
<p>有序性：</p>
<ul>
<li><p>如果在本线程内观察，所有的操作都是有序的（线程内表现为串行的语义）；</p>
</li>
<li><p>如果在一个线程中观察另一个线程，所有的操作都是无序的（指令重排序、工作内存与主内存同步延迟）。</p>
</li>
</ul>
<p><code>volatile</code>和<code>synchronized</code>两个关键字可以保证有序性。</p>
<p><code>synchronized</code>：<code>lock</code>和<code>unlock</code>操作，<code>lock</code>相当于一个内存屏障，我的理解是同步块外的代码不会重排序到代码块内，但是代码块内部应该是不保证顺序的。</p>
<p><code>volatile</code>：禁止重排序。</p>
<p>四种组合类型（禁止屏障两侧的指令重排序）：</p>
<ul>
<li><p>LoadLoad：对于<code>Load a; LoadLoad; Load b;</code>的情况，保证<code>Load a</code>在<code>Load b</code>前完成（即操作可见）。</p>
</li>
<li><p>StoreStore：对于<code>Store a; StoreStore; Store b;</code>的情况，保证<code>Store a</code>在<code>Store b</code>前完成。</p>
</li>
<li><p>LoadStore：对于<code>Load a; LoadStore; Store b;</code>的情况，保证<code>Load a</code>在<code>Store b</code>前完成。</p>
</li>
<li><p>StoreLoad：对于<code>Store a; StoreLoad; Load b;</code>的情况，保证<code>Store a</code>在<code>Load b</code>前完成（开销最大）。</p>
</li>
</ul>
<p>在<code>volatile</code>写操作前插入StoreStore屏障，在后面插入StoreLoad屏障，即，<code>volatile</code>写之前的写操作不能被重排序到后面，之后的操作不能被重排序到前面：</p>
<p>写操作 -&gt; StoreStore -&gt; volatile写 -&gt; StoreLoad -&gt; 读或写操作</p>
<p>在<code>volatile</code>读操作后插入LoadLoad屏障，再在后面插入LoadStore屏障，即，<code>volatile</code>读之后的操作不能被重排序到前面：</p>
<p>volatile读 -&gt; LoadLoad -&gt; LoadStore -&gt; 读或写操作</p>
<p>也就是说，<code>volatile</code>的禁止重排序也不是完全的禁止，并且普通变量是没有内存屏障的，普通变量是可能重排序的。</p>
<p>关于内存屏障，之前我的理解是，普通变量的读写对工作内存和主内存的操作不是同步的，<code>volatile</code>变量的读写是同步的，普通变量的读（<code>read</code>和<code>load</code>）和写（<code>store</code>和<code>write</code>），可能会发生排序，所以在多线程下可能会有可见性等问题。</p>
<p>并发包的锁也是通过一个<code>volatile</code>变量来进行线程间的通信，比如ReentrantLock，之前在想某个对象使用了锁，锁对象的变量可见性是怎么影响该对象的变量的可见性的，应该是内存屏障会保障前后的读写指令的可见性，比如<code>volatile</code>写会保证之前所有写操作会由工作内存刷回主内存，应该是这样的。</p>
<p>另外看到“<code>volatile</code>变量的操作会插入<code>lock</code>指令，相当于内存屏障”，这么一句话，那么内存屏障具体是什么？啧，挺多地方都是不明不白的。</p>
<hr>
<p>可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程立即可感知修改（可见）。</p>
<p>假如线程1先执行，线程2后执行：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 线程1</span>
<span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 线程2</span>
stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre>
<p>线程1运行时，将stop变量值拷贝一份在工作内存，线程2更改了stop变量值之后，可能会一直循环下去。</p>
<p>不过，是因为线程2没把值写回主内存，还是因为线程1没有从主内存读取最新的值？猜测应该是后者，那么只有一开始从主内存读取值，之后都不会？</p>
<p><code>synchronized</code>，<code>final</code>，<code>volatile</code>能实现可见性。</p>
<p><code>synchronized</code>也能够保证可见性，同一时刻只有一个线程获取锁然后执行同步代码，<code>lock</code>操作要求重新执行<code>load</code>或<code>assign</code>操作初始化，<code>unlock</code>操作之前，必须先把此变量同步回主内存中，即执行<code>store</code>和<code>write</code>操作。</p>
<p><code>volatile</code>变量的每次修改都必须立即回写到主内存中，<code>volatile</code>变量的每次读取都必须从主内存刷新最新的值。</p>
<p>StoreLaod屏障，是确保可见性的关键，因为它会将屏障之前的数据全部刷新到主内存中。</p>
<p><code>volatile</code>读和<code>monitorenter</code>有相同的语义，<code>volatile</code>写和<code>monitorexit</code>有相同的语义。</p>
<hr>
<p><code>volatile</code>只能保证可见性和有序性，不能保证对变量的操作是原子性。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        counter<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token operator">></span>
                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
                    <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>每次运行结果都是一个小于1000的数字。</p>
<p>可见性只能保证每次读取的是最新的值，但<code>volatile</code>没法保证对变量的操作的原子性。</p>
<p>自增操作是不具备原子性的，它包括读取变量的值、进行加1操作、写入内存。</p>
<ul>
<li><p>假如某个时刻counter的值为10，线程1先读取了变量counter的值，然后线程1被阻塞了；</p>
</li>
<li><p>然后线程2也去读取counter的值，由于线程1没有对变量进行修改操作，counter的值为10，然后进行加1操作，最后写入主存。</p>
</li>
<li><p>线程1接着进行加1操作，由于已经读取了counter的值，此时在线程1的工作内存中counter的值仍然为10，然后进行加1操作，最后写入主存。</p>
</li>
<li><p>两个线程分别进行了一次自增操作后，counter只增加了1。</p>
</li>
</ul>
<p>解决方法：原子类，利用CMPXCHG指令实现，处理器执行CMPXCHG指令是一个原子性操作。</p>
<hr>
<p>先行发生原则（happens-before）：</p>
<ul>
<li><p>操作A先行发生于操作B，就是说操作A的影响能被操作B观察到。</p>
</li>
<li><p>两个操作之间存在先行发生关系，不意味着具体实现必须要按照指定的顺序来执行。</p>
</li>
</ul>
<hr>
<ul>
<li><code>final</code>域是基础数据类型</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FinalExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> FinalExample obj<span class="token punctuation">;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 普通变量</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// final变量</span>
    <span class="token keyword">void</span> <span class="token function">FinalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 构造函数</span>
        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写普通域</span>
        j <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写final域</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 写线程A</span>
        obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 读线程B</span>
        FinalExample object <span class="token operator">=</span> obj<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读对象引用</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> object<span class="token punctuation">.</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读普通域</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> object<span class="token punctuation">.</span>j<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 读final域</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>编译器会在<code>final</code>域的写之后，构造函数返回之前，插入一个StoreStore屏障，禁止处理器把<code>final</code>域的写重排序到构造函数之外。</p>
<p><code>writer</code>：构造函数开始 -&gt; 普通域的写操作 -&gt; <code>final</code>域的写操作 -&gt; 内存屏障 -&gt; 构造函数结束 -&gt; 引用赋值，可以保证引用赋值前<code>final</code>域的写已经完成，但是普通域的写不具有这个保障？</p>
<p>在一个线程中，初次读对象引用与初次读该对的<code>final</code>域，禁止处理器重排序这两个操作，编译器会在读<code>final</code>域操作的前面插入一个LoadLoad屏障。</p>
<p><code>reader</code>：读对象引用 -&gt; 内存屏障 -&gt; 读对象的<code>final</code>域。</p>
<ul>
<li><code>final</code>域是引用类型</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FinalReferenceExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> FinalReferenceExample obj<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// final是引用类型</span>

    <span class="token function">FinalReferenceExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 构造函数</span>
        intArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1</span>
        intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writerOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 写线程A</span>
        obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalReferenceExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writerTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 写线程B</span>
        obj<span class="token punctuation">.</span>intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 4</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 读线程C</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 5</span>
            <span class="token keyword">int</span> temp1 <span class="token operator">=</span> obj<span class="token punctuation">.</span>intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在构造函数内对一个<code>final</code>引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作不能重排序。</p>
<p>首先线程A执行writerOne方法，执行完后线程B执行writerTwo方法，执行完后线程C执行reader方法。</p>
<p>1是对<code>final</code>域的写入，2是对这个<code>final</code>域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。</p>
<p>可以确保读线程C至少能看到写线程A在构造函数中对<code>final</code>引用对象的成员域的写入，即C至少能看到数组下标0的值为1。</p>
<p>而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。</p>
<hr>
<p><code>final</code>修饰的字段在构造器中一旦被初始化完成，并且构造器没有把<code>this</code>的引用传递出去（使得其他线程有可能通过这个引用访问到初始化未完成的对象），在其他线程中就能看到初始化的<code>final</code>字段的值。</p>
<p>前提：对象引用不能在构造函数中“逸出”。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FinalReferenceEscapeExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> FinalReferenceEscapeExample obj<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token function">FinalReferenceEscapeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 写final域</span>
        obj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this引用逸出</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">FinalReferenceEscapeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>DCL（双重检查加锁）单例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> someField<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingleton instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>someField <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSomeField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>someField<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>得到单例是没有问题的，虽然可以得到单例的正确引用，但是却有可能访问到成员变量的不正确值。</p>
<p>即，<code>Singleton.getInstance().getSomeField()</code>有可能返回<code>someField</code>的默认值0。</p>
<p>解决方法：将<code>someField</code>域设置成<code>final</code>，或者，将<code>instance</code>域声明为<code>volatile</code>。</p>
<p><code>instance = new LazySingleton();</code>这段代码其实是分为三步：</p>
<ol>
<li><p>为Singleton对象分配内存。</p>
</li>
<li><p>调用构造函数初始化Singleton对象。</p>
</li>
<li><p>将Singleton对象指向分配的内存地址。</p>
</li>
</ol>
<p>如果不用<code>volatile</code>，一个可能的顺序就是1 -&gt; 3 -&gt; 2，假设此时2还没完成，那么线程可能观察到一个初始化还没完成的对象，因为是非空的，所以不会进入同步代码块，但是返回的对象的属性可能是初始值(0/false/null)，而不是构造函数中的指定值。</p>
<p>最简单安全的方法是使用<code>static</code>内部类：一个类直到被使用时才被初始化，而类初始化的过程是非并行的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>  <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// Lazy initialization holder class idiom for static fields</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InstanceHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> InstanceHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<hr>
<p>线程安全的实现方法</p>
<h5 id="互斥同步（Mutual-Exclusion＆Synchronization）"><a href="#互斥同步（Mutual-Exclusion＆Synchronization）" class="headerlink" title="互斥同步（Mutual Exclusion＆Synchronization）"></a>互斥同步（Mutual Exclusion＆Synchronization）</h5><p>同步是指在多个线程并发访问共享数据时，共享数据在同个时刻只被一个（或一些，如信号量）线程使用。</p>
<p>互斥是实现同步的手段，最基本的互斥同步就是<code>synchronized</code>，编译后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令，这两个指令都需要一个引用类型来指明要锁定和解锁的对象。</p>
<ul>
<li><p>对于同步方法，锁是当前实例对象的引用。</p>
</li>
<li><p>对于静态同步方法，锁是当前对象的Class对象的引用。</p>
</li>
<li><p>对于同步方法块，锁是<code>synchronized</code>括号里配置的对象的引用。</p>
</li>
</ul>
<p>执行<code>monitorenter</code>指令时，首先要尝试获取对象的锁。</p>
<ul>
<li><p>如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行<code>monitorexit</code>指令时会将锁计数器减1，当计数器为0时，锁就被释放。</p>
</li>
<li><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
</li>
<li><p><code>synchronized</code>同步块对同一线程来说是可重入的，重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。</p>
<ul>
<li><p>当计数值为0时，这个锁就被认为是没有被任何线程所持有，当线程请求一个未被持有的锁时，记下锁的持有者，并且将获取计数值置为1。</p>
</li>
<li><p>如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。</p>
</li>
<li><p>当计数值为0时，这个锁将被释放。</p>
</li>
</ul>
</li>
</ul>
<p>Java的线程是映射到操作系统的原生线程上的，阻塞或唤醒一个线程，都需要操作系统完成，这就需要从用户态转换到核心态中，状态转换需要耗费很多的处理器时间。</p>
<p>互斥同步属于悲观的并发策略，认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的会竞争，都要加锁（虚拟机会优化掉不必要的锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p>
<h5 id="非阻塞同步（Non-Blocking-Synchronization）"><a href="#非阻塞同步（Non-Blocking-Synchronization）" class="headerlink" title="非阻塞同步（Non-Blocking Synchronization）"></a>非阻塞同步（Non-Blocking Synchronization）</h5><p>基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采取补偿措施（不断重试，直到成功）。</p>
<p>AtomicInteger#incrementAndGet</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在一个循环中，不断尝试将一个比当前值大1的新值赋给自己，如果失败，说明在CAS时值已经被修改，于是再次循环，直到成功。</p>
<h5 id="无同步"><a href="#无同步" class="headerlink" title="无同步"></a>无同步</h5><p>要保证线程安全，不一定就要同步，同步只是保证共享数据竞争时的正确性，如果不涉及共享数据，就无须同步，比如ThreadLocal。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>

    <script src="/js/prism.js"></script>
</body>
</html>
