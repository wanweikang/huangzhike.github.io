<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <script>
            var timeStart = new Date();
        </script>
        
        <title>[笔记]-深入理解JAVA虚拟机 | 学而时习之</title>
        
        <meta name="author" content="Huangzhike">
        
        
        <meta name="description" content="K.I.S.S">
        
        
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        
        <meta property="og:title" content="[笔记]-深入理解JAVA虚拟机"/>
        
        <meta property="og:site_name" content="学而时习之"/>
        
        
        <!-- favicon -->
        <link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
        <meta name="msapplication-TileColor" content="#009688">
        <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
        <meta name="theme-color" content="#009688">
        <!-- favicon end -->
        <!-- <link href="//ok.ico" rel="icon"> -->
        
        <!-- toc -->
        <!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
        <!-- material design -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
        <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
        
        <!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
        <!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
    <meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-深入理解JAVA虚拟机</h2>
				
				<div>
					<div class="post-time">2018-11-17</div>
				</div>
				
				<div class="article-content">
				<p>这部分内容基本整理自<a href="https://read.douban.com/ebook/15233695/" target="_blank" rel="noopener">深入理解Java虚拟机</a>，概念上的内容比较多，只能作为入门参考吧，真正想学习虚拟机的还得看源码，不然也是纸上谈兵。</p>
<hr>
<p>JVM的内存可分为3个区：堆(Heap)、栈(Stack)和方法区(Method)</p>
<p>堆区</p>
<ol>
<li>只存储实例对象本身，不存基本类型和对象引用</li>
<li>被所有线程共享</li>
</ol>
<p>栈区</p>
<ol>
<li>每个线程一个栈区，只保存基本类型和对象的引用</li>
<li>栈分为3部分：基本类型变量区、执行环境上下文、操作指令区（存放操作指令），存放函数的参数值，局部变量的值等</li>
<li>每个栈中的数据都是私有的，其他栈不能访问</li>
</ol>
<p>方法区</p>
<ol>
<li>方法区包含所有的class和static变量（唯一）</li>
<li>初始化的全局变量和静态变量在一块区域，未初始化的在相邻的另一块区域</li>
<li>被所有线程共享</li>
</ol>
<hr>
<p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，线程私有。</p>
<p>Java虚拟机栈（Java Virtual Machine Stacks）：</p>
<ul>
<li><p>线程私有。</p>
</li>
<li><p>每个Java方法执行时都会创建一个栈帧，每个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈。</p>
</li>
<li><p>可以粗糙地把Java内存区分为堆和栈，栈就是虚拟机栈中局部变量表部分，局部变量表存放了：</p>
<ul>
<li><p>编译期可知的基本数据类型（boolean、byte、char、short、int、float、long、double）；</p>
</li>
<li><p>对象引用（不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或相关的位置）；</p>
</li>
<li><p>returnAddress类型（指向了一条字节码指令的地址）。</p>
</li>
</ul>
</li>
<li><p>局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。</p>
</li>
<li><p>如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；</p>
</li>
<li><p>如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
</li>
<li><p>如果局部变量是一个引用类型，它引用的对象在Java堆中可被各个线程共享，但是引用本身在Java栈的局部变量表中，是线程私有的。</p>
</li>
</ul>
<p>本地方法栈（Native Method Stack）：虚拟机栈执行Java方法（字节码）服务，而本地方法栈则为Native方法服务，有的实现把两者合二为一。</p>
<p>Java堆（Java Heap）：</p>
<ul>
<li><p>线程共享，存放对象实例，也是垃圾收集器管理的主要区域（Garbage Collected Heap）。</p>
</li>
<li><p>收集器基本采用分代收集算法，Java堆可分为：新生代和老年代，新生代可再细分为Eden空间、From Survivor空间、To Survivor空间。</p>
</li>
<li><p>线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。</p>
</li>
<li><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</p>
</li>
<li><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
</li>
</ul>
<p>方法区（Method Area）：</p>
<ul>
<li><p>线程共享。</p>
</li>
<li><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li><p>方法区称为永久代（Permanent Generation），两者并不等价，但是HotSpot虚拟机用永久代来实现方法区。</p>
</li>
<li><p>使用永久代来实现方法区，容易遇到内存溢出问题（永久代有<code>-XX：MaxPermSize</code>的上限）。</p>
</li>
<li><p>除了和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可以选择不实现垃圾收集。</p>
</li>
<li><p>垃圾收集行为在这个区域是比较少出现的，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p>
</li>
<li><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
</li>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<ul>
<li><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
</li>
<li><p>运行时常量池相对于Class文件常量池的特征是动态性，不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中。</p>
</li>
</ul>
</li>
<li><p>Java7后，常量池已经不在永久代分配了，而是移到了堆中，即常量池和对象共享堆内存，到了Java 8，永久代被永久移除，使用Metaspace取代。</p>
</li>
<li><p>移除永久代的原因是，永久代大小受到<code>-XX：PermSize</code>和<code>-XX：MaxPermSize</code>的限制，而这两个参数又受到JVM的内存大小限制（<code>-Xmx</code>与<code>-Xms</code>），容易出现永久代内存溢出的问题，因此Java8及之后使用Metaspace替代。</p>
</li>
<li><p>Metaspace与永久代最大的区别在于，Metaspace不在虚拟机内存中而是使用直接内存，但也不是无限制的，需要配置参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>。</p>
</li>
</ul>
<p>直接内存（Direct Memory）：NIO类引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据。如果各个内存区域总和大于物理内存限制，也会出现OutOfMemoryError异常。</p>
<hr>
<p>对象的创建</p>
<p>虚拟机遇到一条new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</p>
<p>如果没有，先执行相应的类加载过程，在类加载检查通过后，接下来为新生对象分配内存。</p>
<p>对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<ul>
<li>指针碰撞（Bump the Pointer）</li>
</ul>
<p>如果Java堆中内存是规整的，用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p>
<ul>
<li>空闲列表（Free List）</li>
</ul>
<p>如果Java堆中内存不是规整的，已使用的内存和空闲的内存相互交错，虚拟机必须维护一个列表，记录哪些内存块是可用的。</p>
<p>对象创建在虚拟机中是非常频繁的，修改指针的位置在并发下也不是安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。两种方案：</p>
<ul>
<li><p>对分配内存进行同步处理，如CAS配上失败重试的方式保证更新操作的原子性；</p>
</li>
<li><p>把内存分配按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p>
</li>
</ul>
<p>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，也可以提前至TLAB分配时进行。</p>
<p>这保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>接下来，虚拟机对对象进行设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中。</p>
<p>一般来说执行new指令之后会接着执初始化方法，这样一个真正的对象才算完全产生出来。</p>
<hr>
<p>对象的内存布局</p>
<p>HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头：</p>
<ul>
<li><p>Mark Word：存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
</li>
<li><p>Class对象指针：</p>
<ul>
<li>指向它的类元数据的指针，确定这个对象是哪个类的实例。</li>
<li>并不是所有的实现都在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</li>
<li>如果对象是Java数组，对象头中还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</li>
</ul>
</li>
</ul>
<p>实例数据：对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，包括从父类继承下来的。</p>
<p>对齐填充：占位符的作用，HotSpot的要求对象起始地址必须是8字节的整数倍，所以对象的大小必须是8字节的整数倍。</p>
<hr>
<p>对象的访问定位</p>
<p>通过栈上的引用数据来操作堆上的具体对象。</p>
<p>由于引用类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的位置，所以对象访问方式取决于虚拟机实现。</p>
<ul>
<li><p>使用句柄访问：</p>
<ul>
<li><p>Java堆中将会划分出一块内存来作为句柄池，引用中存储的是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
</li>
<li><p>引用中存储的是稳定的句柄地址，在对象被移动（如GC）时只会改变句柄中的指针，而引用本身不需要修改。</p>
</li>
<li><p><img src="/imgs/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.PNG" alt="使用句柄访问 by huangzhike"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用直接指针访问：</p>
<ul>
<li><p>Java堆对象的布局中必须考虑如何放置访问类型数据的信息，引用中存储的就是对象地址。</p>
</li>
<li><p>速度更快，因为节省了一次指针定位的时间开销。</p>
</li>
<li><p><img src="/imgs/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.PNG" alt="直接指针访问 by huangzhike"></p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>Java堆溢出</p>
<ul>
<li><p>Java堆用于存储对象实例，只要不断地创建对象，并且Roots到对象之间有可达路径来避免垃圾回收，在达到最大堆的容量限制后就会产生内存溢出。</p>
</li>
<li><p>Java堆内存的OOM异常是常见的内存溢出异常，当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p>
</li>
<li><p>如果是内存泄露，可通过工具查看泄露对象到GC Roots的引用链，找到无法自动回收的原因。</p>
</li>
<li><p>如果不存在泄露，内存中的对象确实都还必须存活着，可以检查虚拟机的堆参数（-Xmx与-Xms）是否还可以调大，并且从代码上检查是否存在某些对象生命周期过长的情况。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>栈溢出</p>
<ul>
<li><p>HotSpot虚拟机不区分虚拟机栈和本地方法栈，栈容量只由-Xss参数设定。</p>
</li>
<li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
</li>
<li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
</li>
<li><p>这里存在重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，本质上只是对同一件事情的两种描述而已。</p>
</li>
<li><p>单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，抛出的都是StackOverflowError异常。</p>
</li>
<li><p>如果不限于单线程，通过不断地建立线程的方式可以产生OutOfMemoryError异常，但与栈空间是否足够大不存在联系，此时为每个线程的栈分配的内存越大，越容易产生内存溢出异常。</p>
</li>
<li><p>操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB，2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），剩下的约等于栈内存。</p>
</li>
<li><p>每个线程分配到的栈容量越大，可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽。</p>
</li>
<li><p>如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>方法区溢出</p>
<ul>
<li><p>运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区的一部分。</p>
</li>
<li><p>方法区溢出也是常见的内存溢出异常，一个类要被垃圾收集器回收掉，条件是苛刻的，在动态生成大量Class的应用中，需要特别注意类的回收状况。</p>
</li>
<li><p>除了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>直接内存溢出</p>
<ul>
<li>容量可通过-XX：MaxDirectMemorySize指定，默认与Java堆最大值（-Xmx指定）一样。</li>
</ul>
</li>
</ul>
<hr>
<p>对象的回收判定</p>
<ul>
<li><p>引用计数算法：</p>
<ul>
<li><p>给对象中添加一个引用计数器，有一个地方引用它时，计数器值就加1；引用失效时就减1；为0的对象就是不可能再被使用的。</p>
</li>
<li><p>缺点：难解决对象之间相互循环引用的问题。</p>
</li>
<li><p>对象a和b都有字段instance，令a.instance=b及b.instance=a，除此之外，这两个对象再无任何引用，即使这两个对象已经不可能再被访问，但是它们互相引用着对方，引用计数都不为0，于是无法回收。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>可达性分析算法：</p>
<ul>
<li><p>通过一系列“GC Roots”的对象作为起始点，向下搜索，所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
</li>
<li><p>可作为GC Roots的对象包括：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象，比如在方法中定义<code>Object o = new Object();</code>。</p>
</li>
<li><p>方法区中类静态属性或常量引用的对象，比如在类中定义<code>private static Object lock = new Object();</code>，或者<code>public static final char c = &quot;a&quot;;</code></p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
</li>
<li><p>可达性分析对执行时间的敏感体现在GC停顿上，不可以分析过程中对象引用关系还在变化，这是GC须停顿所有Java执行线程的重要原因。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>引用分为强引用（StrongReference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用就是指类似<code>Object o = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用是用来描述一些还有用但并非必需的对象。</p>
<ul>
<li>对于软引用关联着的对象，在将要发生内存溢出异常之前，将会把这些对象进行回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
</ul>
</li>
<li><p>弱引用也是用来描述非必需对象的，但是比软引用更弱一些。</p>
<ul>
<li>当GC时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
</ul>
</li>
<li><p>虚引用也称为幽灵引用或者幻影引用，是最弱的引用。</p>
<ul>
<li><p>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>
</li>
<li><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>回收方法区</p>
<p>虚拟机规范不要求虚拟机在方法区（HotSpot虚拟机中的永久代）实现垃圾收集。</p>
<p>永久代的GC主要回收两部分：废弃常量和无用的类。</p>
<ul>
<li><p>回收废弃常量：</p>
<ul>
<li><p>以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是没有String对象引用常量池中的“abc”常量，如果这时发生回收，必要的话，这个“abc”常量就会被清理。</p>
</li>
<li><p>常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li><p>该类所有的实例都已经被回收，Java堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的ClassLoader已经被回收。</p>
</li>
<li><p>该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>垃圾收集算法</p>
<ul>
<li><p>标记-清理算法（Mark-Sweep）</p>
<ul>
<li><p>先标记所有要回收的对象，标记完成后统一回收。</p>
</li>
<li><p>效率问题，标记和清除要两次，效率不高；</p>
</li>
<li><p>空间问题，标记清除之后会产生大量不连续的内存碎片，可能导致分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。</p>
</li>
<li><p>多用于老年代。</p>
</li>
</ul>
</li>
<li><p>复制算法（Copying）</p>
<ul>
<li><p>将内存分为两块，每次只使用其中的一块，当这块的内存用完了，就将还存活着的对象复制到另一块上，再把已用过的内存清掉。</p>
</li>
<li><p>新生代中的对象大部分是朝生夕死，因此新生代可以分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。</p>
</li>
<li><p>当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间，减少内存碎片。</p>
</li>
<li><p>默认Eden和Survivor的大小比例是8:1，也就是只有10%会被“浪费”。</p>
</li>
<li><p>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
</li>
<li><p>效率问题，在对象存活率较高时就要进行较多的复制操作。</p>
</li>
<li><p>需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，在老年代不能选用这种算法。</p>
</li>
<li><p>多用于新生代。</p>
</li>
</ul>
</li>
<li><p>标记-整理算法（Mark-Compact）</p>
<ul>
<li><p>不直接清理可回收对象，而让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
</li>
<li><p>多用于老年代。</p>
</li>
</ul>
</li>
<li><p>分代收集算法（Generational Collection）</p>
<ul>
<li><p>根据对象存活周期，将Java堆分为新生代和老年代，根据各个年代的特点采用适当的收集算法。</p>
<ul>
<li><p>新生代中，每次GC只有少量存活，选用复制算法，复制成本较低。</p>
</li>
<li><p>老年代中，对象存活率高、没有额外空间进行分配担保，必须使用“标记-清理”或“标记-整理”算法。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>新生代（Young Generation）和老年代（Old Generation）都存在于堆中，而永久代（Permanent Generation）是方法区的实现方式，Java8之后，去掉永久代，使用元数据区（Metaspace）。</p>
<p>新生代又分为Eden空间、From Survivor空间、To Survivor空间。</p>
<p>对象实例化后在新生代的Eden Space（新生区），存活过一次GC后会进入Survivor Space（幸存者区），存活过多次GC就进入Old Gen（老年代）。</p>
<p>对象优先在Eden区分配，当Eden区没有足够空间进行分配时，将发起一次Minor GC。</p>
<p>需要大量连续内存空间的Java对象称为大对象，会导致提前触发GC以获取更大的连续的空间来进行大对象的分配。</p>
<p>虚拟机提供了-XX:PretenureSizeThreadshold参数来设置大对象的阈值，超过阈值的大对象直接分配到老年代。</p>
<p>另外，对象的年龄到达了MaxTenuringThreshold，则可以进入老年代，同时，如果在Survivor区中相同年龄所有对象大小的总和大于Survivor区的一半，大于等于该年龄的对象可以直接进入老年代。</p>
<hr>
<p>垃圾回收的两个重要方法：System#gc和Object#finalize。</p>
<p>新生代GC叫做Minor GC，老年代GC叫做Major GC，Full GC。</p>
<p>新生代过小，会导致GC频繁，同时在老年代中对象很难被回收。</p>
<p>新生代过大，复制则比较麻烦。</p>
<p>目标是：最小化晋升到老年代的数量，最小化新生代GC的次数和持续时间。</p>
<p>减少GC：</p>
<ul>
<li><p>尽量减少临时对象的使用。临时对象在方法完成后，会被回收。</p>
</li>
<li><p>无用的对象显式置为null。</p>
</li>
<li><p>尽量使用基本类型如int，不用包装类型如Integer。基本类型变量占用的内存比包装类型少得多。</p>
</li>
<li><p>尽量使用StringBuffer，而不用String来累加字符串。如<code>Str5 = Str1 + Str2 + Str3 + Str4;</code>每次累加都会产生新的对象，当然虚拟机有优化。</p>
</li>
<li><p>尽量少用静态对象变量。静态变量生命周期比较长，会一直占用内存。</p>
</li>
<li><p>避免集中在短时间内创建或删除新对象。</p>
</li>
</ul>
<hr>
<p>垃圾收集器</p>
<ul>
<li>Serial收集器</li>
</ul>
<p>Serial收集器是虚拟机运行在Client模式下的默认收集器，因为它简单而高效。</p>
<p>单线程的收集器，必须暂停其他线程的所有工作，直到收集结束为止。</p>
<p>采用复制算法的用于新生代，使用标记-整理算法的用于老年代。</p>
<ul>
<li>Parallel收集器</li>
</ul>
<p>Serial收集器的多线程版本，Server模式下的虚拟机的新生代收集器，因为能与CMS收集器配合工作。</p>
<p>采用复制算法的用于新生代，使用标记-整理算法的用于老年代。</p>
<p>CMS收集器是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel收集器则是可控制的吞吐量。</p>
<p>吞吐量就是CPU用于运行用户代码时间与CPU总消耗时间的比值，停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成任务，主要适合后台运算的任务。</p>
<p>GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的，Parallel收集器也被称为“吞吐量优先收集器”（吞吐量和响应时间）。</p>
<ul>
<li>CMS收集器</li>
</ul>
<p>CMS（Concurrent Mark &amp; Sweep）收集器是以获取最短GC停顿时间为目标的老年代收集器，基于标记-清除算法实现。</p>
<p>CMS收集器注重响应速度，希望系统停顿时间最短，以给用户带来较好的体验，实现了让GC线程与用户线程基本上同时工作。</p>
<ul>
<li>G1收集器</li>
</ul>
<p>在G1（Garbage-First）收集器之前的收集器的范围都是整个新生代或老年代，而G1收集器不是这样，G1收集器将整个Java堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但不再是隔离。</p>
<p>G1收集器跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（Garbage-First）。</p>
<p>使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器的收集效率。</p>
<hr>
<ul>
<li><p>并行Parallel：多条GC线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li><p>并发Concurrent：指用户线程与GC线程同时执行。</p>
</li>
</ul>
<hr>
<p>类加载的时机</p>
<p>类从被加载到虚拟机内存中，到卸载出内存，生命周期包括：</p>
<p>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。</p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而解析则不一定，它可以在初始化之后再开始，这是为了运行时绑定（动态绑定或晚期绑定）。</p>
<p>绑定指的是把一个方法的调用与方法所在的类关联起来，分为静态绑定和动态绑定：</p>
<ul>
<li><p>静态绑定：程序编译期的就可以确定，只有final，static，private和构造方法是前期绑定的。</p>
<ul>
<li><p>invokestatic，静态方法。</p>
</li>
<li><p>invokespecial，调用private方法、构造方法，super方法。</p>
</li>
</ul>
</li>
<li><p>动态绑定：在运行时根据具体对象的类型进行绑定，多态，方法的重写（Override）。</p>
<ul>
<li><p>invokevirtual：多态。</p>
</li>
<li><p>invokeinterface：针对接口的方法的实现。</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>类加载的过程（加载、验证、准备、解析和初始化）</p>
<ul>
<li><p>加载是类加载过程的第一个阶段。</p>
<ul>
<li><p>通过一个类的全限定名获取此类的二进制字节流，具体交给ClassLoader实现。</p>
</li>
<li><p>将类信息、静态变量、字节码、常量等放入方法区。</p>
</li>
<li><p>在内存中生成一个代表这个类的Class对象，作为方法区这个类的访问入口。<br>　　创建的Class对象在方法区中。对象绝大多数放在堆中，Class对象是一个例外。</p>
</li>
</ul>
</li>
<li><p>验证字节流是否合法。</p>
</li>
<li><p>准备阶段为类变量(static)在方法区中分配内存并设置初始值，有final修饰的则使用final指定的初始值。</p>
</li>
<li><p>解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用是Class类文件用来定位目标的，直接引用是虚拟机用来在内存中定位目标的。</p>
</li>
<li><p>初始化是执行类的构造器方法，由类变量的赋值动作和static静态语句块按照在源文件中出现的顺序合并而成。</p>
</li>
</ul>
<p>对于初始化阶段，虚拟机规定了有且只有5种情况必须立即对类进行“初始化”（加载、验证、准备要在此之前开始）：</p>
<ul>
<li><p>遇到以下4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。</p>
<ul>
<li><code>new</code>，使用new关键字实例化对象。</li>
<li><code>getstatic</code>，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）。</li>
<li><code>putstatic</code>，设置一个类的静态字段。</li>
<li><code>invokestatic</code>，调用一个类的静态方法。</li>
</ul>
</li>
<li><p>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候。</p>
</li>
<li><p>初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
</ul>
<p>这5种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SuperClass init！"</span><span class="token punctuation">)</span>；
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span>；
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubClass</span> <span class="token keyword">extends</span> <span class="token class-name">SuperClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SubClass init！"</span><span class="token punctuation">)</span>；
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/**
* 被动使用类字段，通过子类引用父类的静态字段，不会导致子类初始化
*/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NotInitialization</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main（String<span class="token punctuation">[</span><span class="token punctuation">]</span> args）<span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>SubClass<span class="token punctuation">.</span>value<span class="token punctuation">)</span>；
        <span class="token comment" spellcheck="true">// 只会输出“SuperClass init！”，不会输出“SubClass init！”</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<p>至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// AppMain的信息都放入方法区</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppMain</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// main方法本身放入方法区</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// test是引用，放到栈区里，Sample是自定义对象应该放到堆里面</span>
        Sample test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sample</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Sample</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// new Sample实例后，name引用放入栈区里，name对象放入堆里</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Sample</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// printName方法本身放入方法区里</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> </code></pre>
<p>JVM首先从classpath中找到AppMain.class文件，读取二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中，称为类的加载。</p>
<p>接着虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令：<code>Sample test = new Sample(&quot;测试&quot;);</code></p>
<p>虚拟机创建一个Sample实例，并且使引用变量test引用这个实例。</p>
<p>建立一个Sample实例：</p>
<ul>
<li><p>先去方法区找到Sample类的类型信息，这时方法区里还没有Sample类，于是加载Sample类，把Sample类的类型信息存放在方法区里。</p>
</li>
<li><p>在堆区中为一个Sample实例分配内存, 这个实例持有着指向方法区的Sample类的类型信息的引用，而这个地址存放在Sample实例的数据区里。</p>
</li>
</ul>
<p>虚拟机进程中，每个线程都会拥有一个方法调用栈，跟踪线程运行中一系列的方法调用过程，栈中的元素被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。</p>
<p>这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。</p>
<p>“=”前的test是在main()方法中定义的变量，它是局部变量，会添加到了执行main()方法的主线程的JAVA方法调用栈中。</p>
<p>“=”将把test变量指向堆区中的Sample实例，它持有指向Sample实例的引用。</p>
<p>当虚拟机执行test.printName()方法时，根据局部变量test持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>
    <!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
    <!-- material design -->
    <!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
    <!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
    <!-- toc -->
    <!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
    <!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
    <!-- <script src="/js/main.js"></script> -->
    <script src="/js/prism.js"></script>
</body>
</html>
