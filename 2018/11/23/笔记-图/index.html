<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-图 | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-图">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-图</h2>
				
				<div>
					<div class="post-time">2018-11-23</div>
				</div>
				
				<div class="article-content">
				<p><strong>代码来源：《学习JavaScript数据结构与算法》 By <a href="https://github.com/loiane" target="_blank" rel="noopener">Loiane Groner</a></strong></p>
<p>2019年11月26日更新：其实图这里有些算法我没看懂，不看了。</p>
<hr>
<p>图G是一组由边E连接的节点（顶点V）。</p>
<p>一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此A的度为3。</p>
<p>如果图中不存在环，则称该图是无环的。</p>
<p>如果图中每两个顶点间都存在路径，则该图是连通的。</p>
<p>图可以是无向的（边没有方向）或是有向的。</p>
<p>图中每两个顶点间在双向上都存在路径，则该图是强连通的。</p>
<p>图还可以是未加权的或是加权的，加权图的边被赋予了权值。</p>
<p>图的实现</p>
<ul>
<li><p>邻接矩阵。</p>
<ul>
<li><p>用一个二维数组来表示顶点之间的连接。</p>
</li>
<li><p>如果索引为i的节点和索引为j的节点相邻，则<code>array[i][j] === 1</code>，否则<code>array[i][j] === 0</code>。</p>
</li>
<li><p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，浪费了空间。</p>
</li>
<li><p>找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，也不得不迭代一整行。</p>
</li>
<li><p>图中顶点的数量可能会改变，而二维数组不灵活。</p>
</li>
<li><p>但要找出顶点v和w是否相邻，使用邻接矩阵会比较快。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>邻接表。</p>
<ul>
<li><p>邻接表由图中每个顶点的相邻顶点列表所组成。</p>
</li>
<li><p>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>关联矩阵。</p>
<ul>
<li><p>在关联矩阵中，矩阵的行表示顶点，列表示边。</p>
</li>
<li><p>使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则<code>array[v][e] === 1</code>；否则，<code>array[v][e] === 0</code>。</p>
</li>
<li><p>关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/graph.PNG" width="500"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dictionary <span class="keyword">from</span> <span class="string">'./dictionary'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span></span><br><span class="line"><span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(isDirected = false) &#123;</span><br><span class="line">        <span class="comment">// 是否有向</span></span><br><span class="line">        <span class="keyword">this</span>.isDirected = isDirected;</span><br><span class="line">        <span class="comment">// 数组存储图中所有顶点</span></span><br><span class="line">        <span class="keyword">this</span>.vertices = [];</span><br><span class="line">        <span class="comment">// 字典存储邻接表，顶点名作为键，邻接顶点列表作为值</span></span><br><span class="line">        <span class="keyword">this</span>.adjList = <span class="keyword">new</span> Dictionary();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向图添加一个顶点</span></span><br><span class="line">    addVertex(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.vertices.includes(v)) &#123;</span><br><span class="line">            <span class="comment">// 将该顶点添加到顶点列表中</span></span><br><span class="line">            <span class="keyword">this</span>.vertices.push(v);</span><br><span class="line">            <span class="comment">// 在邻接表中，设置顶点 v 作为键对应的字典值为一个空数组</span></span><br><span class="line">            <span class="keyword">this</span>.adjList.set(v, []); <span class="comment">// initialize adjacency list with array as well;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加顶点之间的边两个顶点作为参数</span></span><br><span class="line">    addEdge(a, b) &#123; </span><br><span class="line">        !<span class="keyword">this</span>.adjList.get(a) &amp;&amp; <span class="keyword">this</span>.addVertex(a);</span><br><span class="line">        !<span class="keyword">this</span>.adjList.get(b) &amp;&amp; <span class="keyword">this</span>.addVertex(b);</span><br><span class="line">        <span class="comment">// 将b加入到a的邻接表中，添加了一条自顶点a到顶点b的边</span></span><br><span class="line">        <span class="keyword">this</span>.adjList.get(a).push(b);</span><br><span class="line">        <span class="comment">// 添加一条自b向a的边，上一步实现有向图，这一步实现无向图</span></span><br><span class="line">        <span class="comment">// commented to run the improved DFS with topological sorting</span></span><br><span class="line">        <span class="keyword">this</span>.isDirected !== <span class="literal">true</span> &amp;&amp; <span class="keyword">this</span>.adjList.get(b).push(a);</span><br><span class="line">    &#125;</span><br><span class="line">    getVertices() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.vertices;</span><br><span class="line">    &#125;</span><br><span class="line">    getAdjList() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.adjList;</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.vertices.length; i++) &#123;</span><br><span class="line">            s += <span class="string">`$ &#123;this.vertices[i]&#125; - &gt; `</span>;</span><br><span class="line">            <span class="keyword">const</span> neighbors = <span class="keyword">this</span>.adjList.get(<span class="keyword">this</span>.vertices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; neighbors.length; j++) &#123;</span><br><span class="line">                s += <span class="string">`$ &#123;neighbors[j]&#125;`</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s += <span class="string">'\n'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对图遍历：广度优先搜索（Breadth - First Search，BFS）和深度优先搜索（Depth - First Search，DFS）。</p>
<ul>
<li><p>图遍历：</p>
<ul>
<li><p>追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。</p>
</li>
<li><p>完全探索一个顶点要求查看该顶点的每一条边。</p>
</li>
<li><p>对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
</li>
<li><p>为了保证效率，访问每个顶点至多两次。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>深度优先搜索</p>
<ul>
<li><p>数据结构：栈。</p>
</li>
<li><p>将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>广度优先搜索</p>
<ul>
<li><p>数据结构：队列</p>
</li>
<li><p>将顶点存入队列中，最先入队列的顶点先被探索。</p>
</li>
</ul>
</li>
<li><p>用三种颜色标注顶点的访问状态：</p>
<ul>
<li><p>白色：该顶点还没有被访问。</p>
</li>
<li><p>灰色：该顶点被访问过，但并未被探索过。</p>
</li>
<li><p>黑色：该顶点被访问过且被完全探索过（访问每个顶点最多两次）。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Colors = &#123;</span><br><span class="line">    WHITE: <span class="number">0</span>,</span><br><span class="line">    GREY: <span class="number">1</span>,</span><br><span class="line">    BLACK: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化颜色地图</span></span><br><span class="line"><span class="keyword">const</span> initializeColor = <span class="function"><span class="params">vertices</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">v</span> =&gt;</span> color[v] = Colors.WHITE)</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>广度优先搜索</p>
<ul>
<li><p>从顶点v开始的广度优先搜索算法</p>
<ul>
<li><p>创建一个队列Q。</p>
</li>
<li><p>将v标注为被发现的（灰色），并将v入队列Q。</p>
</li>
<li><p>如果Q非空：</p>
<ul>
<li><p>将u从Q中出队列；</p>
</li>
<li><p>将标注u为被发现的（灰色）；</p>
</li>
<li><p>将u所有未被访问过的邻点（白色）入队列；</p>
</li>
<li><p>将u标注为已被探索的（黑色）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/breadthFirstSearch.PNG" width="500"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue <span class="keyword">from</span> <span class="string">'../../data-structures/queue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> breadthFirstSearch = <span class="function">(<span class="params">graph, startVertex, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">    <span class="comment">// 进队列</span></span><br><span class="line">    queue.enqueue(startVertex);</span><br><span class="line">    <span class="comment">// 循环队列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">        <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">        <span class="comment">// 未探索</span></span><br><span class="line">        color[u] = Colors.GREY;</span><br><span class="line"></span><br><span class="line">        neighbors.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> w = v;</span><br><span class="line">            <span class="comment">// 未访问</span></span><br><span class="line">            <span class="keyword">if</span> (color[w] === Colors.WHITE) &#123;</span><br><span class="line">                <span class="comment">// 未探索</span></span><br><span class="line">                color[w] = Colors.GREY;</span><br><span class="line">                <span class="comment">// 进队列</span></span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已探索</span></span><br><span class="line">        color[u] = Colors.BLACK;</span><br><span class="line">        callback &amp;&amp; callback(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用BFS寻找最短路径<br>给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。<br>对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> BFS = <span class="function">(<span class="params">graph, startVertex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">    <span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">    <span class="comment">// 距离</span></span><br><span class="line">    <span class="keyword">const</span> distances = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 前溯点</span></span><br><span class="line">    <span class="keyword">const</span> predecessors = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 起始顶点入队列</span></span><br><span class="line">    queue.enqueue(startVertex);</span><br><span class="line"></span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 到v的距离distances[v]</span></span><br><span class="line">        distances[v] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 前溯点pred[v]，推导出到其他每个顶点v的最短路径</span></span><br><span class="line">        predecessors[v] = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 出队列</span></span><br><span class="line">        <span class="keyword">const</span> u = queue.dequeue();</span><br><span class="line">        <span class="comment">// 获得邻点</span></span><br><span class="line">        <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line">        <span class="comment">// 未探索</span></span><br><span class="line">        color[u] = Colors.GREY;</span><br><span class="line"></span><br><span class="line">        neighbors.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果未访问</span></span><br><span class="line">            <span class="keyword">if</span> (color[v] === Colors.WHITE) &#123;</span><br><span class="line">                <span class="comment">// 设为未探索</span></span><br><span class="line">                color[v] = Colors.GREY;</span><br><span class="line">                <span class="comment">// 设置 u 和 v 之间的距离（ u 是 v 的前溯点， d[u] 的值已经有了）</span></span><br><span class="line">                distances[v] = distances[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 顶点 u 的邻点 v 时，则设置 v 的前溯点值为 u </span></span><br><span class="line">                predecessors[v] = u;</span><br><span class="line">                <span class="comment">// 进队列</span></span><br><span class="line">                queue.enqueue(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 设为已探索</span></span><br><span class="line">        color[u] = Colors.BLACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        distances, predecessors</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>深度优先搜索</p>
<ul>
<li><p>从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径（先深度后广度）。</p>
</li>
<li><p>深度优先搜索是递归的，使用栈来存储函数调用（递归调用所创建的栈）。</p>
</li>
<li><p>访问顶点v步骤：</p>
<ul>
<li><p>标注v为被发现的（灰色）。</p>
</li>
<li><p>对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/depthFirstSearch.PNG" width="500"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import Graph from '../../data-structures/graph';</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> depthFirstSearch = <span class="function">(<span class="params">graph, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line"></span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图中每个未被访问的顶点</span></span><br><span class="line">        <span class="comment">// 顶点、颜色数组以及回调函数</span></span><br><span class="line">        color[v] === Colors.WHITE &amp;&amp; depthFirstSearchVisit(v, color, adjList, callback);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> depthFirstSearchVisit = <span class="function">(<span class="params">u, color, adjList, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 访问 u 顶点时，标注为被发现</span></span><br><span class="line">    color[u] = Colors.GREY;</span><br><span class="line">    callback &amp;&amp; callback(u);</span><br><span class="line">    <span class="comment">// console.log('Discovered ' + u);</span></span><br><span class="line">    <span class="comment">// 顶点 u 所有邻点</span></span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line"></span><br><span class="line">    neighbors.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对于顶点 u 的每一个未被访问过的邻点 w ，递归</span></span><br><span class="line">        color[v] === Colors.WHITE &amp;&amp; depthFirstSearchVisit(v, color, adjList, callback);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 该顶点和邻点按深度访问之后，回退，该顶点已被完全探索，并将其标注为 black </span></span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">    <span class="comment">// console.log('explored ' + u);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>深度优先搜索遍历图G的所有节点，构建“森林”（有根树的集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DFS = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">    <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">    <span class="keyword">const</span> color = initializeColor(vertices);</span><br><span class="line">    <span class="comment">// 顶点u的发现时间d[u]</span></span><br><span class="line">    <span class="keyword">const</span> d = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 顶点u的完成探索时间f[u]</span></span><br><span class="line">    <span class="keyword">const</span> f = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 顶点u的前溯点p[u]</span></span><br><span class="line">    <span class="keyword">const</span> p = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非对象的变量不能作为引用传递给其他方法</span></span><br><span class="line">    <span class="comment">// 变量作为引用传递：如果该变量在其他方法内部被修改，新值会在原始变量中反映出来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追踪发现时间和完成探索时间</span></span><br><span class="line">    <span class="comment">// 变量值的范围只可能在图顶点数量的一倍到两倍之间</span></span><br><span class="line">    <span class="keyword">const</span> time = &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        f[v] = <span class="number">0</span>;</span><br><span class="line">        d[v] = <span class="number">0</span>;</span><br><span class="line">        p[v] = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    vertices.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        color[v] === Colors.WHITE &amp;&amp; DFSVisit(v, color, d, f, p, time, adjList);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        discovery: d,</span><br><span class="line">        finished: f,</span><br><span class="line">        predecessors: p</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DFSVisit = <span class="function">(<span class="params">u, color, d, f, p, time, adjList</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log('discovered ' + u);</span></span><br><span class="line">    color[u] = Colors.GREY;</span><br><span class="line">    <span class="comment">// 一个顶点第一次被发现时，追踪其发现时间</span></span><br><span class="line">    d[u] = ++time.count;</span><br><span class="line">    <span class="keyword">const</span> neighbors = adjList.get(u);</span><br><span class="line"></span><br><span class="line">    neighbors.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (color[v] === Colors.WHITE) &#123;</span><br><span class="line">            <span class="comment">// 当它是由引自顶点 u 的边而被发现的，追踪它的前溯点</span></span><br><span class="line">            p[v] = u;</span><br><span class="line">            DFSVisit(v, color, d, f, p, time, adjList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    color[u] = Colors.BLACK;</span><br><span class="line">    <span class="comment">// 最后，当这个顶点被完全探索后，追踪其完成时间</span></span><br><span class="line">    f[u] = ++time.count;</span><br><span class="line">    <span class="comment">// console.log('explored ' + u);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/depthFirstSearchVisit.PNG" width="500"></p>
<p>最短路径算法（Dijkstra算法和Floyd-Warshall算法）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> INF = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>Dijkstra算法：计算从单个源到所有其他源的最短路径的贪心算法，用来计算从图的一个顶点到其余各顶点的最短路径。</p>
<p><img src="/imgs/Dijkstra.PNG" width="500"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算顶点间的 minDistance ，就要搜索 dist 数组中的最小值，返回它在数组中的索引</span></span><br><span class="line"><span class="keyword">const</span> minDistance = <span class="function">(<span class="params">dist, visited</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> min = INF;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; dist.length; v++) &#123;</span><br><span class="line">        <span class="comment">// 未访问的顶点&amp;&amp;该顶点到源顶点的距离小于上一个</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v] === <span class="literal">false</span> &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">            <span class="comment">// 更新最小距离</span></span><br><span class="line">            min = dist[v];</span><br><span class="line">            <span class="comment">// 更新该顶点索引</span></span><br><span class="line">            minIndex = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回各顶点到源顶点的最小距离的顶点的索引</span></span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// src也是索引</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, src</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dist = [];</span><br><span class="line">    <span class="keyword">const</span> visited = [];</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 首先把所有的距离初始化为无限大</span></span><br><span class="line">        dist[i] = INF;</span><br><span class="line">        <span class="comment">// 未访问的顶点</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把源顶点到自己的距离设为 0</span></span><br><span class="line">    dist[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找出到其余顶点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从尚未访问的顶点中选出距离源顶点最近的顶点索引</span></span><br><span class="line">        <span class="keyword">const</span> u = minDistance(dist, visited);</span><br><span class="line">        <span class="comment">// 把选出的顶点标为已处理，以免重复计算</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="comment">// 没访问过的顶点&amp;&amp;两顶点相邻并且有距离&amp;&amp;到最近顶点u已经更新了距离&amp;&amp;到最近顶点u的距离+uv的边长&lt;到顶点v的距离</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; graph[u][v] !== <span class="number">0</span> &amp;&amp; dist[u] !== INF &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                <span class="comment">// 如果找到更短的路径，则更新最短路径的值</span></span><br><span class="line">                dist[v] = dist[u] + graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完所有顶点后，返回从源顶点到图中其他顶点最短路径的结果</span></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Floyd-Warshall算法：计算图中所有最短路径的动态规划算法，可以找出从所有源到所有顶点的最短路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> floydWarshall = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dist = [];</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">    <span class="comment">// 首先把 dist 数组初始化为每个顶点之间的权值，因为 i 到 j 可能的最短距离就是这些顶点间的权值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        dist[i] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i === j) &#123;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">isFinite</span>(graph[i][j])) &#123;</span><br><span class="line">                dist[i][j] = <span class="literal">Infinity</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dist[i][j] = graph[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 k ，得到 i 途径顶点 0 至 k ，到达 j 的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="comment">// 判断 i 经过顶点 k 到达 j 的路径是否比已有的最短路径更短（核心）</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    <span class="comment">// 如果是更短的路径，则更新最短路径的值</span></span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最小生成树（Prim算法和Kruskal算法）</p>
<p>在n个岛屿之间建造桥梁，用最低的成本实现所有岛屿相互连通，岛屿表示为图中的一个顶点，边代表成本。</p>
<p>Prim算法：求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minKey = <span class="function">(<span class="params">graph, key, visited</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize min value</span></span><br><span class="line">    <span class="keyword">let</span> min = INF;</span><br><span class="line">    <span class="keyword">let</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; graph.length; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] === <span class="literal">false</span> &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">            min = key[v];</span><br><span class="line">            minIndex = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minIndex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> prim = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = [];</span><br><span class="line">    <span class="keyword">const</span> key = [];</span><br><span class="line">    <span class="keyword">const</span> visited = [];</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125; = graph;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 首先，把所有顶点（ key ）初始化为无限大（</span></span><br><span class="line">        key[i] = INF;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以 parent[0] = -1 。</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 对所有顶点求MST</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 从未处理的顶点集合中选出 key 值最小的顶点</span></span><br><span class="line">        <span class="keyword">const</span> u = minKey(graph, key, visited);</span><br><span class="line">        <span class="comment">// 把选出的顶点标为 visited ，以免重复计算</span></span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v = <span class="number">0</span>; v &lt; length; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">                <span class="comment">// 如果得到更小的权值，则保存MST路径</span></span><br><span class="line">                parent[v] = u;</span><br><span class="line">                <span class="comment">// 更新其权值</span></span><br><span class="line">                key[v] = graph[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完所有顶点后，返回包含MST的结果</span></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Prim算法和Dijkstra算法非常相似。</p>
<p>Prim算法用parent 数组保存MST的结果，用key数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。</p>
<p>可以修改Dijkstra算法，加入parent 数组，这样就可以在求出距离的同时得到路径。</p>
<p>Kruskal算法：求加权无向连通图的MST的贪心算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止MST出现环路</span></span><br><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">i, parent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i]) &#123;</span><br><span class="line">        i = parent[i]; <span class="comment">// eslint-disable-line prefer-destructuring</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">i, j, parent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== j) &#123;</span><br><span class="line">        parent[j] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> initializeCost = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cost = [];</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        cost[i] = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i][j] === <span class="number">0</span>) &#123;</span><br><span class="line">                cost[i][j] = INF;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cost[i][j] = graph[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> kruskal = <span class="function"><span class="params">graph</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = graph;</span><br><span class="line">    <span class="keyword">const</span> parent = [];</span><br><span class="line">    <span class="keyword">let</span> ne = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    <span class="keyword">let</span> u;</span><br><span class="line">    <span class="keyword">let</span> v;</span><br><span class="line">    <span class="comment">// 首先把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span></span><br><span class="line">    <span class="keyword">const</span> cost = initializeCost(graph);</span><br><span class="line">    <span class="comment">// 当MST的边数小于顶点总数减 1 时</span></span><br><span class="line">    <span class="keyword">while</span> (ne &lt; length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 找出权值最小的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, min = INF; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cost[i][j] &lt; min) &#123;</span><br><span class="line">                    min = cost[i][j];</span><br><span class="line">                    a = u = i;</span><br><span class="line">                    b = v = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查MST中是否已存在这条边，以避免环路</span></span><br><span class="line">        u = find(u, parent);</span><br><span class="line">        v = find(v, parent);</span><br><span class="line">        <span class="comment">// 如果 u 和 v 是不同的边，则将其加入MST</span></span><br><span class="line">        union(u, v, parent) &amp;&amp; ne++; </span><br><span class="line">        <span class="comment">// 从列表中移除这些边，以免重复计算</span></span><br><span class="line">        cost[a][b] = cost[b][a] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回MST</span></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
