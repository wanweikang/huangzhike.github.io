<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-图 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-图">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-图</h2>
				
				<div>
					<div class="post-time">2018-11-23</div>
				</div>
				
				<div class="article-content">
				<p><strong>笔记来源：《学习JavaScript数据结构与算法》 By <a href="https://github.com/loiane" target="_blank" rel="noopener">Loiane Groner</a></strong></p>
<p>图G是一组由边E连接的节点（顶点V）。</p>
<p>一个顶点的度是其相邻顶点的数量。比如，A和其他三个顶点相连接，因此A的度为3。</p>
<p>如果图中不存在环，则称该图是无环的。</p>
<p>如果图中每两个顶点间都存在路径，则该图是连通的。</p>
<p>图可以是无向的（边没有方向）或是有向的。</p>
<p>图中每两个顶点间在双向上都存在路径，则该图是强连通的。</p>
<p>图还可以是未加权的或是加权的，加权图的边被赋予了权值。</p>
<p>图的实现</p>
<ul>
<li><p>邻接矩阵。</p>
<ul>
<li><p>用一个二维数组来表示顶点之间的连接。</p>
</li>
<li><p>如果索引为i的节点和索引为j的节点相邻，则<code>array[i][j] === 1</code>，否则<code>array[i][j] === 0</code>。</p>
</li>
<li><p>不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，浪费了空间。</p>
</li>
<li><p>找给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，也不得不迭代一整行。</p>
</li>
<li><p>图中顶点的数量可能会改变，而二维数组不灵活。</p>
</li>
<li><p>但要找出顶点v和w是否相邻，使用邻接矩阵会比较快。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>邻接表。</p>
<ul>
<li><p>邻接表由图中每个顶点的相邻顶点列表所组成。</p>
</li>
<li><p>可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>关联矩阵。</p>
<ul>
<li><p>在关联矩阵中，矩阵的行表示顶点，列表示边。</p>
</li>
<li><p>使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则<code>array[v][e] === 1</code>；否则，<code>array[v][e] === 0</code>。</p>
</li>
<li><p>关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/graph.PNG" width="500"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import Dictionary from &apos;./dictionary&apos;;</span><br><span class="line"></span><br><span class="line">export</span><br><span class="line">default class Graph &#123;</span><br><span class="line">	constructor(isDirected = false) &#123;</span><br><span class="line">		// 是否有向</span><br><span class="line">		this.isDirected = isDirected;</span><br><span class="line">		// 数组存储图中所有顶点</span><br><span class="line">		this.vertices = [];</span><br><span class="line">		// 字典存储邻接表，顶点名作为键，邻接顶点列表作为值</span><br><span class="line">		this.adjList = new Dictionary();</span><br><span class="line">	&#125;</span><br><span class="line">	// 向图添加一个顶点</span><br><span class="line">	addVertex(v) &#123;</span><br><span class="line">		if (!this.vertices.includes(v)) &#123;</span><br><span class="line">			// 将该顶点添加到顶点列表中</span><br><span class="line">			this.vertices.push(v);</span><br><span class="line">			// 在邻接表中，设置顶点 v 作为键对应的字典值为一个空数组</span><br><span class="line">			this.adjList.set(v, []); // initialize adjacency list with array as well;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 添加顶点之间的边两个顶点作为参数</span><br><span class="line">	addEdge(a, b) &#123; </span><br><span class="line">		!this.adjList.get(a) &amp;&amp; this.addVertex(a);</span><br><span class="line">		!this.adjList.get(b) &amp;&amp; this.addVertex(b);</span><br><span class="line">		// 将b加入到a的邻接表中，添加了一条自顶点a到顶点b的边</span><br><span class="line">		this.adjList.get(a).push(b);</span><br><span class="line">		// 添加一条自b向a的边，上一步实现有向图，这一步实现无向图</span><br><span class="line">		// commented to run the improved DFS with topological sorting</span><br><span class="line">		this.isDirected !== true &amp;&amp; this.adjList.get(b).push(a);</span><br><span class="line">	&#125;</span><br><span class="line">	getVertices() &#123;</span><br><span class="line">		return this.vertices;</span><br><span class="line">	&#125;</span><br><span class="line">	getAdjList() &#123;</span><br><span class="line">		return this.adjList;</span><br><span class="line">	&#125;</span><br><span class="line">	toString() &#123;</span><br><span class="line">		let s = &apos;&apos;;</span><br><span class="line">		for (let i = 0; i &lt; this.vertices.length; i++) &#123;</span><br><span class="line">			s += `$ &#123;this.vertices[i]&#125; - &gt; `;</span><br><span class="line">			const neighbors = this.adjList.get(this.vertices[i]);</span><br><span class="line">			for (let j = 0; j &lt; neighbors.length; j++) &#123;</span><br><span class="line">				s += `$ &#123;neighbors[j]&#125;`;</span><br><span class="line">			&#125;</span><br><span class="line">			s += &apos;\n&apos;;</span><br><span class="line">		&#125;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对图遍历：广度优先搜索（Breadth - First Search，BFS）和深度优先搜索（Depth - First Search，DFS）。</p>
<ul>
<li><p>图遍历：</p>
<ul>
<li><p>追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。</p>
</li>
<li><p>完全探索一个顶点要求查看该顶点的每一条边。</p>
</li>
<li><p>对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
</li>
<li><p>为了保证效率，访问每个顶点至多两次。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>深度优先搜索</p>
<ul>
<li><p>数据结构：栈。</p>
</li>
<li><p>将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>广度优先搜索</p>
<ul>
<li><p>数据结构：队列</p>
</li>
<li><p>将顶点存入队列中，最先入队列的顶点先被探索。</p>
</li>
</ul>
</li>
<li><p>用三种颜色标注顶点的访问状态：</p>
<ul>
<li><p>白色：该顶点还没有被访问。</p>
</li>
<li><p>灰色：该顶点被访问过，但并未被探索过。</p>
</li>
<li><p>黑色：该顶点被访问过且被完全探索过（访问每个顶点最多两次）。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Colors = &#123;</span><br><span class="line">	WHITE: 0,</span><br><span class="line">	GREY: 1,</span><br><span class="line">	BLACK: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化颜色地图</span><br><span class="line">const initializeColor = vertices =&gt; &#123;</span><br><span class="line">	const color = &#123;&#125;;</span><br><span class="line">	vertices.forEach(v =&gt; color[v] = Colors.WHITE)</span><br><span class="line">	return color;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>广度优先搜索</p>
<ul>
<li><p>从顶点v开始的广度优先搜索算法</p>
<ul>
<li><p>创建一个队列Q。</p>
</li>
<li><p>将v标注为被发现的（灰色），并将v入队列Q。</p>
</li>
<li><p>如果Q非空：</p>
<ul>
<li><p>将u从Q中出队列；</p>
</li>
<li><p>将标注u为被发现的（灰色）；</p>
</li>
<li><p>将u所有未被访问过的邻点（白色）入队列；</p>
</li>
<li><p>将u标注为已被探索的（黑色）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/breadthFirstSearch.PNG" width="500"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import Queue from &apos;../../data-structures/queue&apos;;</span><br><span class="line"></span><br><span class="line">export const breadthFirstSearch = (graph, startVertex, callback) =&gt; &#123;</span><br><span class="line">	const vertices = graph.getVertices();</span><br><span class="line">	const adjList = graph.getAdjList();</span><br><span class="line">	const color = initializeColor(vertices);</span><br><span class="line">	const queue = new Queue();</span><br><span class="line">	// 进队列</span><br><span class="line">	queue.enqueue(startVertex);</span><br><span class="line">	// 循环队列</span><br><span class="line">	while (!queue.isEmpty()) &#123;</span><br><span class="line">		// 出队列</span><br><span class="line">		const u = queue.dequeue();</span><br><span class="line">		const neighbors = adjList.get(u);</span><br><span class="line">		// 未探索</span><br><span class="line">		color[u] = Colors.GREY;</span><br><span class="line"></span><br><span class="line">		neighbors.forEach(v =&gt; &#123;</span><br><span class="line">			const w = v;</span><br><span class="line">			// 未访问</span><br><span class="line">			if (color[w] === Colors.WHITE) &#123;</span><br><span class="line">				// 未探索</span><br><span class="line">				color[w] = Colors.GREY;</span><br><span class="line">				// 进队列</span><br><span class="line">				queue.enqueue(w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		// 已探索</span><br><span class="line">		color[u] = Colors.BLACK;</span><br><span class="line">		callback &amp;&amp; callback(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用BFS寻找最短路径<br>给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离（以边的数量计）。<br>对于给定顶点v，广度优先算法会访问所有与其距离为1的顶点，接着是距离为2的顶点，以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export const BFS = (graph, startVertex) =&gt; &#123;</span><br><span class="line">	const vertices = graph.getVertices();</span><br><span class="line">	const adjList = graph.getAdjList();</span><br><span class="line">	const color = initializeColor(vertices);</span><br><span class="line">	const queue = new Queue();</span><br><span class="line">	// 距离</span><br><span class="line">	const distances = &#123;&#125;;</span><br><span class="line">	// 前溯点</span><br><span class="line">	const predecessors = &#123;&#125;;</span><br><span class="line">	// 起始顶点入队列</span><br><span class="line">	queue.enqueue(startVertex);</span><br><span class="line"></span><br><span class="line">	vertices.forEach(v =&gt; &#123;</span><br><span class="line">		// 到v的距离distances[v]</span><br><span class="line">		distances[v] = 0;</span><br><span class="line">		// 前溯点pred[v]，推导出到其他每个顶点v的最短路径</span><br><span class="line">		predecessors[v] = null;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	while (!queue.isEmpty()) &#123;</span><br><span class="line">		// 出队列</span><br><span class="line">		const u = queue.dequeue();</span><br><span class="line">		// 获得邻点</span><br><span class="line">		const neighbors = adjList.get(u);</span><br><span class="line">		// 未探索</span><br><span class="line">		color[u] = Colors.GREY;</span><br><span class="line"></span><br><span class="line">		neighbors.forEach(v =&gt; &#123;</span><br><span class="line">			// 如果未访问</span><br><span class="line">			if (color[v] === Colors.WHITE) &#123;</span><br><span class="line">				// 设为未探索</span><br><span class="line">				color[v] = Colors.GREY;</span><br><span class="line">				// 设置 u 和 v 之间的距离（ u 是 v 的前溯点， d[u] 的值已经有了）</span><br><span class="line">				distances[v] = distances[u] + 1;</span><br><span class="line">				// 顶点 u 的邻点 v 时，则设置 v 的前溯点值为 u </span><br><span class="line">				predecessors[v] = u;</span><br><span class="line">				// 进队列</span><br><span class="line">				queue.enqueue(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		// 设为已探索</span><br><span class="line">		color[u] = Colors.BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		distances, predecessors</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>深度优先搜索</p>
<ul>
<li><p>从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径（先深度后广度）。</p>
</li>
<li><p>深度优先搜索是递归的，使用栈来存储函数调用（递归调用所创建的栈）。</p>
</li>
<li><p>访问顶点v步骤：</p>
<ul>
<li><p>标注v为被发现的（灰色）。</p>
</li>
<li><p>对于v的所有未访问的邻点w，访问顶点w，标注v为已被探索的（黑色）。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/imgs/depthFirstSearch.PNG" width="500"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// import Graph from &apos;../../data-structures/graph&apos;;</span><br><span class="line"> </span><br><span class="line">export const depthFirstSearch = (graph, callback) =&gt; &#123;</span><br><span class="line">	const vertices = graph.getVertices();</span><br><span class="line">	const adjList = graph.getAdjList();</span><br><span class="line">	const color = initializeColor(vertices);</span><br><span class="line"></span><br><span class="line">	vertices.forEach(v =&gt; &#123;</span><br><span class="line">		// 图中每个未被访问的顶点</span><br><span class="line">		// 顶点、颜色数组以及回调函数</span><br><span class="line">		color[v] === Colors.WHITE &amp;&amp; depthFirstSearchVisit(v, color, adjList, callback);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const depthFirstSearchVisit = (u, color, adjList, callback) =&gt; &#123;</span><br><span class="line">	// 访问 u 顶点时，标注为被发现</span><br><span class="line">	color[u] = Colors.GREY;</span><br><span class="line">	callback &amp;&amp; callback(u);</span><br><span class="line">	// console.log(&apos;Discovered &apos; + u);</span><br><span class="line">	// 顶点 u 所有邻点</span><br><span class="line">	const neighbors = adjList.get(u);</span><br><span class="line"></span><br><span class="line">	neighbors.forEach(v =&gt; &#123;</span><br><span class="line">		// 对于顶点 u 的每一个未被访问过的邻点 w ，递归</span><br><span class="line">		color[v] === Colors.WHITE &amp;&amp; depthFirstSearchVisit(v, color, adjList, callback);</span><br><span class="line">	&#125;)</span><br><span class="line">	// 该顶点和邻点按深度访问之后，回退，该顶点已被完全探索，并将其标注为 black </span><br><span class="line">	color[u] = Colors.BLACK;</span><br><span class="line">	// console.log(&apos;explored &apos; + u);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>深度优先搜索遍历图G的所有节点，构建“森林”（有根树的集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">export const DFS = graph =&gt; &#123;</span><br><span class="line">	const vertices = graph.getVertices();</span><br><span class="line">	const adjList = graph.getAdjList();</span><br><span class="line">	const color = initializeColor(vertices);</span><br><span class="line">	// 顶点u的发现时间d[u]</span><br><span class="line">	const d = &#123;&#125;;</span><br><span class="line">	// 顶点u的完成探索时间f[u]</span><br><span class="line">	const f = &#123;&#125;;</span><br><span class="line">	// 顶点u的前溯点p[u]</span><br><span class="line">	const p = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	// 非对象的变量不能作为引用传递给其他方法</span><br><span class="line">	// 变量作为引用传递：如果该变量在其他方法内部被修改，新值会在原始变量中反映出来</span><br><span class="line"></span><br><span class="line">	// 追踪发现时间和完成探索时间</span><br><span class="line">	// 变量值的范围只可能在图顶点数量的一倍到两倍之间</span><br><span class="line">	const time = &#123;</span><br><span class="line">		count: 0</span><br><span class="line">	&#125;;</span><br><span class="line">	vertices.forEach(v =&gt; &#123;</span><br><span class="line">		f[v] = 0;</span><br><span class="line">		d[v] = 0;</span><br><span class="line">		p[v] = null;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	vertices.forEach(v =&gt; &#123;</span><br><span class="line">		color[v] === Colors.WHITE &amp;&amp; DFSVisit(v, color, d, f, p, time, adjList);</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	return &#123;</span><br><span class="line">		discovery: d,</span><br><span class="line">		finished: f,</span><br><span class="line">		predecessors: p</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const DFSVisit = (u, color, d, f, p, time, adjList) =&gt; &#123;</span><br><span class="line">	// console.log(&apos;discovered &apos; + u);</span><br><span class="line">	color[u] = Colors.GREY;</span><br><span class="line">	// 一个顶点第一次被发现时，追踪其发现时间</span><br><span class="line">	d[u] = ++time.count;</span><br><span class="line">	const neighbors = adjList.get(u);</span><br><span class="line"></span><br><span class="line">	neighbors.forEach(v =&gt; &#123;</span><br><span class="line">		if (color[v] === Colors.WHITE) &#123;</span><br><span class="line">			// 当它是由引自顶点 u 的边而被发现的，追踪它的前溯点</span><br><span class="line">			p[v] = u;</span><br><span class="line">			DFSVisit(v, color, d, f, p, time, adjList);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	color[u] = Colors.BLACK;</span><br><span class="line">	// 最后，当这个顶点被完全探索后，追踪其完成时间</span><br><span class="line">	f[u] = ++time.count;</span><br><span class="line">	// console.log(&apos;explored &apos; + u);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/depthFirstSearchVisit.PNG" width="500"></p>
<p>最短路径算法（Dijkstra算法和Floyd-Warshall算法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const INF = Number.MAX_SAFE_INTEGER;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var graph = [</span><br><span class="line">	[0, 2, 4, 0, 0, 0],</span><br><span class="line">	[2, 0, 2, 4, 2, 0],</span><br><span class="line">	[4, 2, 0, 0, 3, 0],</span><br><span class="line">	[0, 4, 0, 0, 3, 2],</span><br><span class="line">	[0, 2, 3, 3, 0, 2],</span><br><span class="line">	[0, 0, 0, 2, 2, 0]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>Dijkstra算法：计算从单个源到所有其他源的最短路径的贪心算法，用来计算从图的一个顶点到其余各顶点的最短路径。</p>
<p><img src="/imgs/Dijkstra.PNG" width="500"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 计算顶点间的 minDistance ，就要搜索 dist 数组中的最小值，返回它在数组中的索引</span><br><span class="line">const minDistance = (dist, visited) =&gt; &#123;</span><br><span class="line">	let min = INF;</span><br><span class="line">	let minIndex = -1;</span><br><span class="line">	for (let v = 0; v &lt; dist.length; v++) &#123;</span><br><span class="line">	    // 未访问的顶点&amp;&amp;该顶点到源顶点的距离小于上一个</span><br><span class="line">		if (visited[v] === false &amp;&amp; dist[v] &lt;= min) &#123;</span><br><span class="line">		    // 更新最小距离</span><br><span class="line">			min = dist[v];</span><br><span class="line">			// 更新该顶点索引</span><br><span class="line">			minIndex = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 返回各顶点到源顶点的最小距离的顶点的索引</span><br><span class="line">	return minIndex;</span><br><span class="line">&#125;;</span><br><span class="line">// src也是索引</span><br><span class="line">export const dijkstra = (graph, src) =&gt; &#123;</span><br><span class="line">	const dist = [];</span><br><span class="line">	const visited = [];</span><br><span class="line">	const &#123; length &#125; = graph;</span><br><span class="line">	for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		// 首先把所有的距离初始化为无限大</span><br><span class="line">		dist[i] = INF;</span><br><span class="line">		// 未访问的顶点</span><br><span class="line">		visited[i] = false;</span><br><span class="line">	&#125;</span><br><span class="line">	// 把源顶点到自己的距离设为 0</span><br><span class="line">	dist[src] = 0;</span><br><span class="line">	// 找出到其余顶点的最短路径</span><br><span class="line">	for (let i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">		// 从尚未访问的顶点中选出距离源顶点最近的顶点索引</span><br><span class="line">		const u = minDistance(dist, visited);</span><br><span class="line">		// 把选出的顶点标为已处理，以免重复计算</span><br><span class="line">		visited[u] = true;</span><br><span class="line">		for (let v = 0; v &lt; length; v++) &#123;</span><br><span class="line">			// 没访问过的顶点&amp;&amp;两顶点相邻并且有距离&amp;&amp;到最近顶点u已经更新了距离&amp;&amp;到最近顶点u的距离+uv的边长&lt;到顶点v的距离</span><br><span class="line">			if (!visited[v] &amp;&amp; graph[u][v] !== 0 &amp;&amp; dist[u] !== INF &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) &#123;</span><br><span class="line">				// 如果找到更短的路径，则更新最短路径的值</span><br><span class="line">				dist[v] = dist[u] + graph[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 处理完所有顶点后，返回从源顶点到图中其他顶点最短路径的结果</span><br><span class="line">	return dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Floyd-Warshall算法：计算图中所有最短路径的动态规划算法，可以找出从所有源到所有顶点的最短路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export const floydWarshall = graph =&gt; &#123;</span><br><span class="line">	const dist = [];</span><br><span class="line">	const &#123; length &#125; = graph;</span><br><span class="line">	// 首先把 dist 数组初始化为每个顶点之间的权值，因为 i 到 j 可能的最短距离就是这些顶点间的权值</span><br><span class="line">	for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line"></span><br><span class="line">		dist[i] = [];</span><br><span class="line">		for (let j = 0; j &lt; length; j++) &#123;</span><br><span class="line">			if (i === j) &#123;</span><br><span class="line">				dist[i][j] = 0;</span><br><span class="line">			&#125; else if (!isFinite(graph[i][j])) &#123;</span><br><span class="line">				dist[i][j] = Infinity;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				dist[i][j] = graph[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 通过 k ，得到 i 途径顶点 0 至 k ，到达 j 的最短路径</span><br><span class="line">	for (let k = 0; k &lt; length; k++) &#123;</span><br><span class="line">		for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">			for (let j = 0; j &lt; length; j++) &#123;</span><br><span class="line">				// 判断 i 经过顶点 k 到达 j 的路径是否比已有的最短路径更短（核心）</span><br><span class="line">				if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">					// 如果是更短的路径，则更新最短路径的值</span><br><span class="line">					dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最小生成树（Prim算法和Kruskal算法）</p>
<p>在n个岛屿之间建造桥梁，用最低的成本实现所有岛屿相互连通，岛屿表示为图中的一个顶点，边代表成本。</p>
<p>Prim算法：求解加权无向连通图的MST问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const minKey = (graph, key, visited) =&gt; &#123;</span><br><span class="line">	// Initialize min value</span><br><span class="line">	let min = INF;</span><br><span class="line">	let minIndex = 0;</span><br><span class="line">	for (let v = 0; v &lt; graph.length; v++) &#123;</span><br><span class="line">		if (visited[v] === false &amp;&amp; key[v] &lt; min) &#123;</span><br><span class="line">			min = key[v];</span><br><span class="line">			minIndex = v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return minIndex;</span><br><span class="line">&#125;;</span><br><span class="line">export const prim = graph =&gt; &#123;</span><br><span class="line">	const parent = [];</span><br><span class="line">	const key = [];</span><br><span class="line">	const visited = [];</span><br><span class="line">	const &#123;</span><br><span class="line">		length</span><br><span class="line">	&#125; = graph;</span><br><span class="line">	for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		// 首先，把所有顶点（ key ）初始化为无限大（</span><br><span class="line">		key[i] = INF;</span><br><span class="line">		visited[i] = false;</span><br><span class="line">	&#125;</span><br><span class="line">	// 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是MST的根节点，所以 parent[0] = -1 。</span><br><span class="line">	key[0] = 0;</span><br><span class="line">	parent[0] = -1;</span><br><span class="line">	// 对所有顶点求MST</span><br><span class="line">	for (let i = 0; i &lt; length - 1; i++) &#123;</span><br><span class="line">		// 从未处理的顶点集合中选出 key 值最小的顶点</span><br><span class="line">		const u = minKey(graph, key, visited);</span><br><span class="line">		// 把选出的顶点标为 visited ，以免重复计算</span><br><span class="line">		visited[u] = true;</span><br><span class="line">		for (let v = 0; v &lt; length; v++) &#123;</span><br><span class="line">			if (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123;</span><br><span class="line">				// 如果得到更小的权值，则保存MST路径</span><br><span class="line">				parent[v] = u;</span><br><span class="line">				// 更新其权值</span><br><span class="line">				key[v] = graph[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 处理完所有顶点后，返回包含MST的结果</span><br><span class="line">	return parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Prim算法和Dijkstra算法非常相似。</p>
<p>Prim算法用 parent 数组保存MST的结果，用 key 数组保存权值最小的边，而在Dijkstra算法中，用dist数组保存距离。</p>
<p>可以修改Dijkstra算法，加入 parent 数组，这样就可以在求出距离的同时得到路径。</p>
<p>Kruskal算法：求加权无向连通图的MST的贪心算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">// 防止MST出现环路</span><br><span class="line">const find = (i, parent) =&gt; &#123;</span><br><span class="line">	while (parent[i]) &#123;</span><br><span class="line">		i = parent[i]; // eslint-disable-line prefer-destructuring</span><br><span class="line">	&#125;</span><br><span class="line">	return i;</span><br><span class="line">&#125;;</span><br><span class="line">const union = (i, j, parent) =&gt; &#123;</span><br><span class="line">	if (i !== j) &#123;</span><br><span class="line">		parent[j] = i;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;;</span><br><span class="line">const initializeCost = graph =&gt; &#123;</span><br><span class="line">	const cost = [];</span><br><span class="line">	const &#123; length &#125; = graph;</span><br><span class="line">	for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">		cost[i] = [];</span><br><span class="line">		for (let j = 0; j &lt; length; j++) &#123;</span><br><span class="line">			if (graph[i][j] === 0) &#123;</span><br><span class="line">				cost[i][j] = INF;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cost[i][j] = graph[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return cost;</span><br><span class="line">&#125;;</span><br><span class="line">export const kruskal = graph =&gt; &#123;</span><br><span class="line">	const &#123; length &#125; = graph;</span><br><span class="line">	const parent = [];</span><br><span class="line">	let ne = 0;</span><br><span class="line">	let a;</span><br><span class="line">	let b;</span><br><span class="line">	let u;</span><br><span class="line">	let v;</span><br><span class="line">	// 首先把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值</span><br><span class="line">	const cost = initializeCost(graph);</span><br><span class="line">	// 当MST的边数小于顶点总数减 1 时</span><br><span class="line">	while (ne &lt; length - 1) &#123;</span><br><span class="line">		// 找出权值最小的边</span><br><span class="line">		for (let i = 0, min = INF; i &lt; length; i++) &#123;</span><br><span class="line">			for (let j = 0; j &lt; length; j++) &#123;</span><br><span class="line">				if (cost[i][j] &lt; min) &#123;</span><br><span class="line">					min = cost[i][j];</span><br><span class="line">					a = u = i;</span><br><span class="line">					b = v = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 检查MST中是否已存在这条边，以避免环路</span><br><span class="line">		u = find(u, parent);</span><br><span class="line">		v = find(v, parent);</span><br><span class="line">		// 如果 u 和 v 是不同的边，则将其加入MST</span><br><span class="line">		union(u, v, parent) &amp;&amp; ne++; </span><br><span class="line">		// 从列表中移除这些边，以免重复计算</span><br><span class="line">		cost[a][b] = cost[b][a] = INF;</span><br><span class="line">	&#125;</span><br><span class="line">	// 返回MST</span><br><span class="line">	return parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
