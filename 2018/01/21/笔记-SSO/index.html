<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-SSO | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-SSO">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-SSO</h2>
				
				<div>
					<div class="post-time">2018-01-21</div>
				</div>
				
				<div class="article-content">
				<p>感冒头疼，随便逛，发现新名词。资料来源于网络。</p>
<p>单点登录（Single Sign On）</p>
<ul>
<li><p>多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
</li>
<li><p>用户第一次访问应用系统A的时候，还没有登录，会被引导到认证系统中登录（在URL添加一个返回地址）。</p>
</li>
<li><p>认证系统进行身份效验，如果通过效验，返回给用户一个认证的凭据token（保存到session或cookies）。</p>
</li>
<li><p>用户再访问别的应用的时候就会将这个认证的凭据带上。</p>
</li>
<li><p>应用系统接受到请求之后会把凭据送到认证系统进行效验，检查凭据的合法性。</p>
</li>
<li><p>如果通过效验，用户就可以在不用再次登录的情况下访问应用系统。</p>
</li>
</ul>
<p>单点注销</p>
<ul>
<li><p>认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。</p>
</li>
<li><p>用户向系统A发起注销请求，系统A根据用户与系统A建立的会话id拿到令牌，向认证中心发起注销请求。</p>
</li>
<li><p>认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。</p>
</li>
<li><p>认证中心向所有注册系统发起注销请求。</p>
</li>
<li><p>各注册系统接收认证中心的注销请求，销毁局部会话。</p>
</li>
<li><p>认证中心引导用户至登录页面。</p>
</li>
</ul>
<p>所有应用系统共享一个统一身份认证平台</p>
<ul>
<li><p>将用户的登录信息和用户信息库相比较，对用户进行登录认证；</p>
</li>
<li><p>认证成功后，认证系统生成统一的认证标志，返还给用户；</p>
</li>
<li><p>认证系统还应该对认证标志效验，判断其有效性。</p>
</li>
</ul>
<p>所有应用系统能够识别和提取认证标志</p>
<ul>
<li>应用系统应该能对认证标志进行识别和提取，与认证系统通讯，能自动判断当前用户是否登录过。</li>
</ul>
<hr>
<p>以Cookie作为凭证媒介</p>
<ul>
<li><p>用户凭证存储在客户端。</p>
</li>
<li><p>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie。</p>
</li>
<li><p>授权应用解密cookie并进行校验，校验通过则登录当前用户。</p>
</li>
<li><p>Cookie不安全。</p>
</li>
<li><p>不能跨域（设置cookie域名）。</p>
</li>
</ul>
<p>通过JSONP实现</p>
<ul>
<li><p>用户在父应用中登录后，跟Session匹配的Cookie会存到客户端中。</p>
</li>
<li><p>当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的Cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息。</p>
</li>
<li><p>子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>
</li>
<li><p>可以跨域。</p>
</li>
<li><p>安全性其实跟把信任存储到Cookie是差不多。一旦加密算法泄露了，攻击者可以在本地建立一个实现了登录接口的假冒父应用，通过绑定Host来把子应用发起的请求指向本地的假冒父应用，并作出回应。攻击者可以按照加密算法来伪造响应请求，子应用接收到这个响应之后一样可以通过验证，并且登录特定用户。</p>
</li>
</ul>
<p>通过页面重定向的方式</p>
<ul>
<li><p>通过父应用和子应用来回重定向中进行通信，实现信息的安全传递。</p>
</li>
<li><p>父应用提供一个GET方式的登录接口，用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，返回一个的登录页面，用户登录。</p>
</li>
<li><p>如果用户已经登录了，则生成加密的Token，并且重定向到子应用提供的验证Token的接口，通过解密和校验之后，子应用登录当前用户。</p>
</li>
<li><p>解决安全和跨域的问题，但是不方便。</p>
</li>
</ul>
<p>使用独立登录系统</p>
<ul>
<li><p>一般说来，大型应用会把授权的逻辑与用户信息的相关逻辑独立成一个应用，称为用户中心。</p>
</li>
<li><p>用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。</p>
</li>
<li><p>第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕返回凭证，第三方应用验证凭证，通过后就登录用户。</p>
</li>
</ul>
<hr>
<p>客户端/服务端架构</p>
<ul>
<li><p>sso-client</p>
<ul>
<li>拦截子系统未登录用户请求，跳转至sso认证中心</li>
<li>接收并存储sso认证中心发送的令牌</li>
<li>与sso-server通信，校验令牌的有效性</li>
<li>建立局部会话</li>
<li>拦截用户注销请求，向sso认证中心发送注销请求</li>
<li>接收sso认证中心发出的注销请求，销毁局部会话</li>
</ul>
</li>
<li><p>sso-server</p>
<ul>
<li>验证用户的登录信息</li>
<li>创建全局会话</li>
<li>创建授权令牌</li>
<li>与sso-client通信发送令牌</li>
<li>校验sso-client令牌有效性</li>
<li>系统注册</li>
<li>接收sso-client注销请求，注销所有会话</li>
</ul>
</li>
</ul>
<p>sso-client拦截未登录请求，有servlet、filter、listener三种方式，这里采用filter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) </span><br><span class="line">		throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">	HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">	HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">	HttpSession session = req.getSession();</span><br><span class="line"></span><br><span class="line">	if (session.getAttribute(&quot;isLogin&quot;)) &#123;</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	// 跳转至sso认证中心</span><br><span class="line">	res.sendRedirect(&quot;sso-server-url-with-system-url&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sso-server拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样。</p>
<p>sso-server验证用户登录信息，校验成功，将会话状态标记为“已登录”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/login&quot;)</span><br><span class="line">public String login(String username, String password, HttpServletRequest req) &#123;</span><br><span class="line">	this.checkLoginInfo(username, password);</span><br><span class="line">	req.getSession().setAttribute(&quot;isLogin&quot;, true);</span><br><span class="line">	return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sso-server创建授权令牌，令牌是一串随机字符，只要不重复、不易伪造即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String token = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure>
<p>sso-client取得令牌并校验。</p>
<p>sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在<code>doFilter()</code>中添加几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 请求附带token参数</span><br><span class="line">String token = req.getParameter(&quot;token&quot;);</span><br><span class="line">if (token != null) &#123;</span><br><span class="line">	// 去sso认证中心校验token</span><br><span class="line">	boolean verifyResult = this.verify(&quot;sso-server-verify-url&quot;, token);</span><br><span class="line">	if (!verifyResult) &#123;</span><br><span class="line">		res.sendRedirect(&quot;sso-server-url&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>verify()</code>方法使用httpClient实现，详细使用方法请参考官方文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpPost httpPost = new HttpPost(&quot;sso-server-verify-url-with-token&quot;);</span><br><span class="line">HttpResponse httpResponse = httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure>
<p>sso-server接收并处理校验令牌请求</p>
<p>用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来）。</p>
<p>令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。</p>
<p>redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p>
<p>令牌与注册系统地址可以储在redis中，为什么要存储系统的地址？</p>
<p>如果不存储，注销的时候用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3b221593-f9c4-45af-a567-4937786993e8</span><br></pre></td></tr></table></figure></p>
<p>sso-client校验令牌成功创建局部会话</p>
<p>令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改Filter，添加几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (verifyResult) &#123;</span><br><span class="line">	session.setAttribute(&quot;isLogin&quot;, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用hashmap保存，保存的数据用来处理sso认证中心发来的注销请求。</p>
<p>注销过程</p>
<p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String logout = req.getParameter(&quot;logout&quot;);</span><br><span class="line">if (logout != null) &#123;</span><br><span class="line">	this.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/logout&quot;)</span><br><span class="line">public String logout(HttpServletRequest req) &#123;</span><br><span class="line">	HttpSession session = req.getSession();</span><br><span class="line">	if (session != null) &#123;</span><br><span class="line">		session.invalidate(); // 触发LogoutListener</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;redirect:/&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LogoutListener implements HttpSessionListener &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void sessionCreated(HttpSessionEvent event) &#123;&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void sessionDestroyed(HttpSessionEvent event) &#123;</span><br><span class="line">		// 通过httpClient向所有注册系统发送注销请求</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
