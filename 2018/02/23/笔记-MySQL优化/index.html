<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-MySQL优化 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-MySQL优化"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-MySQL优化</h2>
				
				<div>
					<span class="post-time">2018-02-23 12:55</span>
				</div>	
				
				<div class="article-content">
				<h4 id="来源于网络"><a href="#来源于网络" class="headerlink" title="来源于网络"></a>来源于网络</h4><p>当访问某张表的时候，首先必须获取该表的锁，如果有写入操作到达，那么写入者一直等待读取者完成操作（查询开始之后就不能中断）。</p>
<p>当读取者完成对表的操作的时候，锁就会被解除。</p>
<p>如果写入者正在等待的时候，另一个读取操作到达了，该读取操作也会被阻塞，因为默认的调度策略是写入者优先于读取者。</p>
<p>当第一个读取者完成操作并解放锁后，写入者开始操作，并且直到该写入者完成操作，第二个读取者才开始操作。</p>
<p>通过<code>LOCK TABLES</code>和<code>UNLOCK TABLES</code>语句可以显式地获取或释放锁。</p>
<p>获取的锁的类型依赖于客户端是写入还是读取操作。</p>
<p>对某张表进行写入操作的客户端必须拥有独占的（排他的）访问权的锁。</p>
<p>操作在进行的过程中，该数据表处于不一致的状态，因为数据记录在删除、添加或修改的时候，数据表上的索引也可能需要更新以相互匹配。</p>
<p>允许两个客户端同时写入一张数据表是不利的，因为这样的操作会很快使数据表中的信息成为一堆无用的垃圾。</p>
<p>同时允许客户端读取变化之中的数据表也不正确，因为正在读取的位置中的数据可能正在变化（修改），读取的结果可能并不是真实的。</p>
<p>因此对某张表执行读取操作的客户端也必须获取一个锁，防止在读取的过程中，其它的客户端写入或改变表。</p>
<p>但是这个锁不需要独占的访问权。</p>
<p>因为读取操作不会改变数据，因此没有理由让某个读取者阻止其它的读取者访问这张表。</p>
<p>故读取锁可允许其它的客户端在同一时刻读取这张表。</p>
<p>虽然通过锁机制，可以实现多线程同时对某个表进行操作，但当某个线程作更新操作时，首先要获得独占的访问权。</p>
<p>在更新的过程中，所有其它想要访问这个表的线程必须要等到其更新完成为止。</p>
<p>此时就会导致锁竞争的问题，从而导致用户等待时间的延长。</p>
<p>要提高MySQL的更新/插入效率，应首先考虑降低锁的竞争，减少写操作的等待时间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> score (change_type, score, user_id) <span class="keyword">VALUES</span> (<span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>批量插入数据的时候，会出现性能问题，同时插入多条就是一种优化。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">INSERT</span> <span class="selector-tag">INTO</span> <span class="selector-tag">score</span> (change_type, score, user_id) <span class="selector-tag">VALUES</span> </div><div class="line">(<span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>),</div><div class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>),</div><div class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>考虑使用<code>replace</code>语句代替<code>insert</code>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 删除全部</span></div><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> gag; </div><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> gag <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> gag;</div></pre></td></tr></table></figure>
<p><code>truncate table</code>速度要更快一些，但<code>truncate</code>删除后不记录mysql日志，不可以恢复数据。</p>
<ul>
<li><p>如果没有外键关联，innodb执行<code>truncate</code>是先<code>drop table</code>(原始表),再建一个跟原始表一样空表,远远快于<code>delete</code>逐条删除行记录。</p>
<ul>
<li><code>truncate table</code>删除表后，optimize table尤其重要，特别是大数据数据库，表空间可以得到释放！</li>
</ul>
</li>
<li><p>表有外键关联，<code>truncate table</code>删除表数据为逐行删除，如果外键指定级联删除<code>delete cascade</code>，关联的子表也会会被删除所有表数据。</p>
<ul>
<li>如果外键未指定级联<code>cascde</code>,<code>truncate table</code>逐行删除数据，如果是父行关联子表行数据，将会报错。</li>
</ul>
</li>
<li><p><code>auto_increment</code>计数器在<code>truncate table</code>后会重置为<code>0</code>，与是否有外键关联没有关系。</p>
</li>
</ul>
<p>一个大的<code>DELETE</code>或<code>INSERT</code>操作，要非常小心，因为这两个操作是会锁表的。</p>
<ul>
<li><p>删除数据的速度和创建的索引数量是成正比的。</p>
</li>
<li><p>在超大型数据库中，删除时处理好索引关系非常重要。</p>
</li>
<li><p>推荐的折中方法：在删除数据之前删除这那几个索引，然后删除其中无用数据，删除完成后重新创建索引。</p>
</li>
</ul>
<p>根据应用情况可以使用<code>replace</code>语句代替<code>insert/update</code>语句。</p>
<p>例如：如果一个表在一个字段上建立了唯一索引，当向这个表中使用已经存在的键值插入一条记录，将会抛出一个主键冲突的错误。</p>
<p>如果想用新记录的值来覆盖原来的记录值时，就可以使用<code>REPLAC</code>语句。</p>
<p>如果记录不重复（或往表里插新记录），<code>REPLACE</code>功能与<code>INSERT</code>一样，如果存在重复记录，<code>REPLACE</code>就使用新记录的值来替换原来的记录值。</p>
<p><code>REPLACE</code>的最大好处就是可以将<code>DELETE</code>和<code>INSERT</code>合二为一，形成一个原子操作。</p>
<p>这样就可以不必考虑同时使用<code>DELETE</code>和<code>INSERT</code>时添加事务等复杂操作了。</p>
<p>使用<code>REPLACE</code>时，表中必须有唯一有一个<code>PRIMARY KEY</code>或<code>UNIQUE</code>索引，否则，<code>REPLACE</code>语句没有意义。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 与普通INSERT一样功能</span></div><div class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> score (change_type, score, user_id) <span class="keyword">VALUES</span> </div><div class="line">(<span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>),</div><div class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>),</div><div class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">-- 找到第一条记录，用后面的值进行替换</span></div><div class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> score (<span class="keyword">id</span>, change_type, score, user_id) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p><code>replace(object, search, replace)</code>，把<code>object</code>中出现<code>search</code>的全部替换为<code>replace</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 用法一：不修改数据，而只是单纯做局部替换数据返还而已。</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">REPLACE</span>(<span class="string">'喝茶'</span>, <span class="string">'茶'</span>, <span class="string">'喝'</span>)</div><div class="line"><span class="comment">-- 结果：喝喝</span></div><div class="line"></div><div class="line"><span class="comment">-- 用法二：修改表数据，根据change_type字段找到做任务的数据，用bb来替换</span></div><div class="line"><span class="keyword">UPDATE</span> score <span class="keyword">SET</span> change_type = <span class="keyword">REPLACE</span>(change_type, <span class="string">'做任务'</span>, <span class="string">'bb'</span>)</div></pre></td></tr></table></figure></p>
<p><code>UPDATE</code>和<code>REPLACE</code>的区别：</p>
<ul>
<li><p><code>UPDATE</code>在没有匹配记录时什么都不做，而<code>REPLACE</code>在有重复记录时更新，在没有重复记录时插入。</p>
</li>
<li><p><code>UPDATE</code>可以选择性地更新记录的一部分字段。而<code>REPLACE</code>在发现有重复记录时就将这条记录彻底删除，再插入新的记录。也就是说，将所有的字段都更新了。<br><code>REPLACE</code>更像<code>INSERT</code>与<code>DELETE</code>的结合。</p>
</li>
</ul>
<h4 id="一个复杂查询-or-多个简单查询"><a href="#一个复杂查询-or-多个简单查询" class="headerlink" title="一个复杂查询 or 多个简单查询"></a>一个复杂查询 or 多个简单查询</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * from <span class="built_in">tag</span> </div><div class="line"></div><div class="line">	<span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag_id = <span class="built_in">tag</span>.id</div><div class="line"></div><div class="line">		<span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id = post.id</div><div class="line"></div><div class="line"><span class="keyword">where</span> <span class="built_in">tag</span>.<span class="built_in">tag</span> = <span class="string">'mysql'</span></div></pre></td></tr></table></figure>
<p>可以分解成下面这些查询来代替：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag = <span class="string">'mysql'</span></div><div class="line"></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id = <span class="number">1234</span></div><div class="line"></div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post_id <span class="keyword">in</span> (<span class="number">123</span>, <span class="number">456</span>, <span class="number">567</span>, <span class="number">9098</span>, <span class="number">8904</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>让缓存的效率更高。</p>
</li>
<li><p>将查询分解后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</p>
</li>
<li><p>查询本身效率也可能会有所提升。</p>
</li>
<li><p>可以减少冗余记录的查询。</p>
</li>
<li><p>在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。</p>
</li>
<li><p>大多数的MySQL服务器都开启了查询缓存。</p>
</li>
<li><p>如果查询中有不确定数据，如<code>CURRENT_DATE()</code>和<code>NOW()</code>函数，查询完毕后则不会被缓存。</p>
</li>
</ul>
<p>不要轻易使用<code>select * from</code>，能明确多少数据就查多少个：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">select</span> <span class="selector-tag">d</span><span class="selector-class">.Good_ID</span> ,</div><div class="line">		<span class="selector-tag">d</span><span class="selector-class">.Classify_ID</span>,</div><div class="line">		<span class="selector-tag">d</span><span class="selector-class">.Good_Name</span></div><div class="line">		<span class="selector-tag">from</span></div><div class="line">		<span class="selector-tag">Commodity_list</span> <span class="selector-tag">d</span>;</div></pre></td></tr></table></figure></p>
<p>使用分页语句：<code>limit start</code>,<code>count</code>或者条件<code>where</code>子句，有什么可限制的条件尽量加上。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span></div><div class="line">		d.Good_ID ,</div><div class="line">		d.Classify_ID,</div><div class="line">		d.Good_Name,</div><div class="line">		d.Monthsale_Num,</div><div class="line">		d.Store_Name,</div><div class="line">		d.Comment_Num,</div><div class="line">		d.Good_Brand,</div><div class="line">		d.Ishas_License,</div><div class="line">		<span class="keyword">ifnull</span>(d.Good_Hot, <span class="number">0</span>),</div><div class="line">		d.Good_Price,</div><div class="line">		d.Store_Add,</div><div class="line">		d.Store_Age,</div><div class="line">		d.Seller_Credit,</div><div class="line">		d.Classify_Description</div><div class="line">		<span class="keyword">from</span></div><div class="line">		Commodity_list d</div><div class="line">		<span class="keyword">where</span> Classify_ID = <span class="number">23</span></div><div class="line">		<span class="keyword">limit</span> <span class="number">1</span>,<span class="number">10000</span>;</div></pre></td></tr></table></figure>
<p><code>limit</code>语句的查询时间与起始记录的位置成正比，对记录很多的表并不适合直接使用。</p>
<ul>
<li>偏移量越大，查询越费时</li>
<li>每条数据的实际存储长度不一样（所以必须要依次遍历，不能直接跳过前面的一部分）</li>
<li>哪怕是每条数据存储长度一样，如果之前有过delete操作，那索引上的排列就有gap</li>
<li>所以数据不是定长存储，不能像数组那样用index来访问，只能依次遍历，就导致偏移量越大查询越费时</li>
</ul>
<p>对<code>limit</code>的使用优化：利用自增主键，避免<code>offset</code>的使用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *</div><div class="line">		<span class="keyword">from</span></div><div class="line">		score </div><div class="line">		<span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">0</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>;</div><div class="line"><span class="keyword">select</span> *</div><div class="line">		<span class="keyword">from</span></div><div class="line">		score </div><div class="line">		<span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">10000</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>;</div><div class="line"><span class="keyword">select</span> *</div><div class="line">		<span class="keyword">from</span></div><div class="line">		score </div><div class="line">		<span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">20000</span> <span class="keyword">LIMIT</span> <span class="number">10000</span>;</div></pre></td></tr></table></figure></p>
<p>如果是有序的查询，可使用<code>ORDER BY</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *</div><div class="line">		<span class="keyword">from</span></div><div class="line">		score </div><div class="line">		<span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;<span class="number">0</span></div><div class="line">		<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">ASC</span></div><div class="line">		<span class="keyword">LIMIT</span> <span class="number">10000</span>;</div></pre></td></tr></table></figure></p>
<p>如果有很多<code>JOIN</code>查询，应该确认两个表中<code>Join</code>的字段是被建过索引的。</p>
<p>用来<code>Join</code>的字段，应该是相同的类型的：如果把<code>DECIMAL</code>字段和一个<code>INT</code>字段<code>Join</code>在一起，MySQL就无法使用它们的索引。</p>
<p>对于那些<code>STRING</code>类型，还需要有相同的字符集才行。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> company_name <span class="keyword">FROM</span> <span class="keyword">users</span></div><div class="line">	<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> companies <span class="keyword">ON</span> (users.state = companies.state)</div><div class="line">	<span class="keyword">WHERE</span> users.id = $user_id<span class="string">"</span></div><div class="line">-- 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集</div></pre></td></tr></table></figure></p>
<h4 id="超大型数据不要写子查询，使用连接（JOIN）去替换"><a href="#超大型数据不要写子查询，使用连接（JOIN）去替换" class="headerlink" title="超大型数据不要写子查询，使用连接（JOIN）去替换"></a>超大型数据不要写子查询，使用连接（JOIN）去替换</h4><ul>
<li><p>在大型的数据处理中，子查询是非常常见的，特别是在查询出来的数据需要进一步处理的情况，无论是可读性还是效率上，这时候的子查都是更优。</p>
</li>
<li><p>在一些特定的场景，可以直接从数据库读取就可以的，比如一个表<code>join</code>自己的效率必然比放一个子查在<code>where</code>中快得多。</p>
</li>
<li><p>可参见拉黑表，好友表（双方互相喜欢才是好友的表），在查自己的好友列表的时候，或者拉黑列表中。</p>
</li>
</ul>
<h4 id="创建索引："><a href="#创建索引：" class="headerlink" title="创建索引："></a>创建索引：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`black_list`</span> (</div><div class="line">	<span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">	<span class="string">`black_user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">	<span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">	PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">	<span class="keyword">INDEX</span> indexName (black_user_id(<span class="keyword">length</span>))</div><div class="line">);</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</span></div><div class="line"></div><div class="line"><span class="comment">-- 普通索引，索引值可出现多次</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (column_list)</div><div class="line"></div><div class="line"><span class="comment">-- 这条语句创建的索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list)</div><div class="line"></div><div class="line"><span class="comment">-- 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (column_list)</div><div class="line"></div><div class="line"><span class="comment">-- 该语句指定了索引为FULLTEXT，用于全文索引</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT index_name(olumu_name);</div><div class="line"></div><div class="line"><span class="comment">-- 增加商品分类的索引</span></div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> commodity_list <span class="keyword">ADD</span> <span class="keyword">INDEX</span> classify_index (Classify_Description)</div><div class="line"></div><div class="line"><span class="comment">-- 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔</span></div></pre></td></tr></table></figure>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-- 使用<span class="keyword">CREATE</span> <span class="keyword">INDEX</span>命令创建</div><div class="line">-- <span class="keyword">CREATE</span> <span class="keyword">INDEX</span>可对表增加普通索引或UNIQUE索引</div><div class="line">-- 不能用<span class="keyword">CREATE</span> <span class="keyword">INDEX</span>语句创建PRIMARY KEY索引</div><div class="line"> </div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</div><div class="line"><span class="keyword">CREATE</span> UNIQUE <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column_list)</div><div class="line"> </div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> classify_index  <span class="keyword">ON</span> commodity_list (Classify_Description)</div></pre></td></tr></table></figure>
<h4 id="删除索引："><a href="#删除索引：" class="headerlink" title="删除索引："></a>删除索引：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">-- 删除索引可以使用ALTER TABLE或DROP INDEX语句来实现</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> [table_name];</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [table_name] <span class="keyword">drop</span> <span class="keyword">index</span> [index_name];</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> [table_name] <span class="keyword">drop</span> primary <span class="keyword">key</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 在前面的两条语句中，都删除了table_name中的索引index_name</span></div><div class="line"><span class="comment">-- 最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此不需要指定索引名</span></div><div class="line"><span class="comment">-- 如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引</span></div><div class="line"><span class="comment">-- 如果从表中删除某列，则索引会受影响</span></div><div class="line"><span class="comment">-- 对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除</span></div><div class="line"><span class="comment">-- 如果删除组成索引的所有列，则整个索引将被删除</span></div><div class="line"></div><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span> classify_index <span class="keyword">on</span> commodity_list ;</div></pre></td></tr></table></figure>
<h4 id="查看索引："><a href="#查看索引：" class="headerlink" title="查看索引："></a>查看索引：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> [table_name];</div><div class="line"><span class="keyword">show</span> <span class="keyword">keys</span> <span class="keyword">from</span> [table_name];</div></pre></td></tr></table></figure>
<h4 id="索引建立原则："><a href="#索引建立原则：" class="headerlink" title="索引建立原则："></a>索引建立原则：</h4><ul>
<li><p>最左前缀匹配原则，一直向右匹配直到遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>如果建立<code>(a, b, c, d)</code>顺序的索引，d是用不到索引的，如果建立<code>(a, b, d, c)</code>的索引则都可以用到，a, b, d的顺序可以任意调整。</p>
</li>
<li><p><code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a, b, c)</code>索引可以任意顺序。</p>
</li>
<li><p>尽量选择区分度高的列作为索引，区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，一般需要<code>join</code>的字段要求是0.1以上，即平均1条扫描10条记录。</p>
</li>
<li><p>索引列不能参与计算，保持列“干净”，比如<code>from_unixtime(create_time) = &#39;2014-05-29&#39;</code>就不能使用到索引，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。语句应该写成<code>create_time = unix_timestamp(&#39;2014-05-29&#39;)</code>。</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，只需修改原来的索引即可。</p>
</li>
<li><p>定义有外键的数据列一定要建立索引。</p>
</li>
<li><p>对于查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
</li>
<li><p>对于定义为<code>text</code>、<code>image</code>和<code>bit</code>的数据类型的列不要建立索引。</p>
</li>
<li><p>对于经常存取的列避免建立索引。</p>
</li>
</ul>
<h4 id="索引注意点："><a href="#索引注意点：" class="headerlink" title="索引注意点："></a>索引注意点：</h4><ul>
<li><p>一般说来，索引应建立在那些将用于<code>JOIN</code>,<code>WHERE</code>判断和<code>ORDER BY</code>排序的字段上。</p>
</li>
<li><p>尽量不要对数据库中某个含有大量重复的值的字段建立索引。</p>
</li>
<li><p>对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况。</p>
</li>
<li><p>避免在<code>where</code>子句中对字段进行<code>null</code>值判断，否则将导致引擎放弃使用索引而进行全表扫描。如：<br><code>select id from t where num is null</code></p>
</li>
<li><p>最好不要给数据库留NULL，尽可能的使用<code>NOT NULL</code>填充数据库。</p>
</li>
<li><p>不要以为<code>NULL</code>不需要空间，如：<code>char(100)</code>，在字段建立时，空间就固定了，不管是否插入值都是占用100个字符的空间的，如果是<code>varchar</code>这样的变长字段，<code>null</code>不占用空间。</p>
</li>
<li><p>可以在num上设置默认值0，确保表中num列没有<code>null</code>值，然后查询。</p>
</li>
<li><p>避免在<code>where</code>子句中使用<code>!=</code>或<code>&lt;</code> <code>&gt;</code>操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>避免在<code>where</code>子句中使用<code>or</code>来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</p>
<ul>
<li>如：<code>select id from t where num = 10 or Name = &#39;xxx&#39;</code></li>
</ul>
</li>
<li><p>可以这样查询，充分利用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">10</span></div><div class="line"><span class="keyword">union</span> all</div><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">Name</span> = <span class="string">'xxx'</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>in</code>和<code>not in</code>也要慎用，否则会导致全表扫描，对于连续的数值，能用<code>between</code>就不要用<code>in</code>。</p>
</li>
<li><p>很多时候用<code>exists</code>代替<code>in</code>是一个好的选择：</p>
<ul>
<li><code>select num from a where num in(select num from b)</code>-&gt;<code>select num from a where exists(select 1 from b where num=a.num)</code>。</li>
</ul>
</li>
<li><p>下面的模糊查询也将导致全表扫描：<code>select id from t where name like &#39;%abc%&#39;</code></p>
</li>
<li><p>不鼓励使用<code>like</code>。<code>like &#39;%aaa%&#39;</code>不会使用索引，而<code>like &#39;aaa%&#39;</code>可以使用索引。</p>
</li>
<li><p><code>like %keyword</code>索引失效，使用全表扫描。</p>
</li>
<li><p>可以通过翻转函数+like前模糊查询+建立翻转函数索引=走翻转函数索引，不走全表扫描：</p>
<ul>
<li><code>like keyword%</code>索引有效。</li>
<li><code>like %keyword%</code>索引失效，也无法使用反向索引。</li>
</ul>
</li>
<li><p>若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>如果在<code>where</code>子句中使用参数，也会导致全表扫描：</p>
<ul>
<li><code>select id from t where num = @num</code>。</li>
<li>SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时，它必须在编译时进行选择。</li>
<li>如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。</li>
</ul>
</li>
<li><p>可以改为强制查询使用索引：</p>
<ul>
<li><code>select id from t with(index(索引名)) where num = @num</code></li>
</ul>
</li>
<li><p>避免在<code>where</code>子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<ul>
<li>如：<code>select id from t where num / 2 = 100</code>应改为<code>select id from t where num = 100 * 2</code></li>
</ul>
</li>
<li><p>避免在<code>where</code>子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描：</p>
<ul>
<li><code>select id from t where substring(name, 1, 3) = &#39;abc&#39;</code>应改为:<code>select id from t where name like &#39;abc%&#39;</code></li>
</ul>
</li>
<li><p>不要在<code>where</code>子句中的<code>=</code>左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引（多列索引），那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的<code>select</code>的效率，但同时也降低了<code>insert</code>及<code>update</code>的效率，因为<code>insert</code>或<code>update</code>时有可能会重建索引。</p>
<ul>
<li>一个表的索引数最好不要超过6个。</li>
</ul>
</li>
<li><p>MySQL查询只使用一个索引，因此如果<code>where</code>子句中已经使用了索引的话，那么<code>order by</code>中的列是不会使用索引的。</p>
<ul>
<li>因此数据库默认排序可以符合要求的情况下不要使用排序操作；</li>
<li>尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li>
</ul>
</li>
</ul>
<h4 id="类型选取建议"><a href="#类型选取建议" class="headerlink" title="类型选取建议"></a>类型选取建议</h4><h4 id="数字类型："><a href="#数字类型：" class="headerlink" title="数字类型："></a>数字类型：</h4><ul>
<li>不要使用浮点数<code>DOUBLE</code>，会存在精确性的问题，对货币等对精度敏感的数据，应该用定点数表示或存储。</li>
<li>固定精度的小数，也不建议使用<code>DECIMAL</code>，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。</li>
<li>对于整数的存储，在数据量较大的情况下，建议区分开<code>TINYINT</code>/<code>INT</code>/<code>BIGINT</code>的选择，确定不会使用负数的字段，建议添加<code>unsigned</code>定义。</li>
<li>在数据量较大时，建议把实数类型转为整数类型，如：要存放财务数据精确到万分之一，则可以把所有金额乘以一百万、然后存在<code>BIGINT</code>下。<ul>
<li>浮点不精确；</li>
<li>定点计算代价昂贵。</li>
</ul>
</li>
</ul>
<h4 id="字符类型："><a href="#字符类型：" class="headerlink" title="字符类型："></a>字符类型：</h4><ul>
<li>尽量不要使用<code>TEXT</code>数据类型，定长字段，建议使用<code>CHAR</code>类型，不定长字段用<code>VARCHAR</code>，且设定适当的最大长度，因为不同的长度范围，MySQL也会有不一样的存储处理。</li>
<li><code>char</code>会删除字符串尾部的空格，<code>varchar</code>不会，<code>varchar</code>向前补1-2字节；</li>
<li><code>binary</code>类似于<code>char</code>，只能保存二进制字符串。</li>
<li><code>char</code>是固定长度，所以速度比<code>varchar</code>快得多，但缺点是浪费存储空间，不能在行尾保存空格。</li>
<li><code>enum</code>类型忽略大小写。</li>
<li><code>text</code>与<code>blob</code>区别：<code>blob</code>保存二进制数据（如照片等）；<code>text</code>保存字符数据（如文章，日记等），有字符集。<code>text</code>和<code>blob</code>不能有默认值。</li>
<li><code>blob</code>与<code>text</code>在执行了大量删除操作时候，有性能问题（产生大量的空洞），为提高性能建议定期<code>optimize table</code>对这类表进行碎片整理。</li>
</ul>
<h4 id="时间类型："><a href="#时间类型：" class="headerlink" title="时间类型："></a>时间类型：</h4><ul>
<li>尽量使用<code>TIMESTAMP</code>类型，因为其存储空间只需要<code>DATETIME</code>类型的一半。对于只需要精确到某一天的数据类型，建议使用<code>DATE</code>类型。</li>
<li>根据实际需要选择能够满足应用的最小存储日期类型。</li>
<li><code>timestamp</code>，日期类型中只有它能够和实际时区相对应。</li>
</ul>
<h4 id="ENUM-amp-SET："><a href="#ENUM-amp-SET：" class="headerlink" title="ENUM &amp; SET："></a>ENUM &amp; SET：</h4><ul>
<li>对于状态字段，可以尝试使用<code>ENUM</code>来存放，因为可以极大的降低存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重建表数据。</li>
<li>如果是存放可预先定义的属性数据，可以尝试使用SET类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。</li>
</ul>
<h4 id="主键和外键的必要性"><a href="#主键和外键的必要性" class="headerlink" title="主键和外键的必要性"></a>主键和外键的必要性</h4><ul>
<li><p>主键是实体的抽象，主键与外键的配对，表示实体之间的连接。</p>
</li>
<li><p>很多表也不一定需要主键，但是对于数据量大，查询频繁的数据库表，一定要有主键，主键可以增加效率、防止重复等优点。</p>
</li>
<li><p>一般选择总的长度小的键，小的键的比较速度快，同时小的键可以使主键的B树结构的层次更少。</p>
</li>
<li><p>对于组合主键来说，不同的字段次序的主键的性能差别可能会很大，一般应该选择重复率低、单独或者组合查询可能性大的字段放在前面。</p>
</li>
<li><p>外键作为数据库对象，是最高效的一致性维护方法。</p>
</li>
<li><p>数据库的一致性要求，依次可以用外键、CHECK约束、规则约束、触发器、客户端程序，一般认为，离数据越近的方法效率越高。</p>
</li>
<li><p>谨慎使用级联删除和级联更新。</p>
</li>
<li><p>从性能看级联删除和级联更新是比其他方法更高效的方法。</p>
</li>
</ul>
<h4 id="实际项目中的主外键取舍设计："><a href="#实际项目中的主外键取舍设计：" class="headerlink" title="实际项目中的主外键取舍设计："></a>实际项目中的主外键取舍设计：</h4><ul>
<li>边缘模块指的是小功能不常用需求很少再改的模块；</li>
<li>中心模块是指关联的东西太多的模块、是很多表的主表；</li>
<li>物理键指的是在表建立主外键关联，逻辑主外键指的是利用字段去实现逻辑主外键关联；</li>
<li><p>热点模块指的是需求经常要改的模块。</p>
</li>
<li><p>大型系统：</p>
<ul>
<li>性能要求不高，安全要求高的模块，推荐使用物理主外键关联；</li>
<li>性能要求高、安全自己控制的模块，推荐不用物理外键；</li>
<li>中心模块和其他模块的联系，推荐使用物理主外键；</li>
<li>热点模块，必须使用逻辑主外键；</li>
<li>边缘模块，推荐使用物理主外键。</li>
</ul>
</li>
</ul>
<h4 id="传说中的‘三少原则’："><a href="#传说中的‘三少原则’：" class="headerlink" title="传说中的‘三少原则’："></a>传说中的‘三少原则’：</h4><ul>
<li>数据库的表越少越好</li>
<li>表的字段越少越好</li>
<li>字段中的组合主键、组合索引越少越好</li>
</ul>
<p>实际上，为了减少单表查询压力，会去分表，避免一个超级表的诞生。</p>
<ul>
<li>如果某个表的记录太多，例如超过一千万条，则要水平分割，以该表主键的某个值为界线，将该表的记录水平分割为两个表。</li>
<li>如果某个表的字段太多，例如超过八十个，则垂直分割，将原来的一个表分解为两个表</li>
</ul>
<h4 id="分表分区"><a href="#分表分区" class="headerlink" title="分表分区"></a>分表分区</h4><p>大表是指存储了百万级乃至千万级条记录的表。</p>
<p>这样的表过于庞大，导致数据库在查询和插入的时候耗时太长，性能低下，如果涉及联合查询的情况，性能会更加糟糕。</p>
<p>分表和表分区的目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。</p>
<h4 id="垂直切分："><a href="#垂直切分：" class="headerlink" title="垂直切分："></a>垂直切分：</h4><p>把主键和一些数据表的列放在一个表中，然后把主键和另一些数据表的列放在一个表中。</p>
<p>如果一个表的某些列常用，另一些不常用，则可以采用垂直拆分。</p>
<p>垂直拆分可以使数据行变小，一个数据块(Block)就可以存放更多的数据，在查询时候可以减少I/O次数。</p>
<p>其缺点是需要管理冗余列(主键)，查询所有数据时候需要<code>join</code>查找。</p>
<h4 id="水平拆分："><a href="#水平拆分：" class="headerlink" title="水平拆分："></a>水平拆分：</h4><p>根据列的范围值进行合理切分，放在多个独立的表或分区中。</p>
<p>适用场景：表中的数据是独立的，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另一些数据不常用。</p>
<p>一种选择是根据key的范围来做切分，譬如ID 为 1-10000的放到表A上，ID 为10000~20000的放到表B。</p>
<p>另一种是根据某一字段值来划分，譬如根据用户名的首字母，如果是A-D，就属于表A，E-H就属于表B。</p>
<p>这样做也存在不均衡性，当某个范围超出了单点所能承受的范围就需要继续切分。</p>
<p>还有按日期切分等等。</p>
<h4 id="散列库表（基于hash算法的切分）："><a href="#散列库表（基于hash算法的切分）：" class="headerlink" title="散列库表（基于hash算法的切分）："></a>散列库表（基于hash算法的切分）：</h4><p>表散列与水平分割相似，但没有水平分割那样的明显分割界限，采用Hash算法把数据分散到各个分表中，这样IO更加均衡。</p>
<p>这种方法能够平均地来分配数据，但是伴随着数据量的增大，需要进行扩展的时候，这种方式无法做到在线扩容。</p>
<p>每增加节点的时候，就需要对hash 算法重新运算。</p>
<p>按照业务或者功能模块将数据库进行分离，不同的模块对应不同的数据库或者表，再按照一定的策略对某个页面或者功能进行更小的数据库散列，比如用户表，按照用户ID进行表散列，散列128张表，则应就能够低成本的提升系统的性能并且有很好的扩展性。</p>
<h4 id="分区和分表。"><a href="#分区和分表。" class="headerlink" title="分区和分表。"></a>分区和分表。</h4><p>分区和分表相似，都是按照规则分解表。</p>
<p>分表将大表分解为若干个独立的实体表，而分区是将数据分段划分在多个位置存放，可以是同一块磁盘也可以在不同的机器。</p>
<p>分区后，表面上还是一张表，但数据散列到多个位置了。</p>
<p>分表是将一个大表按照一定的规则分解成多张具有独立存储空间的实体表，可以称为子表，每个表都对应三个文件，<code>MYD</code>数据文件，<code>.MYI</code>索引文件，<code>.frm</code>表结构文件。</p>
<p>这些子表可以分布在同一块磁盘上，也可以在不同的机器上。</p>
<p>读写的时候根据事先定义好的规则得到对应的子表名，然后去操作它。</p>
<h4 id="分表和分区联系："><a href="#分表和分区联系：" class="headerlink" title="分表和分区联系："></a>分表和分区联系：</h4><ul>
<li>都能提高性高，在高并发状态下都有一个良好的表现。</li>
<li>分表和分区可以相互配合的，对于那些大访问量，并且表数据比较多的表，可以采取分表和分区结合的方式（如果<code>merge</code>这种分表方式，不能和分区配合的话，可以用其他的分表试），访问量不大，但是表数据很多的表，我们可以采取分区的方式等。</li>
<li>分表技术是比较麻烦的，需要手动去创建子表，服务端读写时候需要计算子表名。采用<code>merge</code>好一些，但也要创建子表和配置子表间的<code>union</code>关系。</li>
<li>表分区相对于分表，操作方便，不需要创建子表。</li>
</ul>
<h4 id="字段设计原则："><a href="#字段设计原则：" class="headerlink" title="字段设计原则："></a>字段设计原则：</h4><ul>
<li>数据类型尽量用数字型，数字型的比较比字符型的快很多。</li>
<li>数据类型尽量小。</li>
<li>尽量不要允许<code>NULL</code>，除非必要，可以用<code>NOT NULL</code> + <code>DEFAULT</code>代替。</li>
<li>少用<code>TEXT</code>和<code>IMAGE</code>，二进制字段的读写是比较慢的，大部分情况下最好不用。</li>
<li>自增字段要慎用，不利于数据迁移。</li>
</ul>
<h4 id="一对一："><a href="#一对一：" class="headerlink" title="一对一："></a>一对一：</h4><ul>
<li>一对一主键关联：两个表的主键必须完全一致，通过两个表的主键建立关联关系。</li>
<li>一对一外键关联：以外键关联起来的一个表。</li>
</ul>
<h4 id="多对多："><a href="#多对多：" class="headerlink" title="多对多："></a>多对多：</h4><p>在RDBMS中，必须使用中间表来表示多对多的关系。</p>
<p>中间表可以分成两种，一种是纯粹表示关系的中间表，一种是表示中间实体的中间表。</p>
<p>纯粹表示关系的中间表很简单，只需要两列：AID和BID，AID以外键关联到A表的主键，BID以外键关联到B表的主键，然后这两个列组成联合主键。</p>
<p>这个中间表纯粹是表示多对多关系而存在，在业务上不会有对应的实体与之对应。</p>
<p>比如学生和课程的关系，只需要知道哪些学生上哪些课，哪些课有哪些学生选，不需要有更多的信息的情况下，可以建立“学生课程”中间表，里面只有学生ID和课程ID两个字段。</p>
<p>中间实体是在纯粹的中间关系表的基础上，加上了更多的属性，从而形成了一个新的实体。</p>
<p>比如学生和课程的关系，如果需要记录学生选课的时间、学生选择这门课程后的考试成绩，那么就像建立一个“选课”实体，该实体具有如下属性：</p>
<ul>
<li>选课ID，主键</li>
<li>学生ID，与学生表做外键关联</li>
<li>课程ID，与课程表做外键关联</li>
<li>选课时间，DateTime类型</li>
<li>考试成绩，记录选修该课程后考试的最终成绩</li>
</ul>
<h4 id="外键与索引："><a href="#外键与索引：" class="headerlink" title="外键与索引："></a>外键与索引：</h4><p>外键是约束，与索引不一样，大多数情况下，建立外键时，都会在外键列上建立对应的索引。</p>
<p>外键的存在会在每一次数据插入、修改时进行约束检查，如果不满足外键约束，则禁止数据的插入或修改，在数据量特别大的情况下，每一次约束检查必然导致性能的下降。</p>
<p>索引也有类似的问题，索引如果建多了，在插入删除修改数据时也要去维护对应的索引，所以索引的存在也会导致数据操作变慢。</p>
<p>不过外键与索引的优点不同，外键只是保证数据的一致性，并不能给系统性能带来任何好处。</p>
<p>而索引的目的是为了检索数据更快，维护数据时导致的索引数据的变更，对性能的影响不会像外键那样。</p>
<p>出于性能的考虑，如果系统完全由我们开发的程序使用，而不需要提供数据库给其他应用系统写入数据，而且对性能要求较高，可以考虑在生产环境中不使用外键，只需要建立能够提高性能的索引。</p>
<p>由于整个数据库的操作都是由我们开发的程序来完成的，程序可以在开发过程中做好各方面的一致性检查，保证操作的数据是满足外键约束的，而不需要真正的存在这样一个外键约束。</p>
<p>怎么做到这一点呢，首先，在建立数据库时有多个脚本，包括创建表、创建初始化数据、创建索引、创建外键等，在开发和测试环境中，都把这些脚本运行了，以使开发测试环境中的数据库是完整的，经过大量测试保证应用程序能够维护数据之间的约束的情况下，在生产时，并不需要运行创建外键这个脚本文件，只需要创建表、初始化数据、创建索引等即可。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2018 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
