<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
				<script>var timeStart = new Date();</script>
		
		<title>[笔记]-TCP | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-TCP"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-TCP</h2>
				
				<div>
					<span class="post-time">2018-07-19 19:55:17</span>
				</div>	
				
				<div class="article-content">
				<p><strong>参考：</strong><br><a href="http://www.52im.net/thread-1003-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-1003-1-1.html</a><br><a href="http://www.52im.net/thread-1103-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-1103-1-1.html</a><br><a href="http://www.52im.net/thread-258-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-258-1-1.html</a><br><a href="http://www.52im.net/thread-1095-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-1095-1-1.html</a><br><a href="http://www.52im.net/thread-1107-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-1107-1-1.html</a><br><a href="http://www.52im.net/thread-513-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-513-1-1.html</a><br><a href="http://www.52im.net/thread-275-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-275-1-1.html</a><br><a href="http://www.52im.net/thread-1729-1-1.html" target="_blank" rel="external">http://www.52im.net/thread-1729-1-1.html</a><br><a href="http://www.cnblogs.com/doit8791/p/8714488.html" target="_blank" rel="external">http://www.cnblogs.com/doit8791/p/8714488.html</a></p>
<p> <img src="/imgs/tcp_shaking.png" alt="tcp shaking by huangzhike"></p>
<p><strong>三次握手</strong>：</p>
<p>前两次握手为了确认服务端能正常收到客户端的请求并愿意应答，后两次握手是为了确认客户端能正常收到服务端的请求并愿意应答。</p>
<p>通信的双方要互相通知对方自己的初始化的<code>Sequence Number（ISN：Inital Sequence Number）</code>，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p>
<p><strong>四次挥手</strong>：</p>
<p>因为TCP是全双工（双向数据传输）协议，前两次挥手表示客户端停止发送数据并得到服务端响应，此时可以从服务端单向发数据到客户端，后两次挥手表示服务端停止发送数据并得到客户端的响应。</p>
<p>此时客户端等待两个MSL，避免因为网络原因，它的应答信息服务端没有收到，服务端在超时后会再次发送停止发送数据请求，客户端再次发送应答确认信息。</p>
<p>TCP是全双工的，发送方和接收方都需要<code>Fin</code>和<code>Ack</code>，只不过，有一方是被动的，所以看上去就成了4次挥手。</p>
<p>如果两边同时断连接，那就会就进入到<code>CLOSING</code>状态，然后到达<code>TIME_WAIT</code>状态。</p>
<p>如果Server在收到Client的<code>FIN</code>包后，再也没数据发送给Client了，那么对Client的<code>ACK</code>包和Server自己的<code>FIN</code>包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了，主动关闭方就会从<code>FIN_WAIT_1</code>状态直接进入到<code>TIME_WAIT</code>状态，跳过了<code>FIN_WAIT_2</code>状态。</p>
<p>TCP主动关闭连接的那一方会最后进入<code>TIME_WAIT</code>，是否主动关闭是由<code>FIN</code>包的先后决定的，就是在自己没收到对端Peer的<code>FIN</code>包之前自己发出了<code>FIN</code>包，那么自己就是主动关闭连接的那一方。</p>
<p>据TCP协议规范，不对<code>ACK</code>进行<code>ACK</code>，如果主动关闭方不进入<code>TIME_WAIT</code>，那么主动关闭方在发送完<code>ACK</code>就走了的话，如果最后发送的<code>ACK</code>在路由过程中丢掉了，最后没能到被动关闭方，这个时候被动关闭方没收到自己<code>FIN</code>的<code>ACK</code>就不能关闭连接，接着被动关闭方会超时重发<code>FIN</code>包，但是这个时候已经没有对端会给该<code>FIN</code>回<code>ACK</code>，被动关闭方就无法正常关闭连接了，所以主动关闭方需要进入<code>TIME_WAIT</code>以便能够重发丢掉的被动关闭方<code>FIN</code>的<code>ACK</code>。</p>
<hr>
<p><strong>关于建连接时SYN超时</strong>：</p>
<p>如果server端接到了clien发的<code>SYN</code>后回了<code>SYN-ACK</code>后client掉线了，server端没有收到client回来的<code>ACK</code>，那么，这个连接处于一个中间状态，即没成功，也没失败。</p>
<p>如果server端在一定时间内没有收到的TCP会重发<code>SYN-ACK</code>。</p>
<p>在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p>
<p><strong>关于SYN Flood攻击</strong>：</p>
<p>一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个<code>SYN</code>后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的SYN连接的队列耗尽，让正常的连接请求不能处理。</p>
<p>Linux下给了一个叫<code>tcp_syncookies</code>的参数来应对，当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p>
<p>请别用<code>tcp_syncookies</code>来处理正常的大负载的连接的情况。对于正常的请求，应该调整三个TCP参数：</p>
<ul>
<li><code>tcp_synack_retries</code>: 减少重试次数；</li>
<li><code>tcp_max_syn_backlog</code>: 增大SYN连接数；</li>
<li><code>tcp_abort_on_overflow</code>: 处理不过来直接拒绝连接。</li>
</ul>
<p><strong>关于ISN的初始化</strong>：</p>
<p><code>ISN</code>是不能hard code的：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。</p>
<p><strong>关于 <code>MSL</code> 和 <code>TIME_WAIT</code></strong>：</p>
<p>在TCP的状态图中，从<code>TIME_WAIT</code>状态到<code>CLOSED</code>状态，有一个超时设置 <code>2*MSL</code>。<br>为什么要有<code>TIME_WAIT</code>？为什么不直接给转成<code>CLOSED</code>状态呢？</p>
<ul>
<li><code>TIME_WAIT</code>确保有足够的时间让对端收到了<code>ACK</code>，如果被动关闭的那方没有收到<code>Ack</code>，就会触发被动端重发<code>Fin</code>，一来一去正好2个<code>MSL</code>；</li>
<li>有足够的时间让这个连接不会跟后面的连接混在一起（有些路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。</li>
</ul>
<p> <img src="/imgs/tcp_segment.png" alt="tcp segment by huangzhike"></p>
<hr>
<ul>
<li><p>TCP的包是没有IP地址的，那是IP层上的事，但是有源端口和目标端口。一个TCP连接需要四个元组来表示是同一个连接（<code>src_ip</code>, <code>src_port</code>, <code>dst_ip</code>, <code>dst_port</code>）准确说是五元组，还有一个是协议，但这里只说TCP协议。</p>
</li>
<li><p>Sequence Number：包的序号，用来解决网络分包乱序（reordering）问题，第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。</p>
</li>
</ul>
<ul>
<li><p>Acknowledgement Number：ACK用于确认收到，用来解决不丢包的问题。</p>
</li>
<li><p>Window：滑动窗口（Sliding Window），用于解决流控。</p>
</li>
<li><p>TCP Flag ：包的类型，主要用于操控TCP的状态机。</p>
<ul>
<li>URG：紧急指针（urgent pointer）有效。</li>
<li><p>ACK：确认序号有效（不要将确认序号Ack与标志位中的ACK搞混了，确认方Ack=发起方Req+1，两端配对），ACK携带两个信息：</p>
<ul>
<li>期待要收到下一个数据包的编号；</li>
<li>接收方的接收窗口的剩余容量。<br>每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。</li>
</ul>
</li>
<li><p>PSH：接收方应该尽快将这个报文交给应用层。</p>
</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>FIN：释放一个连接。</li>
</ul>
</li>
</ul>
<hr>
<p>最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p>
<p>以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p>
<p>以太网是广播发送，同一个子网络的每台计算机都收到了这个包。</p>
<p>IP 协议：定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。</p>
<p>路由器就是基于 IP 协议，局域网之间要靠路由器连接。</p>
<p>IP 协议只是一个地址协议，并不保证数据包的完整。</p>
<p>如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。</p>
<p>这就要依靠 TCP 协议，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。</p>
<p>以太网数据包（packet）的大小是固定的，其中， 1500 字节是负载（payload），22字节是头信息（head）。</p>
<p>IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。 </p>
<p>IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包的负载里面。</p>
<p>TCP 的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。</p>
<p>由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p>
<p>因此，一条1500字节的信息需要两个 TCP 数据包。</p>
<p>HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个。</p>
<p>TCP 面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP应用程序交下来的数据仅仅是一连串的无结构的字节流。</p>
<hr>
<p>IP地址分成两个部分，前一部分代表网络，后一部分代表主机。</p>
<p>比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。</p>
<p>处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>
<ul>
<li>GoogleIP地址是172.194.72.105；</li>
<li>本机IP地址：192.168.1.100；</li>
<li>子网掩码：255.255.255.0；</li>
<li>网关的IP地址：192.168.1.1；</li>
<li>DNS的IP地址：8.8.8.8；</li>
</ul>
<p>要判断IP地址是不是在同一个子网络，这就要用到子网掩码。</p>
<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；</p>
<p>然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。</p>
<p>两个结果不相等，所以Google与本机不在同一个子网络。</p>
<p>因此要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
