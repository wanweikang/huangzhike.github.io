	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[笔记]-十六、对象 | 一切都沉淀为笔记</title>
  <meta name="author" content="Huangzhike">
  
  <meta name="description" content="对象（object）是无序的数据集合，由若干个“键值对”（key-value）构成。1234var o = &amp;#123;	a: &amp;quot;Hello World&amp;quot;,	b: 1994&amp;#125;;
键名键名加不加引号都可以，上面的代码也可以写成下面这样。123var o = &amp;#123;	">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[笔记]-十六、对象"/>
  <meta property="og:site_name" content="一切都沉淀为笔记"/>

  
  
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="//favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">一切都沉淀为笔记</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/resume" title="我的主页">
                    <i class="fa fa-github"></i>GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>[笔记]-十六、对象</h2>
					
					<div>
						<span class="post-time">2016-10-29 13:45</span>
					</div>	
					

					<div class="article-content">
						<p>对象（object）是无序的数据集合，由若干个“键值对”（key-value）构成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	a: &quot;Hello World&quot;,</div><div class="line">	b: 1994</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>键名<br>键名加不加引号都可以，上面的代码也可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	&quot;a&quot;: &quot;Hello World&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但是，如果键名包含数字、字母、下划线以外的字符，或者第一个字符为数字，也不是正整数，则必须加上””。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	&quot;1a&quot;: &quot;Hello World&quot;,</div><div class="line">	&quot;a b&quot;: &quot;Hello World&quot;,</div><div class="line">	&quot;a-b&quot;: &quot;Hello World&quot;,</div><div class="line">	&quot;a+b&quot;: &quot;Hello World&quot;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>属性<br>对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	a: function(x) &#123;return 2*x;&#125; // 对象o有一个方法a，它是一个函数。</div><div class="line">&#125;;</div><div class="line"></div><div class="line">o.a(1) // 2</div></pre></td></tr></table></figure></p>
<p>有两种方式来访问对象的属性，点操作符或者中括号操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	a: &quot;Hello World&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">o.a // &quot;Hello World&quot;</div><div class="line">o[&quot;a&quot;] // &quot;Hello World&quot;</div></pre></td></tr></table></figure></p>
<p>属性名a-b不是一个有效的变量，就需要用””括起来。访问这个属性也无法使用.操作符，必须用[“xxx”]来访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">o[&quot;a-b&quot;]; // &quot;Hello World&quot;</div><div class="line">o[&quot;a&quot;]; // &quot;Hello World&quot;</div><div class="line">o.a; // &quot;Hello World&quot;</div></pre></td></tr></table></figure></p>
<p>注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123;</div><div class="line">	0.7: &quot;Hello World&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">o.[&quot;0.7&quot;] // &quot;Hello World&quot;</div><div class="line">o[0.7] // &quot;Hello World&quot;</div></pre></td></tr></table></figure></p>
<p>方括号运算符内部可以使用表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o[&quot;hello&quot; + &quot; world&quot;]</div><div class="line">o[3+3]</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name = &quot;a&quot;;</div><div class="line">o[name]; // &quot;Hello World&quot;</div><div class="line"></div><div class="line">foo.1234; // SyntaxError</div><div class="line">foo[&quot;1234&quot;]; // works</div></pre></td></tr></table></figure>
<p>在使用对象字面量语法时，属性名也可以使用字符串。数值属性名会自动转换为字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">	5 : true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在访问字符串属性名时，必须使用方括号语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var test = &#123;</div><div class="line">	&quot;case&quot;: &quot;I am a keyword so I must be notated as a string&quot;,</div><div class="line">	delete: &quot;I am a keyword too so me&quot; // 出错：SyntaxError</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对象的属性名可以使用字符串或者普通字符声明。但上面的第二种声明方式在 ES5 之前会抛出SyntaxError 的错误。<br>原因是 delete 是一个关键词；为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用字符串字面值声明方式。</p>
<p>JavaScript 中所有变量都可以当作对象使用，除了两个例外 null 和undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">false.toString(); // &quot;false&quot;</div><div class="line">[1, 2, 3].toString(); // &quot;1,2,3&quot;</div></pre></td></tr></table></figure></p>
<p>一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器试图将点操作符解析为浮点数字面值的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2.toString(); // 出错：SyntaxError</div></pre></td></tr></table></figure></p>
<p>有很多方法可以让数字的字面值看起来像对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2..toString(); // 第二个点号可以正常解析</div><div class="line">2 .toString(); // 注意点号前面的空格</div><div class="line">(2).toString(); // 2先被计算</div></pre></td></tr></table></figure></p>
<p>属性的继承<br>属性分成两种。一种是对象自身的原生属性，另一种是继承自原型的继承属性。</p>
<p>对象的原生属性<br>对象本身的所有属性，可以用Object.getOwnPropertyNames方法获得。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.getOwnPropertyNames(Date)</div><div class="line">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</div></pre></td></tr></table></figure></p>
<p>对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的。只获取那些可以枚举的属性，使用Object.keys方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.keys(Date)</div><div class="line">// []</div></pre></td></tr></table></figure></p>
<p>判断对象是否具有某个属性，使用hasOwnProperty方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Date.hasOwnProperty(&quot;length&quot;)</div><div class="line">// true</div><div class="line"></div><div class="line">Date.hasOwnProperty(&quot;toString&quot;)</div><div class="line">// false</div></pre></td></tr></table></figure></p>
<p>JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性， 需要使用外部的 hasOwnProperty 函数来获取正确的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">	hasOwnProperty: function() &#123;</div><div class="line">		return false;</div><div class="line">	&#125;,</div><div class="line">	bar: &quot;Here be dragons&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">foo.hasOwnProperty(&quot;bar&quot;); // 总是返回 false</div><div class="line"></div><div class="line">// 使用其它对象的 hasOwnProperty，并将其上下文设置为foo</div><div class="line">(&#123;&#125;).hasOwnProperty.call(foo, &quot;bar&quot;); // true</div></pre></td></tr></table></figure></p>
<p>扩展内置类型的原型<br>一个错误特性被经常使用，那就是扩展 Object.prototype 或者其他内置类型的原型对象。<br>这种技术被称之为 monkey patching 并且会破坏封装。虽然它被广泛的应用到一些 JavaScript 类库中比如 Prototype,<br>扩展内置类型的唯一理由是为了和新的 JavaScript 保持一致，比如Array.forEach。（这是编程领域常用的一种方式，称之为 Backport，也就是将新的补丁添加到老版本中）</p>
<p>属性查找<br>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止。<br>到查找到达原型链的顶部，也就是Object.prototype，但是仍然没有找到指定的属性，就会返回 undefined。</p>
<p>虽然可以通过对象实例访问原型中的值，但却不能通过对象实例重写原型中的值。如果在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，该属性将会屏蔽原型中的那个属性，但不会修改那个属性。使用delete操作符则可以完全删除实例属性，重新访问原型中的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var person1 = new Person();</div><div class="line">person1.name = &quot;jason&quot;;</div><div class="line">delete person1.name;</div><div class="line">alert(person1.name);   //ken</div></pre></td></tr></table></figure></p>
<p>单独使用in操作符，会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(&quot;name&quot; in person1);    //true;</div></pre></td></tr></table></figure></p>
<p>使用for-in循环时，返回的是所有能够通过对象访问的，可枚举的属性，其中既包含存在于实例中的属性，也包括存在原型中的属性。屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的（除了IE8及更早版本）。<br>要取得对象上所有可枚举的实例属性，可以使用ECMAScript5中的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。<br>如果想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()。<br>总结：</p>
<p>for-in 实例+原型、可枚举；<br>Object.keys() 实例、可枚举；<br>Object.getOwnPropertyNames() 实例、可枚举+不可枚举</p>
<p>如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个变量是否被声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 检查a变量是否被声明</div><div class="line"></div><div class="line">if(a) &#123;...&#125; // 报错</div><div class="line">if(window.a) &#123;...&#125; // 不报错</div><div class="line">if(window[&quot;a&quot;]) &#123;...&#125; // 不报错</div></pre></td></tr></table></figure></p>
<p>上面的后二种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。<br>window.a的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。<br>注意，后二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。</p>
<p>判断一个对象是否具有某个属性（不管是自身的还是继承的），使用in运算符。<br>in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(&quot;a&quot; in window) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该运算符对数组也适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = [&quot;hello&quot;, &quot;world&quot;];</div><div class="line"></div><div class="line">0 in a // true</div><div class="line">1 in a // true</div><div class="line">2 in a // false</div><div class="line"></div><div class="line">&quot;0&quot; in a // true</div><div class="line">&quot;1&quot; in a // true</div><div class="line">&quot;2&quot; in a // false</div></pre></td></tr></table></figure></p>
<p>上面代码表示，数字键0和1都在数组之中。<br>由于数组是一种特殊对象，而对象的键名都是字符串，所以字符串的”0“和”1“，也是数组的键名。</p>
<p>in运算符的一个问题是，它不能识别对象继承的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div><div class="line">o.hasOwnProperty(&quot;toString&quot;) // false</div><div class="line"></div><div class="line">&quot;toString&quot; in o // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，toString方法不是对象o自身的属性，而是继承的属性，hasOwnProperty方法可以说明这一点。但是，in运算符不能识别，对继承的属性也返回true。</p>
<p>和 in 操作符一样，for in 循环同样在查找对象属性时遍历原型链上的所有属性。<br>获得对象的所有 enumerable为true属性（不管是自身的还是继承的），可以使用for-in循环(for-in语句循环输出的属性名顺序是不可预测的)</p>
<p>如果一个属性在原型链的上端，试图获取一个不存在的属性将会遍历整个原型链。<br>并且，当使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问。<br>由于 for in 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var o1 = &#123;p1:123&#125;;</div><div class="line"></div><div class="line">var o2 = Object.create(o1,&#123;</div><div class="line">	p2: &#123; </div><div class="line">		value: &quot;abc&quot;, </div><div class="line">		enumerable: true</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">for (p in o2) &#123;</div><div class="line">	console.info(p);</div><div class="line">&#125;</div><div class="line">// p2</div><div class="line">// p1</div></pre></td></tr></table></figure></p>
<p>为了在for…in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断。hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for ( var key in object ) &#123;</div><div class="line">	if ( object.hasOwnProperty(key) ) &#123;</div><div class="line">		/* code */</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了避免这一点，可以新建一个继承null的对象。由于null没有任何属性，所以新对象也就不会有继承的属性了。</p>
<p>获得对象的所有属性（不管是自身的还是继承的，以及是否可枚举），可以使用下面的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function inheritedPropertyNames(obj) &#123;</div><div class="line">	var props = &#123;&#125;;</div><div class="line">	while(obj) &#123;</div><div class="line">		Object.getOwnPropertyNames(obj).forEach(function(p) &#123;</div><div class="line">			props[p] = true;</div><div class="line">		&#125;);</div><div class="line">		obj = Object.getPrototypeOf(obj);</div><div class="line">	&#125;</div><div class="line">	return Object.getOwnPropertyNames(props);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inheritedPropertyNames(Date)</div><div class="line">// [&quot;caller&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;UTC&quot;, &quot;call&quot;, &quot;parse&quot;, &quot;prototype&quot;, &quot;__defineSetter__&quot;, &quot;__lookupSetter__&quot;, &quot;length&quot;, &quot;arguments&quot;, &quot;bind&quot;, &quot;__lookupGetter__&quot;, &quot;isPrototypeOf&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;valueOf&quot;, &quot;apply&quot;, &quot;__defineGetter__&quot;, &quot;name&quot;, &quot;now&quot;, &quot;hasOwnProperty&quot;]</div></pre></td></tr></table></figure></p>
<p>写入属性<br>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">o.p = &quot;abc&quot;;</div><div class="line">o[&quot;p&quot;] = &quot;abc&quot;;</div></pre></td></tr></table></figure></p>
<p>JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var o = &#123; p:1 &#125;;</div><div class="line"></div><div class="line">// 等价于</div><div class="line"></div><div class="line">var o = &#123;&#125;;</div><div class="line">o.p = 1;</div></pre></td></tr></table></figure></p>
<p>属性的删除<br>删除一个属性，需要使用delete操作符；设置属性为 undefined 或者null 并不能真正的删除属性， 而仅仅是移除了属性和值的关联。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	bar: 1,</div><div class="line">	foo: 2,</div><div class="line">	baz: 3</div><div class="line">&#125;;</div><div class="line">obj.bar = undefined;</div><div class="line">obj.foo = null;</div><div class="line">delete obj.baz;</div><div class="line"></div><div class="line">for(var i in obj) &#123;</div><div class="line">	if (obj.hasOwnProperty(i)) &#123;</div><div class="line">		console.log(i, &quot;&quot; + obj[i]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果 bar undefined 和 foo null<br>只有 baz 被真正的删除了，所以从输出结果中消失。</p>
<p>如果删除一个不存在的属性，delete不报错，而且返回true。<br>delete命令只能删除对象本身的属性，不能删除继承的属性。<br>delete命令也不能删除var命令声明的变量，只能用来删除属性。<br>delete命令只能用来保证某个属性的值为undefined，而无法保证该属性是否真的存在。<br>只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var o = Object.defineProperty(&#123;&#125;, &quot;p&quot;, &#123;</div><div class="line">	value: 123,</div><div class="line">	configurable: false</div><div class="line">&#125;);</div><div class="line"></div><div class="line">o.p // 123</div><div class="line">delete o.p // false</div></pre></td></tr></table></figure></p>
<p>对象的引用<br>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，指向同一个内存地址。JavaScript 中的引用始终指向最终的对象，而并非引用本身。修改其中一个变量，会影响到其他所有变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;&#125;;//空对象</div><div class="line">var ref = obj;//引用</div><div class="line">obj.name = &quot;objectA&quot;;</div><div class="line"></div><div class="line">console.log(ref.name);//ref跟着添加了name属性</div><div class="line"></div><div class="line">obj = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];//obj指向了另一个对象(数组对象)</div><div class="line"></div><div class="line">console.log(ref.name);//ref还指向原来的对象</div><div class="line">console.log(obj.length);//3</div><div class="line">console.log(ref.length);//undefined</div><div class="line"></div><div class="line">// 运行结果如下：</div><div class="line">// objectA</div><div class="line">// objectA</div><div class="line">// 3</div><div class="line">// undefined</div></pre></td></tr></table></figure></p>
<p>obj 只是对一个匿名对象的引用，所以，ref 并非指向它，当 obj 指向另一个数组对象<br>时可以看到，引用 ref 并未改变，而始终指向那个后来添加了 name 属性的”空”对象”{}”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var obj = &#123;&#125;; // 新建一个对象，并被obj引用</div><div class="line">var ref = obj; // ref1引用obj,事实上是引用obj引用的空对象</div><div class="line">obj.func = &quot;function&quot;;</div><div class="line"></div><div class="line">console.log(ref.func); // function</div></pre></td></tr></table></figure>
<p>在定义了引用之后，修改原始的那个对象会影响到其引用上。</p>
<p>但是，这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var x = 1;</div><div class="line">var y = x;</div><div class="line"></div><div class="line">x = 2;</div><div class="line">y // 1</div></pre></td></tr></table></figure></p>
<p>上面的代码，当x的值发生变化后，y的值并不变，这表示y和x并不是指向同一个内存地址。</p>
<p>当一个函数拥有多个返回值时，在传统的面向对象语言中，需要组织一个对象，然后返回，而 JavaScript 则完全不需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function point(left, top)&#123;</div><div class="line">	this.left = left;</div><div class="line">	this.top = top;</div><div class="line">	// 直接动态的构建一个新的匿名对象返回即可</div><div class="line">	return &#123;x: this.left, y:this.top&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var pos = new point(3, 4);</div><div class="line">pos.x; // 3</div><div class="line">pos.y; // 4</div></pre></td></tr></table></figure></p>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  Powered by <a href="https://hexo.io">Hexo</a>  | with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme
</p>
<p>
  &copy; 2016 <a href="http://huangzhike.github.io"> Huangzhike </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
