	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[笔记]-十五、this（二） | 一切都沉淀为笔记</title>
  <meta name="author" content="Huangzhike">
  
  <meta name="description" content="显式使用call apply bind 固定 this1234func.call( thisObject, arg1，arg2，… ); // 参数列表，arg1，arg2，...func.apply( thisObject, [arg1, arg2, ...])func.bind( thisObj">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[笔记]-十五、this（二）"/>
  <meta property="og:site_name" content="一切都沉淀为笔记"/>

  
  
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="//favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">一切都沉淀为笔记</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="//resume" title="我的主页">
                    <i class="fa fa-github"></i>GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>[笔记]-十五、this（二）</h2>
					
					<div>
						<span class="post-time">2016-10-26 13:45</span>
					</div>	
					

					<div class="article-content">
						<p>显式使用call apply bind 固定 this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">func.call( thisObject, arg1，arg2，… ); // 参数列表，arg1，arg2，...</div><div class="line">func.apply( thisObject, [arg1, arg2, ...])</div><div class="line">func.bind( thisObject[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure></p>
<p>如果call apply bind 方法没有参数，或者参数为 null 或 undefined，则默认指向全局对象。</p>
<p>传入 null 的用处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function sum(a,b) &#123;</div><div class="line">	console.log(  a + b );</div><div class="line">&#125;</div><div class="line">sum.apply( null, [2, 3] ); // 5 （使用 apply()展开一个数组，并当作参数传入一个函数）</div><div class="line"></div><div class="line"></div><div class="line">var curriedSum = sum.bind( null, 2 );  // （使用 bind() 柯里化， null作为占位值）</div><div class="line">curriedSum( 3 ); // 5</div></pre></td></tr></table></figure></p>
<p>apply及call方法</p>
<p>调用对象的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Math.max(3, 5, 4);</div><div class="line">Math.max.apply(null, [3, 5, 4]); // 5 </div><div class="line">Math.max.call(null, 3, 5, 4); // 5 </div><div class="line">var a = [1, 2, 3, 4];</div><div class="line">Math.max.apply(null, a) // 4 （找出数组最大元素）</div></pre></td></tr></table></figure></p>
<p>将数组的空元素变为undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.apply(null, [&quot;a&quot;,,&quot;b&quot;]) // [ &quot;a&quot;, undefined, &quot;b&quot; ]</div></pre></td></tr></table></figure></p>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但不会跳过undefined。因此，forEach遍历内部元素时，会得到不同的结果。</p>
<p>利用数组对象的slice方法，可以将类似数组对象（如arguments对象）转为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.prototype.slice.apply(&#123;0:1,length:1&#125;) // [1] </div><div class="line">Array.prototype.slice.apply(&#123;0:1&#125;) // []  （被处理的对象必须有length属性，以及对应的数字键）</div><div class="line">Array.prototype.slice.apply(&#123;0:1,length:2&#125;) // [1, undefined]</div><div class="line">Array.prototype.slice.apply(&#123;length:1&#125;) // [undefined]</div></pre></td></tr></table></figure></p>
<p>如果要从函数对象内部引用它自身，那只使用 this 是不够的。<br>一般需要通过一个指向函数对象的词法标识符（变量）来引用它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">	foo.count = 4; // foo指向它自身</div><div class="line">&#125;</div><div class="line">setTimeout( function()&#123;</div><div class="line">	// 匿名函数无法指向自身</div><div class="line">&#125;, 10 );</div></pre></td></tr></table></figure></p>
<p>记录函数 foo 被调用的次数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line">	this.count++;</div><div class="line">	&#125;</div><div class="line">foo.count = 0;</div><div class="line">var i;</div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// foo: 6</div><div class="line">// foo: 7</div><div class="line">// foo: 8</div><div class="line">// foo: 9</div><div class="line">console.log( foo.count ); // 0</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line">	foo.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0</div><div class="line">var i;</div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo( i );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function foo(num) &#123;</div><div class="line">	console.log( &quot;foo: &quot; + num );</div><div class="line">	this.count++;</div><div class="line">&#125;</div><div class="line">foo.count = 0;</div><div class="line">var i;</div><div class="line">for (i=0; i&lt;10; i++) &#123;</div><div class="line">	if (i &gt; 5) &#123;</div><div class="line">		foo.call( foo, i ); // 使用call 确保this指向函数对象foo本身</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log( foo.count ); // 4</div></pre></td></tr></table></figure>
<p>绑定回调函数的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">animate(oDiv,&#123;&quot;left&quot;:600&#125;,2000,function()&#123;</div><div class="line">	this.style.backgroundColor = &quot;red&quot;; // 回调函数中 this 不是oDiv</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(&quot;#btn&quot;).click = obj.handler;  //  handler中 this 不会绑定在 obj上，会绑定到 $(&quot;#btn&quot;)上。</div><div class="line"></div><div class="line">var f = function ()&#123;</div><div class="line">	obj.handler.apply(obj);  // 或者 obj.handler.call(obj);</div><div class="line">	// apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此得把绑定语句写在一个函数体内。</div><div class="line">&#125;;</div><div class="line"></div><div class="line">$(&quot;#btn&quot;).on(&quot;click&quot;, obj.handler);</div></pre></td></tr></table></figure>
<p>解决回调函数绑定更简洁的写法是 bind()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var obj1 = &#123;</div><div class="line">	name: &quot;obj1&quot;,</div><div class="line">	method: function (arg) &#123;</div><div class="line">		console.log( this.name + &quot; &quot; + arg );</div><div class="line">	&#125;,</div><div class="line">	add:function(x,y)&#123;</div><div class="line">		console.log( x + y );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var  obj2 = &#123;</div><div class="line">	name: &quot;obj2&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj1.method(&quot;a&quot;);// obj a</div><div class="line"></div><div class="line">var r = obj1.method;</div><div class="line">r(&quot;a&quot;); // a （this默认绑定为全局）</div><div class="line">var r = obj1.method.bind(obj1);</div><div class="line">r(&quot;a&quot;); // obj a（this已经被绑定obj1） </div><div class="line"></div><div class="line">var add=obj1.add.bind(null,99);</div><div class="line">add(1); // 100（bind除了绑定this以外，还可以绑定原函数的参数。call和apply方法不能）</div><div class="line"></div><div class="line">obj1.method.call(obj2, 24);  </div><div class="line">obj1.method.apply(obj2, [24]);  </div><div class="line">obj1.method.bind(obj2, 24)(); // bind方法返回一个绑定上下文的新函数，而call、apply方法直接执行了函数</div><div class="line">obj1.method.bind(obj2)(24); </div><div class="line">obj1.method.bind(obj2)([24]); // bind方法传递参数可以逐个列出，也可以写在数组中。</div></pre></td></tr></table></figure>
<p>bind方法每运行一次就返回一个新函数</p>
<p>如果要从函数对象内部引用它自身，那只使用 this 是不够的。<br>一般来说需要通过一个指向函数对象的词法标识符（变量）来引用它。</p>
<p>监听事件错误写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(&quot;click&quot;, o.m.bind(o));</div><div class="line">element.removeEventListener(&quot;click&quot;, o.m.bind(o)); //click事件绑定bind方法生成的匿名函数，所以无法取消监听。</div></pre></td></tr></table></figure></p>
<p>正确写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var listener = o.m.bind(o);</div><div class="line">element.addEventListener(&quot;click&quot;, listener);</div><div class="line">element.removeEventListener(&quot;click&quot;, listener);</div></pre></td></tr></table></figure></p>
<p>不支持bind方法的老式浏览器，可以自行定义bind方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if(!(&quot;bind&quot; in Function.prototype))&#123;</div><div class="line">	Function.prototype.bind = function()&#123;</div><div class="line">		var fn = this;</div><div class="line">		args = Array.prototype.slice.call(arguments), </div><div class="line">		context = args.shift();    </div><div class="line">		return function()&#123;</div><div class="line">			return fn.apply(context, args.concat(Array.prototype.slice.call(arguments)));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function bind（fn, context） &#123;</div><div class="line">	var args = [].slice.call(arguments, 2);</div><div class="line">	return function () &#123;</div><div class="line">		return fn.apply(context, args.concat([].slice.call(arguments)));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>jQuery的proxy方法<br>除了用bind方法绑定函数运行时所在的对象，还可以使用 jQuery的 $.proxy方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;#button&quot;).on(&quot;click&quot;, $.proxy(o.f, o)); // $.proxy方法将o.f方法绑定到o对象。</div></pre></td></tr></table></figure></p>
<p>附：bind某案例</p>
<p>已知<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1,2,3].slice(0,1) // [1]</div><div class="line">// 等同于</div><div class="line">Array.prototype.slice.call([1,2,3], 0, 1) // [1]</div><div class="line">// 等同于</div><div class="line">var slice = Function.prototype.call.bind(Array.prototype.slice);</div><div class="line">slice([1, 2, 3], 0, 1) // [1]</div></pre></td></tr></table></figure></p>
<p>改写bind的调用形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function func()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var obj = &#123; name: &quot;obj&quot; &#125;;</div><div class="line">var bind = Function.prototype.call.bind(Function.prototype.bind); // 将Function.prototype.call方法绑定到Function.prototype.bind对象</div><div class="line">bind(func,obj)() // obj</div></pre></td></tr></table></figure></p>
<p>分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bind = Function.prototype.call.bind(Function.prototype.bind);</div></pre></td></tr></table></figure></p>
<p>可以简化结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var bind = func.bind(obj);</div><div class="line">var bind = obj.func;</div></pre></td></tr></table></figure></p>
<p>原式可以理解为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bind = Function.prototype.bind.call; // 返回的是call函数，但这个call函数中的上下文指向Function.prototype.bind。</div></pre></td></tr></table></figure></p>
<p>为什么写：<code>var bind = Function.prototype.call.bind(Function.prototype.bind);</code><br>而不直接写：<code>var bind = Function.prototype.bind.call;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	name: &quot;obj&quot;,</div><div class="line">	method: function () &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">obj.method(); // obj</div><div class="line">var method = obj.method;</div><div class="line">method(); // this 指向全局</div><div class="line"></div><div class="line">var method = obj.method.bind(obj);</div><div class="line">method(); // obj</div></pre></td></tr></table></figure></p>
<p>直接写：<code>var bind = Function.prototype.bind.call;</code><br>bind函数中的上下文已经与 <code>Function.prototype.bind.call</code>中的不一样了<br>而这样写：<code>var bind = Function.prototype.call.bind(Function.prototype.bind);</code><br>bind函数中的上下文与<code>Function.prototype.call.bind(Function.prototype.bind)</code>中是一样的。</p>
<p>为什么写：<code>bind(func,obj);</code><br>而不写：<code>bind(obj, func);</code></p>
<p><code>Function.prototype.call.bind(Function.prototype.bind)</code>相当于<code>Function.prototype.bind.call</code></p>
<p> <code>Function.prototype.bind.call</code>怎么用。<br>其实就相当于<code>obj.bind(arg)</code>。<br>需要func函数绑定对象obj，即<code>func.bind(obj)</code><br>也就是 <code>Function.prototype.bind.call(func, obj)</code>，<br>所以应该这样写 <code>bind(func, obj)</code>。</p>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  Powered by <a href="https://hexo.io">Hexo</a>  | with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme
</p>
<p>
  &copy; 2016 <a href="http://huangzhike.github.io"> Huangzhike </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
