	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[半原创]-继承 | 一切都沉淀为笔记</title>
  <meta name="author" content="Huangzhike">
  
  <meta name="description" content="主要是高程3的笔记，为什么说半原创呢，因为我加了很多注释，还有自己的理解，于是虚荣地自称半原创啦
123456789101112131415161718function Foo() &amp;#123;	this.value = &amp;quot;f&amp;quot;;&amp;#125;Foo.prototype = &amp;#1">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[半原创]-继承"/>
  <meta property="og:site_name" content="一切都沉淀为笔记"/>

  
  
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="//favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">一切都沉淀为笔记</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="//resume" title="我的主页">
                    <i class="fa fa-github"></i>GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>[半原创]-继承</h2>
					
					<div>
						<span class="post-time">2016-10-30 19:45</span>
					</div>	
					

					<div class="article-content">
						<p><strong>主要是高程3的笔记，为什么说半原创呢，因为我加了很多注释，还有自己的理解，于是虚荣地自称半原创啦</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">	this.value = &quot;f&quot;;</div><div class="line">&#125;</div><div class="line">Foo.prototype = &#123;</div><div class="line">	method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Bar() &#123;&#125;</div><div class="line"></div><div class="line">Bar.prototype = new Foo(); // 设置Bar.prototype设为Foo的实例对象（让原型等于实例）</div><div class="line"></div><div class="line">// 使用Bar.prototype = Foo.prototype会使两个对象共享原型，改变原型会相互影响。</div><div class="line">// 使用Bar.prototype = Foo 不会指向 Foo的原型，而是指向函数 Foo。因为 Foo.__proto__===Function.prototype，原型链会回溯到更上层的Function.prototype 而不是Foo.prototype，method 不会在 Bar 的原型链上。</div><div class="line"></div><div class="line">Bar.prototype.barM = &quot;this is Bar&quot;;</div><div class="line">Bar.prototype.constructor = Bar; // 修正Bar.prototype.constructor为Bar本身</div><div class="line"></div><div class="line">var instance = new Bar() // new Bar() 不会创造出一个新的Foo 实例，而是 重复使用它原型上的实例；所有的 Bar 实例都会共享相同的 value 属性。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 原型链</div><div class="line">instance [Bar的实例]</div><div class="line">	Bar.prototype [Foo的实例] </div><div class="line">	&#123; barM: &quot;this is Bar&quot; &#125;</div><div class="line">		Foo.prototype</div><div class="line">		&#123;method: ...&#125;;</div><div class="line">			Object.prototype</div><div class="line">			&#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>instance 对象从 Bar.prototype 和 Foo.prototype 继承下来， 它能访问 Foo 的原型方法 method，也能够访问 Foo 实例属性 value。 </p>
<p>instance.constructor指向Foo，因为Bar的原型指向了Foo的原型，而这个原型对象的constructor属性指向Foo。</p>
<p>由于原型链的关系，可以说 instance 是 Object、Foo、Bar中任何一个的实例。</p>
<p>确定原型与实例之间的关系，第一种方法是使用 instanceof 操作符；第二种方法是使用 isPrototypeOf()方法。<br>Bar.prototype.isPrototypeOf(instance);    //true;</p>
<p>原型链的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">	this.friends = [&quot;Tom&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.getFoo = function()&#123;</div><div class="line">	return this.friends;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Bar()&#123;&#125;</div><div class="line"></div><div class="line">Bar.prototype = new Foo ();</div><div class="line"></div><div class="line">var instance1 = new Bar ();</div><div class="line">instance1.arr.push(&quot;Sam&quot;);</div><div class="line"></div><div class="line">var instance2 = new Bar ();</div><div class="line">instance2.arr; //  [&quot;Tom&quot;,&quot;Sam&quot;]</div></pre></td></tr></table></figure></p>
<p><strong>借用构造函数（经典继承）</strong>，即在子类型构造函数的内部调用超类型构造函数。<br>相对于原型链而言，借用构造函数一个优势就是可以在子类型构造函数中向超类型构造函数传递参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function Foo(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.friends = [&quot;Tom&quot;];</div><div class="line">	this.sayName = function()&#123;</div><div class="line">		return this.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Bar(name)&#123;</div><div class="line">	// 在子类型构造函数的内部调用超类型构造函数</div><div class="line">	Foo.call(this, name); // new 调用与call 把 this绑定为实例，等同于instance.sayName等等</div><div class="line">&#125;</div><div class="line">var instance1 = new Bar (&quot;Jim&quot;);</div><div class="line">instance1.sayName(); // &quot;Jim&quot;</div><div class="line"></div><div class="line">instance1.friends.push(&quot;Sam&quot;);</div><div class="line">instance1.friends; // [&quot;Tom&quot;,&quot;Sam&quot;] </div><div class="line"></div><div class="line">var instance2 = new Bar (&quot;Tim&quot;);</div><div class="line">instance2.friends; // [&quot;Tom&quot;] （Bar的每个实例有自己的friends属性的副本）</div></pre></td></tr></table></figure></p>
<p>借用构造函数无法避免构造函数模式的问题：方法都在构造函数中定义。<br>而且，在超类型的prototype（原型）中定义的方法，对于子类型也不可见。</p>
<p><strong>组合继承（伪经典模式）</strong> JavaScript 最常用的继承模式<br>使用原型链实现原型属性和方法的继承，使用构造函数实现对实例属性的继承。<br>这样，既在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function Foo(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.friends = [&quot;Tom&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Bar(name,age) &#123;</div><div class="line">	Foo.call(this,name); // 继承实例属性（调用 Bar 构造函数时，第二次调用 Foo 函数，在新实例上创建了实例属性，屏蔽了Bar.prototype的同名属性）</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.prototype = new Foo(); // 继承原型属性和方法 （第一次调用 Foo 构造函数时 Bar.prototype 得到 Foo 的实例属性）</div><div class="line"></div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line">Bar.prototype.sayAge = function()&#123;</div><div class="line">	console.log(this.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new Bar(&quot;Jim&quot;,22);</div><div class="line">instance1.friends.push(&quot;Sam&quot;);</div><div class="line">instance1.friends;    // [&quot;Tom&quot;, &quot;Sam&quot;]</div><div class="line">instance1.sayName();    // Jim</div><div class="line">instance1.sayAge();    // 22</div><div class="line"></div><div class="line">var instance2 = new Bar(&quot;Tim&quot;,21);</div><div class="line">instance2.friends;    // [&quot;Tom&quot;]</div><div class="line">instance2.sayName();    // Tim</div><div class="line">instance2.sayAge();    // 21</div></pre></td></tr></table></figure></p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了优点，是JavaScript中最常用的继承模式。<br>而且，instanceof 和 isPrototypeOf()也能够识别组合继承创建的对象。</p>
<p>组合继承缺点：会调用两次超类型构造函数：<br>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。<br>子类型最终会包含超类型对象的全部实例属性，但在调用子类型构造函数时重写这些属性。</p>
<p><strong>原型式继承 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line">	function F()&#123;&#125; // 先创建一个临时的构造函数</div><div class="line">	F.prototype = o; // 将传入的对象作为这个构造函数的原型</div><div class="line">	return new F(); // 返回新实例</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var Person = &#123;</div><div class="line">	name: &quot;Jim&quot;,</div><div class="line">	friends: [&quot;Tom&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = object(Person);</div><div class="line">person1.name =&quot;Sam&quot;;</div><div class="line">person1.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var person2 = object(person);</div><div class="line">person2.name = &quot;Tim&quot;;</div><div class="line">person2.friends.push(&quot;Jam&quot;);</div><div class="line"></div><div class="line">Person.friends;    // [&quot;Tom&quot;, &quot;Rob&quot;, &quot;Jam&quot;]</div></pre></td></tr></table></figure></p>
<p>包含引用类型值的属性会共享相应的值，就像原型模式一样。</p>
<p>ES5的Object.create()方法规范了原型式继承。这个方法接收两个参数：一个新对象原型的对象和一个为新对象定义额外属性的对象（可选）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Person = &#123;</div><div class="line">	name: &quot;Jim&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person = Object.create(Person, &#123;</div><div class="line">	name:&#123;</div><div class="line">		value: &quot;Sam&quot;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person; // Object &#123;name: &quot;Sam&quot;&#125;</div></pre></td></tr></table></figure></p>
<p><strong>寄生式继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function createAnother(original) &#123;</div><div class="line">	var clone = object(original); // 利用原型式继承</div><div class="line">	clone.sayHi = function()&#123;</div><div class="line">		console.log(&apos;hi&apos;);</div><div class="line">	&#125;;</div><div class="line">	return clone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建的新对象不仅具有original的所有属性和方法，还有自己的 sayHi()方法。</p>
<p><strong>寄生组合式继承</strong>  即通过借用构造函数继承属性，通过原型链继承方法。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">function Foo(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.friends= [&quot;Tom&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Bar(name,age) &#123;</div><div class="line">	Foo.call(this,name);     // 继承属性（Bar调用Foo构造方法）</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用Foo构造函数，但并没有继承Foo，Bar创建的对象的原型是：</div><div class="line">// new Bar() --&gt; Bar.prototype --&gt; Object.prototype --&gt; null</div><div class="line"></div><div class="line">new Bar().__proto__ === Bar.prototype;</div><div class="line">Bar.prototype.__proto__ === Object.prototype;</div><div class="line">Object.prototype.__proto__ === null;</div><div class="line"></div><div class="line">// 借助一个中间对象，中间对象的原型指向 Foo.prototype。</div><div class="line"></div><div class="line">// 修改为：</div><div class="line">// new Bar() --&gt; Bar.prototype --&gt; Foo.prototype --&gt; Object.prototype --&gt; null</div><div class="line">// 这样Bar的实例对象不但能调用 Bar.prototype定义的方法，也可以调用 Foo.prototype定义的方法。</div><div class="line"></div><div class="line">function inheritPrototype(Bar,Foo)&#123;</div><div class="line">	</div><div class="line">	var F = function () &#123;&#125;;   // 中间对象用一个空函数F来实现</div><div class="line">	F.prototype = Foo.prototype;  // 把F的原型指向Foo.prototype:</div><div class="line">	Bar.prototype = new F(); // 把Bar的原型指向一个新的F对象，F对象的原型正好指向Foo.prototype:</div><div class="line">	Bar.prototype.constructor = Bar; // 把Bar原型的构造函数修复为Bar:</div><div class="line"></div><div class="line">	// 如果修正constructor属性放在在后面也可以用下面代码	</div><div class="line">	// var prototype = new F(); </div><div class="line">	// prototype.constructor = Bar;</div><div class="line">	// Bar.prototype = prototype;  // 重写 Bar.prototype（Bar的原型指向Foo的原型）</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(Bar,Foo); // 实现继承</div><div class="line"></div><div class="line">/*</div><div class="line">等价</div><div class="line">Bar.prototype = Object.create(Foo.prototype); // 子类继承父类的方法</div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line">*/</div><div class="line"></div><div class="line">// 继承分成两部分，一部分是Bar调用Foo构造方法，另一部分是Bar的原型指向Foo的原型。</div><div class="line"></div><div class="line">/*</div><div class="line">上面代码中，Bar的原型整体指向Foo的原型。有时只需单个方法指向原型，或修改Foo同名方法，可以采用下面的写法。</div><div class="line">Bar.prototype.method = function() &#123;</div><div class="line">    Foo.prototype.method.call(this);</div><div class="line">    // some code</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">// 在Bar原型（就是new F()出的实例对象对象）上定义方法</div><div class="line">// 必须在inheritPrototype之后，因为放在之前会被重写</div><div class="line">Bar.prototype.sayAge = function()&#123;</div><div class="line">	console.log(this.age); </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">var instance1 = new Bar(&quot;Jim&quot;,22);</div><div class="line">instance1.friends.push(&quot;Sam&quot;);</div><div class="line">instance1.friends;    // [&quot;Tom&quot;, &quot;Sam&quot;]</div><div class="line">instance1.sayName();    // Jim</div><div class="line">instance1.sayAge();    // 22</div><div class="line"></div><div class="line">var instance2 = new Bar(&quot;Tim&quot;,21);</div><div class="line">instance2.friends;    // [&quot;Tom&quot;]</div><div class="line">instance2.sayName();    // Tim</div><div class="line">instance2.sayAge();    // 21</div><div class="line"></div><div class="line"></div><div class="line">// 验证原型:</div><div class="line">instance1.__proto__ === Bar.prototype; // true</div><div class="line">instance1.__proto__.__proto__ === Foo.prototype; // true</div><div class="line"></div><div class="line">// 验证继承关系:</div><div class="line">instance1 instanceof Bar; // true</div><div class="line">instance1 instanceof Foo; // true</div></pre></td></tr></table></figure>
<p>高效率体现在它只调用了一次 Foo 构造函数，并且因此避免了在 Bar.prototype 上面创建不必要的属性。<br>与此同时原型链保持不变，因此，还能够正常使用 instanceof 和 isPrototypeOf() 。<br>普遍认为寄生组合式继承是引用类型最理想的继承方式。</p>
<p>JavaScript的原型继承实现：<br>1.定义新的构造函数，并在内部用 call()调用希望“继承”的构造函数，并绑定this；<br>2.借助中间函数F实现原型链继承（通过封装的inherits函数完成）；<br>3.继续在新的构造函数的原型上定义新方法。</p>
<p><strong>class继承</strong></p>
<p>ES6正式引入关键字 class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Foo(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = function () &#123;</div><div class="line">	console.log(this.name );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用 class 字编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Foo &#123;</div><div class="line">	constructor(name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sayName() &#123;</div><div class="line">		console.log( this.name );</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>class 定义包含了构造函数 constructor和定义在原型对象上的函数 sayName()（没有function关键字），避免了分散的代码。</p>
<p>创建一个Foo实例对象和之前一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var person = new Foo(&quot;Sam&quot;);</div><div class="line">person.sayName();</div></pre></td></tr></table></figure></p>
<p>class继承</p>
<p>用class定义对象的另一个好处是继承更方便了。<br>之前从Foo派生一个Bar需要的原型继承的中间对象，原型对象的构造函数等等都不需要了，直接通过 extends 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Bar extends Foo &#123;</div><div class="line">	constructor(name, grade) &#123;</div><div class="line">		super(name);</div><div class="line">		this.grade = grade;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	getGrade() &#123;</div><div class="line">		console.log(this.grade);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意Bar的定义也是 class 关键字实现的，而 extends 则表示原型链对象来自Foo。<br>子类的构造函数可能会与父类不太相同，<br>例如，Bar需要name和grade两个参数，并且需要通过 super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。<br>Bar已经自动获得了父类Foo的sayName方法，又在子类中定义了新的getGrade方法。</p>
<p>ES6引入的class和原有的JavaScript原型继承没有任何区别，class的让JavaScript引擎去实现原来需要我们自己编写的原型链代码。用class的好处就是极大地简化了原型链代码。</p>
<p>不是所有的主流浏览器都支持ES6的class。可以用Babel转换代码。</p>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  Powered by <a href="https://hexo.io">Hexo</a>  | with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme
</p>
<p>
  &copy; 2016 <a href="http://huangzhike.github.io"> Huangzhike </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
