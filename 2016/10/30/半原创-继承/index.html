<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[半原创]-继承 | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[半原创]-继承">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[半原创]-继承</h2>
				
				<div>
					<div class="post-time">2016-10-30</div>
				</div>
				
				<div class="article-content">
				<p><strong>2016-11-17重新整理更新</strong><br><strong>主要是高程3的笔记，因为加了很多注释，还有自己的理解，所以虚荣地称半原创啦</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">	this.value = &quot;f&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">	method: function() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = new Foo(); // 设置Bar.prototype为Foo的实例对象（让原型等于实例）</span><br><span class="line">// 使用Bar.prototype = Foo.prototype使两个对象共享原型，原型相互影响。</span><br><span class="line">// 使用Bar.prototype = Foo不会指向Foo的原型，而是指向函数Foo。</span><br><span class="line">// 因为Foo.__proto__ === Function.prototype，原型链回溯到更上层的Function.prototype而不是Foo.prototype。</span><br><span class="line"></span><br><span class="line">Bar.prototype.barM = &quot;this is Bar&quot;;</span><br><span class="line">Bar.prototype.constructor = Bar; // 修正Bar.prototype.constructor为Bar</span><br><span class="line"></span><br><span class="line">// new Bar()不会创造出一个新的Foo实例，而是重复使用原型上的实例；</span><br><span class="line">// 所有的Bar实例共享相同的value属性</span><br><span class="line">var instance = new Bar();</span><br><span class="line"></span><br><span class="line">// 原型链</span><br><span class="line">instance（Bar的实例）--&gt;Bar.prototype（Foo的实例）--&gt;Foo.prototype--&gt;Object.prototype</span><br></pre></td></tr></table></figure>
<p>instance 对象从 Bar.prototype 和 Foo.prototype 继承下来， 它能访问 Foo 的原型方法 method，也能够访问 Foo 实例属性 value。 </p>
<p>instance.constructor指向Foo，因为Bar的原型指向了Foo的原型，而这个原型对象的constructor属性指向Foo。</p>
<p>由于原型链的关系，可以说 instance 是 Object、Foo、Bar中任何一个的实例。</p>
<p>确定原型与实例之间的关系，第一种方法是使用 instanceof 操作符；第二种方法是使用 isPrototypeOf()方法：<code>Bar.prototype.isPrototypeOf(instance);</code></p>
<p>原型链的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">	this.friends = [&quot;Tom&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getFoo = function()&#123;</span><br><span class="line">	return this.friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Bar()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = new Foo ();</span><br><span class="line"></span><br><span class="line">var instance1 = new Bar ();</span><br><span class="line">instance1.arr.push(&quot;Sam&quot;);</span><br><span class="line"></span><br><span class="line">var instance2 = new Bar ();</span><br><span class="line">instance2.arr; //  [&quot;Tom&quot;,&quot;Sam&quot;]</span><br></pre></td></tr></table></figure></p>
<p><strong>借用构造函数（经典继承）</strong>，即在子类型构造函数的内部调用超类型构造函数。<br>相对于原型链而言，借用构造函数一个优势就是可以在子类型构造函数中向超类型构造函数传递参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.friends = [&quot;Tom&quot;];</span><br><span class="line">	this.sayName = function()&#123;</span><br><span class="line">		return this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Bar(name)&#123;</span><br><span class="line">	// 在子类型构造函数的内部调用超类型构造函数</span><br><span class="line">	Foo.call(this, name); // new 调用与call 把 this绑定为实例，等同于instance.sayName等等</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new Bar (&quot;Jim&quot;);</span><br><span class="line">instance1.sayName(); // &quot;Jim&quot;</span><br><span class="line"></span><br><span class="line">instance1.friends.push(&quot;Sam&quot;);</span><br><span class="line">instance1.friends; // [&quot;Tom&quot;,&quot;Sam&quot;] </span><br><span class="line"></span><br><span class="line">var instance2 = new Bar (&quot;Tim&quot;);</span><br><span class="line">instance2.friends; // [&quot;Tom&quot;] （Bar的每个实例有自己的friends属性的副本）</span><br></pre></td></tr></table></figure></p>
<p>借用构造函数无法避免构造函数模式的问题：方法都在构造函数中定义。<br>而且，在超类型的prototype（原型）中定义的方法，对于子类型也不可见。</p>
<p><strong>组合继承（伪经典模式）</strong> JavaScript 最常用的继承模式<br>使用原型链实现原型属性和方法的继承，使用构造函数实现对实例属性的继承。<br>这样，既在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.friends = [&quot;Tom&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayName = function()&#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar(name,age) &#123;</span><br><span class="line">	Foo.call(this,name); // 继承实例属性（调用 Bar 构造函数时，第二次调用 Foo 函数，在新实例上创建了实例属性，屏蔽了Bar.prototype的同名属性）</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = new Foo(); // 继承原型属性和方法 （第一次调用 Foo 构造函数时 Bar.prototype 得到 Foo 的实例属性）</span><br><span class="line"></span><br><span class="line">Bar.prototype.constructor = Bar;</span><br><span class="line">Bar.prototype.sayAge = function()&#123;</span><br><span class="line">	console.log(this.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Bar(&quot;Jim&quot;,22);</span><br><span class="line">instance1.friends.push(&quot;Sam&quot;);</span><br><span class="line">instance1.friends;    // [&quot;Tom&quot;, &quot;Sam&quot;]</span><br><span class="line">instance1.sayName();    // Jim</span><br><span class="line">instance1.sayAge();    // 22</span><br><span class="line"></span><br><span class="line">var instance2 = new Bar(&quot;Tim&quot;,21);</span><br><span class="line">instance2.friends;    // [&quot;Tom&quot;]</span><br><span class="line">instance2.sayName();    // Tim</span><br><span class="line">instance2.sayAge();    // 21</span><br></pre></td></tr></table></figure></p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了优点，是JavaScript中最常用的继承模式。<br>而且，instanceof 和 isPrototypeOf()也能够识别组合继承创建的对象。</p>
<p>组合继承缺点：会调用两次超类型构造函数：<br>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。<br>子类型最终会包含超类型对象的全部实例属性，但在调用子类型构造函数时重写这些属性。</p>
<p><strong>原型式继承 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function object(o)&#123;</span><br><span class="line">	function F()&#123;&#125; // 先创建一个临时的构造函数</span><br><span class="line">	F.prototype = o; // 将传入的对象作为这个构造函数的原型</span><br><span class="line">	return new F(); // 返回新实例</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Person = &#123;</span><br><span class="line">	name: &quot;Jim&quot;,</span><br><span class="line">	friends: [&quot;Tom&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person1 = object(Person);</span><br><span class="line">person1.name =&quot;Sam&quot;;</span><br><span class="line">person1.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">var person2 = object(person);</span><br><span class="line">person2.name = &quot;Tim&quot;;</span><br><span class="line">person2.friends.push(&quot;Jam&quot;);</span><br><span class="line"></span><br><span class="line">Person.friends;    // [&quot;Tom&quot;, &quot;Rob&quot;, &quot;Jam&quot;]</span><br></pre></td></tr></table></figure></p>
<p>包含引用类型值的属性会共享相应的值，就像原型模式一样。</p>
<p>ES5的Object.create()方法规范了原型式继承。这个方法接收两个参数：一个新对象原型的对象和一个为新对象定义额外属性的对象（可选）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person = &#123;</span><br><span class="line">	name: &quot;Jim&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person = Object.create(Person, &#123;</span><br><span class="line">	name:&#123;</span><br><span class="line">		value: &quot;Sam&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person; // Object &#123;name: &quot;Sam&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>寄生式继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original) &#123;</span><br><span class="line">	var clone = object(original); // 利用原型式继承</span><br><span class="line">	clone.sayHi = function()&#123;</span><br><span class="line">		console.log(&apos;hi&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line">	return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建的新对象不仅具有original的所有属性和方法，还有自己的 sayHi()方法。</p>
<p><strong>寄生组合式继承</strong>  即通过借用构造函数继承属性，通过原型链继承方法。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.friends= [&quot;Tom&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayName = function()&#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar(name,age) &#123;</span><br><span class="line">	Foo.call(this,name);     // 继承属性（Bar调用Foo构造方法）</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用Foo构造函数，但并没有继承Foo，Bar创建的对象的原型是：</span><br><span class="line">// new Bar() --&gt; Bar.prototype --&gt; Object.prototype --&gt; null</span><br><span class="line"></span><br><span class="line">new Bar().__proto__ === Bar.prototype;</span><br><span class="line">Bar.prototype.__proto__ === Object.prototype;</span><br><span class="line">Object.prototype.__proto__ === null;</span><br><span class="line"></span><br><span class="line">// 借助一个中间对象，中间对象的原型指向 Foo.prototype。</span><br><span class="line"></span><br><span class="line">// 修改为：</span><br><span class="line">// new Bar() --&gt; Bar.prototype --&gt; Foo.prototype --&gt; Object.prototype --&gt; null</span><br><span class="line">// 这样Bar的实例对象不但能调用 Bar.prototype定义的方法，也可以调用 Foo.prototype定义的方法。</span><br><span class="line"></span><br><span class="line">function inheritPrototype(Bar,Foo)&#123;</span><br><span class="line">	</span><br><span class="line">	var F = function () &#123;&#125;;   // 中间对象用一个空函数F来实现</span><br><span class="line">	F.prototype = Foo.prototype;  // 把F的原型指向Foo.prototype:</span><br><span class="line">	Bar.prototype = new F(); // 把Bar的原型指向一个新的F对象，F对象的原型正好指向Foo.prototype:</span><br><span class="line">	Bar.prototype.constructor = Bar; // 把Bar原型的构造函数修复为Bar:</span><br><span class="line"></span><br><span class="line">	// 如果修正constructor属性放在在后面也可以用下面代码	</span><br><span class="line">	// var prototype = new F(); </span><br><span class="line">	// prototype.constructor = Bar;</span><br><span class="line">	// Bar.prototype = prototype;  // 重写 Bar.prototype（Bar的原型指向Foo的原型）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(Bar,Foo); // 实现继承</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">等价</span><br><span class="line">Bar.prototype = Object.create(Foo.prototype); // 子类继承父类的方法</span><br><span class="line">Bar.prototype.constructor = Bar;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 继承分成两部分，一部分是Bar调用Foo构造方法，另一部分是Bar的原型指向Foo的原型。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">上面代码中，Bar的原型整体指向Foo的原型。有时只需单个方法指向原型，或修改Foo同名方法，可以采用下面的写法。</span><br><span class="line">Bar.prototype.method = function() &#123;</span><br><span class="line">    Foo.prototype.method.call(this);</span><br><span class="line">    // some code</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 在Bar原型（就是new F()出的实例对象对象）上定义方法</span><br><span class="line">// 必须在inheritPrototype之后，因为放在之前会被重写</span><br><span class="line">Bar.prototype.sayAge = function()&#123;</span><br><span class="line">	console.log(this.age); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance1 = new Bar(&quot;Jim&quot;,22);</span><br><span class="line">instance1.friends.push(&quot;Sam&quot;);</span><br><span class="line">instance1.friends;    // [&quot;Tom&quot;, &quot;Sam&quot;]</span><br><span class="line">instance1.sayName();    // Jim</span><br><span class="line">instance1.sayAge();    // 22</span><br><span class="line"></span><br><span class="line">var instance2 = new Bar(&quot;Tim&quot;,21);</span><br><span class="line">instance2.friends;    // [&quot;Tom&quot;]</span><br><span class="line">instance2.sayName();    // Tim</span><br><span class="line">instance2.sayAge();    // 21</span><br><span class="line"></span><br><span class="line">instance1.__proto__ === Bar.prototype; // true</span><br><span class="line">instance1.__proto__.__proto__ === Foo.prototype; // true</span><br><span class="line"></span><br><span class="line">instance1 instanceof Bar; // true</span><br><span class="line">instance1 instanceof Foo; // true</span><br></pre></td></tr></table></figure>
<p>高效率体现在它只调用了一次 Foo 构造函数，并且因此避免了在 Bar.prototype 上面创建不必要的属性。<br>与此同时原型链保持不变，因此，还能够正常使用 instanceof 和 isPrototypeOf() 。<br>普遍认为寄生组合式继承是引用类型最理想的继承方式。</p>
<p>JavaScript的原型继承实现：<br>1.定义新的构造函数，并在内部用 call()调用希望“继承”的构造函数，并绑定this；<br>2.借助中间函数F实现原型链继承（通过封装的inherits函数完成）；<br>3.继续在新的构造函数的原型上定义新方法。</p>
<p><strong>class继承</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.sayName = function () &#123;</span><br><span class="line">	console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用class编写：</span><br><span class="line">class Foo &#123;</span><br><span class="line">    // 构造函数constructor</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">    // 定义在原型对象上的函数 sayName()（没有function关键字）</span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log( this.name );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个Foo实例对象</span><br><span class="line">var person = new Foo(&quot;Sam&quot;);</span><br><span class="line">person.sayName();</span><br><span class="line"></span><br><span class="line">// 之前从Foo派生一个Bar需要的原型继承的中间对象，原型对象的构造函数等等都不需要了，直接通过 extends 实现：</span><br><span class="line"></span><br><span class="line">// class定义Bar，extends表示原型链对象来自Foo</span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">	constructor(name, grade) &#123;</span><br><span class="line">        // 通过 super(name)调用父类的构造函数，否则父类的name属性无法初始化</span><br><span class="line">		super(name);</span><br><span class="line">		this.grade = grade;</span><br><span class="line">	&#125;</span><br><span class="line">// Bar已经自动获得了父类Foo的sayName方法</span><br><span class="line">// 在子类中定义了新的getGrade方法</span><br><span class="line">	getGrade() &#123;</span><br><span class="line">		console.log(this.grade);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ES6引入的class和原JavaScript原型继承没有任何区别，只是简化了原型链代码。</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
