<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[半原创]-继承 | 一切都沉淀为笔记</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="一个放笔记的地方">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[半原创]-继承"/>
		
		<meta property="og:site_name" content="一切都沉淀为笔记"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一切都沉淀为笔记 <span>Talk is cheap, show me the code</span></a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="/resume" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[半原创]-继承</h2>
				
				<div>
					<span class="post-time">2016-10-30 19:45</span>
				</div>	
				
				<div class="article-content">
				<p><strong>2016-11-17更新</strong><br><strong>主要是高程3的笔记，因为我加了很多注释，还有自己的理解，所以虚荣地自称半原创啦</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.value = <span class="string">"f"</span>;</div><div class="line">&#125;</div><div class="line">Foo.prototype = &#123;</div><div class="line">	<span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo(); <span class="comment">// 设置Bar.prototype为Foo的实例对象（让原型等于实例）</span></div><div class="line"><span class="comment">// 使用Bar.prototype = Foo.prototype会使两个对象共享原型，原型会相互影响。</span></div><div class="line"><span class="comment">// 使用Bar.prototype = Foo不会指向Foo的原型，而是指向函数Foo。</span></div><div class="line"><span class="comment">// 因为Foo.__proto__ === Function.prototype，原型链回溯到更上层的Function.prototype而不是Foo.prototype，method不在Bar的原型链上。</span></div><div class="line"></div><div class="line">Bar.prototype.barM = <span class="string">"this is Bar"</span>;</div><div class="line">Bar.prototype.constructor = Bar; <span class="comment">// 修正Bar.prototype.constructor为Bar本身</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Bar() <span class="comment">// new Bar() 不会创造出一个新的Foo 实例，而是 重复使用它原型上的实例；所有的 Bar 实例都会共享相同的 value 属性。</span></div><div class="line"></div><div class="line"><span class="comment">// 原型链</span></div><div class="line">instance [Bar的实例]</div><div class="line">	Bar.prototype [Foo的实例] </div><div class="line">	&#123; <span class="attr">barM</span>: <span class="string">"this is Bar"</span> &#125;</div><div class="line">		Foo.prototype</div><div class="line">		&#123;<span class="attr">method</span>: ...&#125;;</div><div class="line">			<span class="built_in">Object</span>.prototype</div><div class="line">			&#123;<span class="attr">toString</span>: ... <span class="comment">/* etc. */</span>&#125;;</div></pre></td></tr></table></figure>
<p>instance 对象从 Bar.prototype 和 Foo.prototype 继承下来， 它能访问 Foo 的原型方法 method，也能够访问 Foo 实例属性 value。 </p>
<p>instance.constructor指向Foo，因为Bar的原型指向了Foo的原型，而这个原型对象的constructor属性指向Foo。</p>
<p>由于原型链的关系，可以说 instance 是 Object、Foo、Bar中任何一个的实例。</p>
<p>确定原型与实例之间的关系，第一种方法是使用 instanceof 操作符；第二种方法是使用 isPrototypeOf()方法。<br>Bar.prototype.isPrototypeOf(instance);    //true;</p>
<p>原型链的问题：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.friends = [<span class="string">"Tom"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.getFoo = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.friends;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo ();</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Bar ();</div><div class="line">instance1.arr.push(<span class="string">"Sam"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Bar ();</div><div class="line">instance2.arr; <span class="comment">//  ["Tom","Sam"]</span></div></pre></td></tr></table></figure></p>
<p><strong>借用构造函数（经典继承）</strong>，即在子类型构造函数的内部调用超类型构造函数。<br>相对于原型链而言，借用构造函数一个优势就是可以在子类型构造函数中向超类型构造函数传递参数。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">(name)</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.friends = [<span class="string">"Tom"</span>];</div><div class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span><span class="params">(name)</span></span>&#123;</div><div class="line">	<span class="comment">// 在子类型构造函数的内部调用超类型构造函数</span></div><div class="line">	Foo.call(<span class="keyword">this</span>, name); <span class="comment">// new 调用与call 把 this绑定为实例，等同于instance.sayName等等</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Bar (<span class="string">"Jim"</span>);</div><div class="line">instance1.sayName(); <span class="comment">// "Jim"</span></div><div class="line"></div><div class="line">instance1.friends.push(<span class="string">"Sam"</span>);</div><div class="line">instance1.friends; <span class="comment">// ["Tom","Sam"] </span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Bar (<span class="string">"Tim"</span>);</div><div class="line">instance2.friends; <span class="comment">// ["Tom"] （Bar的每个实例有自己的friends属性的副本）</span></div></pre></td></tr></table></figure></p>
<p>借用构造函数无法避免构造函数模式的问题：方法都在构造函数中定义。<br>而且，在超类型的prototype（原型）中定义的方法，对于子类型也不可见。</p>
<p><strong>组合继承（伪经典模式）</strong> JavaScript 最常用的继承模式<br>使用原型链实现原型属性和方法的继承，使用构造函数实现对实例属性的继承。<br>这样，既在原型上定义方法实现了函数复用，又保证每个实例都有自己的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.friends = [<span class="string">"Tom"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">	Foo.call(<span class="keyword">this</span>,name); <span class="comment">// 继承实例属性（调用 Bar 构造函数时，第二次调用 Foo 函数，在新实例上创建了实例属性，屏蔽了Bar.prototype的同名属性）</span></div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bar.prototype = <span class="keyword">new</span> Foo(); <span class="comment">// 继承原型属性和方法 （第一次调用 Foo 构造函数时 Bar.prototype 得到 Foo 的实例属性）</span></div><div class="line"></div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line">Bar.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Bar(<span class="string">"Jim"</span>,<span class="number">22</span>);</div><div class="line">instance1.friends.push(<span class="string">"Sam"</span>);</div><div class="line">instance1.friends;    <span class="comment">// ["Tom", "Sam"]</span></div><div class="line">instance1.sayName();    <span class="comment">// Jim</span></div><div class="line">instance1.sayAge();    <span class="comment">// 22</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Bar(<span class="string">"Tim"</span>,<span class="number">21</span>);</div><div class="line">instance2.friends;    <span class="comment">// ["Tom"]</span></div><div class="line">instance2.sayName();    <span class="comment">// Tim</span></div><div class="line">instance2.sayAge();    <span class="comment">// 21</span></div></pre></td></tr></table></figure></p>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了优点，是JavaScript中最常用的继承模式。<br>而且，instanceof 和 isPrototypeOf()也能够识别组合继承创建的对象。</p>
<p>组合继承缺点：会调用两次超类型构造函数：<br>一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。<br>子类型最终会包含超类型对象的全部实例属性，但在调用子类型构造函数时重写这些属性。</p>
<p><strong>原型式继承 </strong><br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 先创建一个临时的构造函数</span></div><div class="line">	F.prototype = o; <span class="comment">// 将传入的对象作为这个构造函数的原型</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">// 返回新实例</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">	name: <span class="string">"Jim"</span>,</div><div class="line">	friends: [<span class="string">"Tom"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = object(Person);</div><div class="line">person1.name =<span class="string">"Sam"</span>;</div><div class="line">person1.friends.push(<span class="string">"Rob"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = object(person);</div><div class="line">person2.name = <span class="string">"Tim"</span>;</div><div class="line">person2.friends.push(<span class="string">"Jam"</span>);</div><div class="line"></div><div class="line">Person.friends;    <span class="comment">// ["Tom", "Rob", "Jam"]</span></div></pre></td></tr></table></figure></p>
<p>包含引用类型值的属性会共享相应的值，就像原型模式一样。</p>
<p>ES5的Object.create()方法规范了原型式继承。这个方法接收两个参数：一个新对象原型的对象和一个为新对象定义额外属性的对象（可选）。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> Person = &#123;</div><div class="line">	<span class="built_in">na</span><span class="symbol">me:</span> <span class="string">"Jim"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">var</span> person = Object.create(Person, &#123;</div><div class="line">	<span class="built_in">na</span><span class="symbol">me:</span>&#123;</div><div class="line">		val<span class="symbol">ue:</span> <span class="string">"Sam"</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">person; // Object &#123;<span class="built_in">na</span><span class="symbol">me:</span> <span class="string">"Sam"</span>&#125;</div></pre></td></tr></table></figure></p>
<p><strong>寄生式继承</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">clone</span> = object(original); <span class="comment">// 利用原型式继承</span></div><div class="line">	<span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">		console.log(<span class="string">'hi'</span>);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">clone</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建的新对象不仅具有original的所有属性和方法，还有自己的 sayHi()方法。</p>
<p><strong>寄生组合式继承</strong>  即通过借用构造函数继承属性，通过原型链继承方法。<br>本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.friends= [<span class="string">"Tom"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">	Foo.call(<span class="keyword">this</span>,name);     <span class="comment">// 继承属性（Bar调用Foo构造方法）</span></div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用Foo构造函数，但并没有继承Foo，Bar创建的对象的原型是：</span></div><div class="line"><span class="comment">// new Bar() --&gt; Bar.prototype --&gt; Object.prototype --&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> Bar().__proto__ === Bar.prototype;</div><div class="line">Bar.prototype.__proto__ === <span class="built_in">Object</span>.prototype;</div><div class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="comment">// 借助一个中间对象，中间对象的原型指向 Foo.prototype。</span></div><div class="line"></div><div class="line"><span class="comment">// 修改为：</span></div><div class="line"><span class="comment">// new Bar() --&gt; Bar.prototype --&gt; Foo.prototype --&gt; Object.prototype --&gt; null</span></div><div class="line"><span class="comment">// 这样Bar的实例对象不但能调用 Bar.prototype定义的方法，也可以调用 Foo.prototype定义的方法。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Bar,Foo</span>)</span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;   <span class="comment">// 中间对象用一个空函数F来实现</span></div><div class="line">	F.prototype = Foo.prototype;  <span class="comment">// 把F的原型指向Foo.prototype:</span></div><div class="line">	Bar.prototype = <span class="keyword">new</span> F(); <span class="comment">// 把Bar的原型指向一个新的F对象，F对象的原型正好指向Foo.prototype:</span></div><div class="line">	Bar.prototype.constructor = Bar; <span class="comment">// 把Bar原型的构造函数修复为Bar:</span></div><div class="line"></div><div class="line">	<span class="comment">// 如果修正constructor属性放在在后面也可以用下面代码	</span></div><div class="line">	<span class="comment">// var prototype = new F(); </span></div><div class="line">	<span class="comment">// prototype.constructor = Bar;</span></div><div class="line">	<span class="comment">// Bar.prototype = prototype;  // 重写 Bar.prototype（Bar的原型指向Foo的原型）</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(Bar,Foo); <span class="comment">// 实现继承</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">等价</div><div class="line">Bar.prototype = Object.create(Foo.prototype); // 子类继承父类的方法</div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 继承分成两部分，一部分是Bar调用Foo构造方法，另一部分是Bar的原型指向Foo的原型。</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">上面代码中，Bar的原型整体指向Foo的原型。有时只需单个方法指向原型，或修改Foo同名方法，可以采用下面的写法。</div><div class="line">Bar.prototype.method = function() &#123;</div><div class="line">    Foo.prototype.method.call(this);</div><div class="line">    // some code</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">// 在Bar原型（就是new F()出的实例对象对象）上定义方法</span></div><div class="line"><span class="comment">// 必须在inheritPrototype之后，因为放在之前会被重写</span></div><div class="line">Bar.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.age); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Bar(<span class="string">"Jim"</span>,<span class="number">22</span>);</div><div class="line">instance1.friends.push(<span class="string">"Sam"</span>);</div><div class="line">instance1.friends;    <span class="comment">// ["Tom", "Sam"]</span></div><div class="line">instance1.sayName();    <span class="comment">// Jim</span></div><div class="line">instance1.sayAge();    <span class="comment">// 22</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Bar(<span class="string">"Tim"</span>,<span class="number">21</span>);</div><div class="line">instance2.friends;    <span class="comment">// ["Tom"]</span></div><div class="line">instance2.sayName();    <span class="comment">// Tim</span></div><div class="line">instance2.sayAge();    <span class="comment">// 21</span></div><div class="line"></div><div class="line">instance1.__proto__ === Bar.prototype; <span class="comment">// true</span></div><div class="line">instance1.__proto__.__proto__ === Foo.prototype; <span class="comment">// true</span></div><div class="line"></div><div class="line">instance1 <span class="keyword">instanceof</span> Bar; <span class="comment">// true</span></div><div class="line">instance1 <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>高效率体现在它只调用了一次 Foo 构造函数，并且因此避免了在 Bar.prototype 上面创建不必要的属性。<br>与此同时原型链保持不变，因此，还能够正常使用 instanceof 和 isPrototypeOf() 。<br>普遍认为寄生组合式继承是引用类型最理想的继承方式。</p>
<p>JavaScript的原型继承实现：<br>1.定义新的构造函数，并在内部用 call()调用希望“继承”的构造函数，并绑定this；<br>2.借助中间函数F实现原型链继承（通过封装的inherits函数完成）；<br>3.继续在新的构造函数的原型上定义新方法。</p>
<p><strong>class继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES6用class编写：</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="comment">// 构造函数constructor</span></div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">    <span class="comment">// 定义在原型对象上的函数 sayName()（没有function关键字）</span></div><div class="line">	sayName() &#123;</div><div class="line">		<span class="built_in">console</span>.log( <span class="keyword">this</span>.name );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个Foo实例对象</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Foo(<span class="string">"Sam"</span>);</div><div class="line">person.sayName();</div><div class="line"></div><div class="line"><span class="comment">// 之前从Foo派生一个Bar需要的原型继承的中间对象，原型对象的构造函数等等都不需要了，直接通过 extends 实现：</span></div><div class="line"></div><div class="line"><span class="comment">// class定义Bar，extends表示原型链对象来自Foo</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">        <span class="comment">// 通过 super(name)调用父类的构造函数，否则父类的name属性无法初始化</span></div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.grade = grade;</div><div class="line">	&#125;</div><div class="line"><span class="comment">// Bar已经自动获得了父类Foo的sayName方法</span></div><div class="line"><span class="comment">// 在子类中定义了新的getGrade方法</span></div><div class="line">	getGrade() &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.grade);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6引入的class和原有的JavaScript原型继承没有任何区别，好处就是极大地简化了原型链代码。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by  Huangzhike </p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"> Huangzhike </a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
