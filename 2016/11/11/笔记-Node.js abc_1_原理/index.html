<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-Node.js abc_1_原理 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Node.js abc_1_原理"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Node.js abc_1_原理</h2>
				
				<div>
					<span class="post-time">2016-11-11 0:20</span>
				</div>	
				
				<div class="article-content">
				<h3 id="来源：Node-js开发指南"><a href="#来源：Node-js开发指南" class="headerlink" title="来源：Node.js开发指南"></a>来源：Node.js开发指南</h3><p><strong>注：</strong>我觉得这些东西挺有意思的，虽然我不打算使用node作为后端语言，但是还是想学node，虽然这篇笔记复制粘贴比较多，还是希望保留。</p>
<h4 id="1-单线程下的阻塞式-I-O"><a href="#1-单线程下的阻塞式-I-O" class="headerlink" title="1. 单线程下的阻塞式 I/O"></a>1. 单线程下的阻塞式 I/O</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">result</span> = db.query(<span class="string">'SELECT * from some_table'</span>);</div><div class="line"><span class="comment">// 使用该查询结果</span></div></pre></td></tr></table></figure>
<p>客户端发起 I/O 请求，等待数据库返回结果，结果返回后再操作，由于数据库查询可能涉及磁盘读写和网络通信，延时可能相当大（长达几个到几百毫秒，相比CPU的时钟差了好几个数量级）。这一过程中，服务器无法接受新的请求，即阻塞式 I/O。类似在火车站售票窗口排队买票。</p>
<h4 id="2-多线程下的阻塞式-I-O"><a href="#2-多线程下的阻塞式-I-O" class="headerlink" title="2. 多线程下的阻塞式 I/O"></a>2. 多线程下的阻塞式 I/O</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">result</span> =  db.query(<span class="string">'SELECT * from some_table'</span>); </div><div class="line"><span class="comment">// 使用该查询结果</span></div></pre></td></tr></table></figure>
<p>服务器为每个请求分配一个线程，所有任务均在该线程内执行，就像火车站多开了几个卖票窗口。服务器每创建一个线程，每个线程大概会占用 2M 的内存，而且线程之间的切换也会降低服务器的处理效率，开发多线程程序非常困难，容易出错。程序员需考虑死锁，数据不一致等问题，多线程的程序极难调试和测试。<br>对于高并发的访问，一方面线程长期阻塞等待，另一方面为了应付新请求而不断增加线程，因此会浪费大量系统资源，同时线程的增多也会占用大量的 CPU 时间来处理内存上下文切换，而且还容易遭受低速连接攻击。</p>
<h4 id="3-基于事件驱动的编程模型"><a href="#3-基于事件驱动的编程模型" class="headerlink" title="3. 基于事件驱动的编程模型"></a>3. 基于事件驱动的编程模型</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.query(<span class="string">'SELECT * from some_table'</span>, <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</div><div class="line">	<span class="comment">// 使用该查询结果</span></div><div class="line">&#125;); </div><div class="line"> <span class="comment">// 继续干其他的事</span></div></pre></td></tr></table></figure>
<p>使用一个线程执行，客户发起 I/O 请求的同时传入回调函数，在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作，直到进入事件循环。设想一大早来到办公室，给火车站打个电话，订票，泡杯茶，浏览一下网页，回复一下今天的电子邮件，如果订到票，火车站会联系送票给你。<br>所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，负责在 I/O 执行完后，将结果返回给回调函数。注意 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。</p>
<h4 id="Node-js-用异步式-I-O-和事件驱动代替多线程。"><a href="#Node-js-用异步式-I-O-和事件驱动代替多线程。" class="headerlink" title="Node.js 用异步式 I/O 和事件驱动代替多线程。"></a>Node.js 用异步式 I/O 和事件驱动代替多线程。</h4><ul>
<li>对于高并发的解决方案，传统的架构是多线程模型，为每个业务逻辑提供一个系统线程，通过系统线程切换弥补同步式 I/O 调用时的时间开销。</li>
<li>Node.js 使用的是单线程模型，对于所有 I/O 都采用异步式的请求方式，避免了频繁的上下文切换。</li>
<li>Node.js 在执行的过程中会维护一个事件队列，程序执行时进入事件循环等待下一个事件，每个异步式 I/O 请求完成后会被推送到事件队列，等待处理。</li>
<li>Node.js 的异步机制是基于事件的，所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求，返回的结果由事件循环来处理。</li>
<li>Node.js 进程在同一时刻只会处理一个事件，完成后立即进入事件循环检查并处理后面的事件。好处是，CPU 和内存在同一时间集中处理一件事，同时尽可能让耗时的 I/O 操作并行执行。</li>
<li>对于低速连接攻击，Node.js 只是在事件队列中增加请求，等待操作系统的回应，因而不会有任何多线程开销，很大程度上可以提高 Web 应用的健壮性，防止恶意攻击。</li>
</ul>
<h4 id="阻塞与线程"><a href="#阻塞与线程" class="headerlink" title="阻塞与线程"></a>阻塞与线程</h4><ul>
<li>线程在执行中遇到磁盘读写或网络通信（统称为 I/O 操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。</li>
<li>当 I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通常的同步式 I/O（Synchronous I/O）或阻塞式 I/O （Blocking I/O）。</li>
<li>异步式 I/O （Asynchronous I/O）或非阻塞式 I/O （Non-blocking I/O）则针对所有 I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成 I/O 操作时，以事件形式通知执行 I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。</li>
<li>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的 CPU 核心利用率永远是 100%，I/O 以事件的方式通知。在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让 CPU 资源不被阻塞中的线程浪费。而在非阻塞模式下，线程不会被 I/O 阻塞，永远在利用 CPU。多线程带来的好处仅仅是在多核 CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么 Node.js 使用了单线程、非阻塞的事件编程模式。</li>
<li>单线程事件驱动的异步式 I/O 比传统的多线程阻塞式 I/O 究竟好在哪呢？异步式 I/O 少了多线程的开销。对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。</li>
</ul>
<table>
<thead>
<tr>
<th>同步式 I/O（阻塞式）</th>
<th>异步式 I/O（非阻塞式）</th>
</tr>
</thead>
<tbody>
<tr>
<td>利用多线程提供吞吐量</td>
<td>单线程即可实现高吞吐量</td>
</tr>
<tr>
<td>通过事件片分割和线程调度利用多核CPU</td>
<td>通过功能划分利用多核CPU</td>
</tr>
<tr>
<td>需要由操作系统调度多线程使用多核 CPU</td>
<td>可以将单进程绑定到单核 CPU</td>
</tr>
<tr>
<td>难以充分利用 CPU 资源</td>
<td>可以充分利用 CPU 资源</td>
</tr>
<tr>
<td>内存轨迹大，数据局部性弱</td>
<td>内存轨迹小，数据局部性强</td>
</tr>
<tr>
<td>符合线性的编程思维</td>
<td>不符合传统编程思维</td>
</tr>
</tbody>
</table>
<h4 id="Node-js-不适合做的事："><a href="#Node-js-不适合做的事：" class="headerlink" title="Node.js 不适合做的事："></a>Node.js 不适合做的事：</h4><p><strong>1. 计算密集型的程序</strong></p>
<ul>
<li>在Node.js 0.8 版本之前，Node.js 不支持多线程。</li>
<li>理想情况下，Node.js单线程将一个CPU核心完全占满，所有的请求等待当前请求处理完后进入事件循环才能响应。</li>
<li>如果应用是计算密集型的，除非手动将它拆散，否则请求响应延迟相当大。</li>
<li>例如，某个事件的回调函数中要进行复杂的计算，占用CPU 200毫秒，那么事件循环中所有的请求都要等待200毫秒。</li>
<li>提高响应速度唯一的办法就是把这个计算密集的部分拆成若干个逻辑，即使这样，系统的总吞吐量和总响应延迟也不会降低，只是调度稍微公平了一些。</li>
<li>好在真正的Web 服务器中，很少会有计算密集，如果真的有，它不应该被实现为即时响应。</li>
<li>正确的方式是给用户一个提示，说服务器正在处理中，完成后会通知用户，然后交给服务器的其他进程甚至其他专职的服务器来做这件事。</li>
</ul>
<p><strong>2. 单用户多任务型应用</strong></p>
<ul>
<li>前面讨论的都是服务器端编程，其中一个假设就是用户数量很多。如果面对的是单用户，譬如本地的命令行工具或者图形界面，所谓的大量并发请求就不存在了。</li>
<li>另一个问题出现了，尽管是单用户，却不一定是单任务。例如给用户提供界面的同时后台在进行计算，为了让用户界面阻塞，不得不开启多线程或多进程。</li>
<li>而Node.js 线程或进程之间的通信很不便，因为它根本没有锁，因而号称不会死锁。</li>
<li>Node.js 的多进程往往是在执行同一任务，通过多进程利用多处理器的资源，但遇到多进程相互协作时，就显得捉襟见肘了。</li>
</ul>
<p><strong>3. 逻辑十分复杂的事务</strong></p>
<ul>
<li>Node.js 的控制流不是线性的，它被一个个事件拆散，但人的思维却是线性的，举例来说，要实现一个这样的逻辑：</li>
<li>从银行取钱，拿钱去购买某个虚拟商品，买完以后加入库存数据库，这中间的任何一步都可能会涉及数十次的I/O操作，任何一次操作失败后都要回滚。</li>
<li>这个过程是线性的，已经很复杂了，如果要拆分为非线性的逻辑，那么其复杂程度很可能就达到无法维护的地步了。</li>
<li>Node.js更善于处理那些逻辑简单但访问频繁的任务，而不适合完成逻辑十分复杂的工作。</li>
</ul>
<p><strong>4. Unicode 与国际化</strong></p>
<ul>
<li>Node.js 不支持完整的Unicode，很多字符无法用 string 表示。这不是Node.js 的缺陷，而是JavaScript 标准的问题。</li>
<li>目前JavaScript 支持的字符集还是双字节的UCS2，即用两个字节来表示一个Unicode 字符，这样能表示的字符数量是65536。显然，仅仅是汉字就不止这个数目。</li>
<li>这是历史遗留问题，像2000 年问题（俗称千年虫）一样，都起源于当时人们的主观判断。</li>
<li>最早的Unicode设计者认为65536个字符足以囊括全世界所有的文字了，因此那个时候盲目兼容Unicode 的系统或平台（如Windows、Java 和JavaScript）在后来都遇到了问题。</li>
<li>Unicode 随后意识到2个字节是不够的，因此推出了UCS4，即用4 个字节来表示一个Unicode 字符。</li>
<li>很多原先用定长编码的UCS2 的系统都升级为了变长编码的UTF-16，因为只有它向下兼容UCS2。</li>
<li>UTF-16 对UCS2 以内的字符采用定长的双字节编码，而对它以外的部分使用多字节的变长编码。</li>
<li>好处是在绝大多数情况下都是定长的编码，有利于提高运算效率，而且兼容了UCS2，缺点是它本质还是变长编码，程序中处理多少有些不便。</li>
<li>许多号称支持UTF-16 的平台仍然只支持它的子集UCS2，而不支持它的变长编码部分。</li>
<li>相比之下，UTF-8 完全是变长编码，有利于传输，而UTF-32 或UCS4 则是4 字节的定长编码，有利于计算。</li>
<li>当下的JavaScript 内部支持的仍是定长的UCS2 而不是变长的UTF-16，因此对于处理UCS4 的字符它无能为力。</li>
<li>所有的JavaScript 引擎都保留了这个缺陷，包括V8 ，因此无法使用Node.js 处理罕见的字符。</li>
<li>想用Node.js 实现一个多语言的字典工具？除非放弃使用 string 数据类型，把所有的字符当作二进制的 Buffer 数据来处理。</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
