<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
				<script>var timeStart = new Date();</script>
		
		<title>[笔记]-Node.js abc_2_Moudule | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Node.js abc_2_Moudule"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Node.js abc_2_Moudule</h2>
				
				<div>
					<span class="post-time">2016-11-11 00:20:17</span>
				</div>	
				
				<div class="article-content">
				<p><strong>参考：</strong></p>
<ul>
<li><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-tutorial.html</a></li>
<li><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">http://www.liaoxuefeng.com/</a></li>
<li>Node.js开发指南 BYVoid</li>
</ul>
<p><strong> Node.js 模块加载：调用 require </strong></p>
<p><strong> Node.js 模块：</strong></p>
<ul>
<li>核心模块：Node.js 标准 API 中提供的模块，如 fs 、 http 、 net 、 vm 。<ul>
<li>核心模块拥有最高的加载优先级，如果有模块与其命名冲突，加载核心模块。</li>
</ul>
</li>
<li>文件模块：存储为单独的文件（或文件夹）的模块，可能是 JavaScript 代码、JSON 或编译好的 C/C++ 代码。<ul>
<li>不显式指定文件模块扩展名时，Node.js 分别加上 .js 、.json 和 .node（编译好的 C/C++ 代码）扩展名。</li>
</ul>
</li>
</ul>
<p><strong>文件模块的加载：按路径加载；查找 node_modules 文件夹。</strong></p>
<ul>
<li>如果 require 参数以“ / ”开头，以绝对路径查找模块名称，例如 require(‘/home/byvoid/module’) 将会按照优先级依次尝试加载 /home/byvoid/module.js、/home/byvoid/module.json 和 /home/byvoid/module.node。</li>
<li>如果 require 参数以“ ./ ”或“ ../ ”开头，以相对路径查找模块，最常见。 require(‘./hello’) 加载同一文件夹下的hello.js。</li>
<li>如果 require 参数不以“ / ”、“ ./ ”或“ ../ ”开头，该模块又不是核心模块，就要通过 node_modules 加载模块。使用npm获取的包通常以这种方式加载。</li>
<li>在某个目录下执行命令 npm install express， 出现了一个node_modules目录。</li>
<li>在 node_modules 目录外一层，可以直接使用 require(‘express’) 代替require(‘./node_modules/express’) ，通过查找 node_modules 目录加载模块。</li>
<li><p>当 require 遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会在当前目录下的 node_modules 目录中来查找，如果没有找到，在当前目录的上一层中的 node_modules 目录中继续查找，直到根目录。</p>
</li>
<li><p>Node.js 模块不会被重复加载，因为 Node.js 通过文件名缓存所有加载过的文件模块，注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，即使分别通过require(‘express’) 和 require(‘./node_modules/express’) 加载两次，也不会重复加载。</p>
</li>
</ul>
<p><strong> 总结：Node.js中存在4类模块（原生模块和3种文件模块），用 require(some_module) 时加载顺序：</strong></p>
<ul>
<li>从文件模块缓存中加载</li>
<li>如果 some_module 是一个核心模块，直接加载，结束。</li>
<li>如果 some_module 以“ / ”、“ ./ ”或“ ../ ”开头，按路径加载 some_module ，结束。</li>
<li>假设当前目录为 current_dir，按路径加载 current_dir/node_modules/some_module。<ul>
<li>如果加载成功，结束。</li>
<li>如果加载失败，令current_dir为其父目录。</li>
<li>重复这一过程，直到遇到根目录，抛出异常，结束。</li>
</ul>
</li>
<li>require方法接受以下参数：<ul>
<li>http、fs、path等，原生模块。</li>
<li>./mod或../mod，相对路径的文件模块。</li>
<li>/pathtomodule/mod，绝对路径的文件模块。</li>
<li>mod，非原生模块的文件模块。</li>
</ul>
</li>
</ul>
<p><strong>包是在模块基础上更深一步的抽象，Node.js 的包将独立的功能封装起来，用于发布、更新、依赖管理和版本控制。</strong></p>
<ul>
<li>Node.js 根据 CommonJS 规范实现了包机制， npm解决包的发布和获取需求。</li>
<li>Node.js 的包是一个目录，包含一个 JSON 格式的包说明文件 package.json。</li>
<li>符合 CommonJS 规范的包应该具备以下特征：<ul>
<li>package.json 在包的顶层目录下；</li>
<li>二进制文件在 bin 目录下；</li>
<li>JavaScript 代码在 lib 目录下；</li>
<li>文档在 doc 目录下；</li>
<li>单元测试在 test 目录下。</li>
</ul>
</li>
</ul>
<p><strong>作为文件夹的模块</strong></p>
<ul>
<li><p>建立 somepackage 文件夹，在其中创建 index.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//somepackage/index.js</span></div><div class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Hello.'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>在 somepackage 外建立 getpackage.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//getpackage.js</span></div><div class="line"><span class="keyword">var</span> somePackage = <span class="built_in">require</span>(<span class="string">'./somepackage'</span>);</div><div class="line">somePackage.hello();</div><div class="line"><span class="comment">// 运行 node getpackage.js，控制台输出 Hello.</span></div></pre></td></tr></table></figure>
</li>
<li><p>somepackage 文件夹下，创建 package.json：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"main"</span> : <span class="string">"./lib/interface.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将 index.js 重命名为 interface.js 并放入 lib 子文件夹下。以同样的方式再次调用这个包，依然可以正常使用。</p>
</li>
<li>Node.js 在调用某个包时，首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果不存在，寻找 index.js 或 index.node 作为包的接口。</li>
<li><p>package.json ：CommonJS 规定的用来描述包的文件。</p>
<ul>
<li>name ：包名，必须唯一，由小写英文字母、数字和下划线组成，不能包含空格。</li>
<li>description ：包的简要说明。</li>
<li>version ：版本字符串。</li>
<li>homepage ：包的官网 url 。</li>
<li>author ：包的作者姓名。</li>
<li>dependencies ：依赖包列表。一个关联数组，由包名称和版本号组成。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li>main ：模块ID，指向程序的主要项目。如果包名 express，用户安装它，require(“express”)。</li>
<li>keywords ：关键字数组，通常用于搜索。</li>
<li>maintainers ：维护者数组，每个元素要包含 name 、 email （可选）、 web （可选）字段。</li>
<li>contributors ：贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。</li>
<li>bugs ：提交bug的地址，可以是网址或者电子邮件地址。</li>
<li>licenses ：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到许可证文本的地址）字段。</li>
<li>repositories ：仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。</li>
</ul>
</li>
<li><p>一个完全符合 CommonJS 规范的 package.json 示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	<span class="attr">"name"</span>: <span class="string">"mypackage"</span>,</div><div class="line">	<span class="attr">"description"</span>: <span class="string">"Sample package for CommonJS."</span>,</div><div class="line">	<span class="attr">"version"</span>: <span class="string">"0.7.0"</span>,</div><div class="line">	<span class="attr">"keywords"</span>: [</div><div class="line">		<span class="string">"package"</span>,</div><div class="line">		<span class="string">"example"</span></div><div class="line">	],</div><div class="line">	<span class="attr">"maintainers"</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">"name"</span>: <span class="string">"Bill Smith"</span>,</div><div class="line">			<span class="attr">"email"</span>: <span class="string">"bills@example.com"</span>,</div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="attr">"contributors"</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">"name"</span>: <span class="string">"BYVoid"</span>,</div><div class="line">			<span class="attr">"web"</span>: <span class="string">"http://www.byvoid.com/"</span></div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="attr">"bugs"</span>: &#123;</div><div class="line">		<span class="attr">"mail"</span>: <span class="string">"dev@example.com"</span>,</div><div class="line">		<span class="attr">"web"</span>: <span class="string">"http://www.example.com/bugs"</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">"licenses"</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">"type"</span>: <span class="string">"GPLv2"</span>,</div><div class="line">			<span class="attr">"url"</span>: <span class="string">"http://www.example.org/licenses/gpl.html"</span></div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="attr">"repositories"</span>: [</div><div class="line">		&#123;</div><div class="line">			<span class="attr">"type"</span>: <span class="string">"git"</span>,</div><div class="line">			<span class="attr">"url"</span>: <span class="string">"http://github.com/BYVoid/mypackage.git"</span></div><div class="line">		&#125;</div><div class="line">	],</div><div class="line">	<span class="attr">"dependencies"</span>: &#123;</div><div class="line">		<span class="attr">"webkit"</span>: <span class="string">"1.2"</span>,</div><div class="line">		<span class="attr">"ssl"</span>: &#123;</div><div class="line">			<span class="attr">"gnutls"</span>: [<span class="string">"1.0"</span>, <span class="string">"2.0"</span>],</div><div class="line">			<span class="attr">"openssl"</span>: <span class="string">"0.9.8"</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong> Node.js包管理器</strong></p>
<ul>
<li>npm是 Node.js 官方提供的包管理工具， Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。</li>
<li>npm 提供了命令行工具，可以方便地下载、安装、升级、删除包，也可以作为开发者发布并维护包。</li>
<li>npm 之于 Node.js，就像 pip 之于 Python，gem 之于 Ruby，pear 之于 PHP，CPAN 之于 Perl ……同时也像 apt-get 之于 Debian/Ubutnu，yum 之于 Fedora/RHEL/CentOS，homebrew 之于 Mac OS X。</li>
<li>上面说什么我一点都不懂。</li>
<li>新版nodejs集成了npm，输入 <code>npm -v</code> 测试。</li>
<li>升级命令：<code>npm install npm -g</code></li>
<li>npm 安装包的命令格式为：<code>npm [install/i] [package_name]</code><ul>
<li>如安装 express ， <code>npm install express</code>或<code>$ npm i express</code></li>
<li>在当前目录的 node_modules 子目录下，npm 在获取 express 时自动解析依赖，获取 express 依赖的 mime 、 mkdirp 、qs 和 connect 。</li>
<li>只需 require(‘express’) ，无需指定第三方包路径。</li>
</ul>
</li>
<li>npm在默认从npmjs.org搜索或下载包，将包安装到当前目录的node_modules子目录下。</li>
<li>如果把包安装到全局，可以提高程序的重复利用程度，避免同样的内容的多份副本，坏处是难以处理不同的版本依赖。</li>
<li>如果把包安装到当前目录，则不会有不同程序依赖不同版本的包的冲突问题，缺陷则是被安装许多次。</li>
<li>默认情况下用 npminstall 命令就是采用本地模式，即把包安装到当前目录的 node_modules 子目录下。</li>
<li>Node.js的 require 在加载模块时会尝试搜寻 node_modules 子目录，因此使用 npm 本地模式安装的包可以直接被引用。</li>
<li>还有不同的安装模式，全局模式：<code>npm [install/i] -g [package_name]</code></li>
<li>为什么用全局模式：本地模式不会注册 PATH 环境变量。npm 本地模式仅把包安装到 node_modules 子目录下，其中的 bin 目录没有包含在 PATH 环境变量中，不能直接在命令行中调用。</li>
<li>全局安装时，npm 会将包安装到系统目录，如 /usr/local/lib/node_modules/，同时 package.json 文件中 bin 字段包含的文件会被链接到 /usr/local/bin/。</li>
<li>全局模式安装的包不能直接 require ，因为 require 不会搜索 /usr/local/lib/node_modules/。</li>
<li>本地安装<ul>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ul>
</li>
<li>全局安装<ul>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ul>
</li>
<li>如果希望具备两者功能，需要在两个地方安装或使用 npm link。</li>
<li>卸载模块： <code>npm uninstall express</code></li>
<li>更新模块： <ul>
<li><code>npm update &lt;package&gt;</code>：更新当前目录下node_modules模块。</li>
<li><code>npm update &lt;package&gt; -g</code>：更新全局。</li>
</ul>
</li>
<li>NPM使用语义版本号：<ul>
<li>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</li>
<li>如果只是修复bug，需要更新Z位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>
<li>如果有大变动，向下不兼容，需要更新X位。</li>
<li>在申明第三方包依赖时，除了可依赖固定版本号外，还可依赖于某个范围的版本号。如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。</li>
</ul>
</li>
<li>国内直接用 npm 的官方镜像非常慢，用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</li>
<li><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>，用 cnpm 命令安装模块：<code>cnpm install [name]</code></li>
</ul>
<ul>
<li><p><strong> Node中，有两种方法可在模块中输出变量：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">方法一：直接使用exports</div><div class="line">exports.hello = hello;</div><div class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 同一目录下getmodule.js</span></div><div class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module'</span>);</div><div class="line"></div><div class="line">myModule.hello();</div><div class="line">myModule.sayHello();</div><div class="line"><span class="comment">// node getmodule.js</span></div><div class="line"></div><div class="line"><span class="comment">// 不可以直接对exports赋值</span></div><div class="line"><span class="comment">// 代码可以执行，但模块没有输出任何变量</span></div><div class="line">exports = &#123;</div><div class="line">	<span class="attr">hello</span>: hello,</div><div class="line">	<span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 方法二：对module.exports赋值</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">	<span class="attr">hello</span>: hello,</div><div class="line">	<span class="attr">greet</span>: greet</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>如果a.js和b.js使用了相同的全局变量s，将造成冲突。</p>
</li>
<li><p>Node.js实现“模块”：用函数包装起来，变量就成了函数内部的局部变量。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// hello.js</span></div><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Node.js加载了hello.js后，把代码包装：</span></div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> s = <span class="string">'Hello'</span>;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// Node.js继续加载其他模块，这些模块中定义的变量s互不干扰</span></div></pre></td></tr></table></figure>
</li>
<li><p>模块的输出加载实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node准备的module变量</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</div><div class="line">	<span class="attr">id</span>: <span class="string">'hello'</span>,</div><div class="line">	<span class="attr">exports</span>: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 将变量module传入加载函数</span></div><div class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span> (<span class="params">exports, module</span>) </span>&#123;</div><div class="line">	<span class="comment">// 读取的hello.js代码:</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;&#125;</div><div class="line">	<span class="comment">// module是函数的参数，在hello.js中可直接使用</span></div><div class="line">	<span class="built_in">module</span>.exports = greet;</div><div class="line">	<span class="comment">// hello.js代码结束</span></div><div class="line">	<span class="keyword">return</span> <span class="built_in">module</span>.exports;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Node把整个待加载的hello.js放入包装函数load中执行，把变量传递给了Node</span></div><div class="line"><span class="comment">// exports和module.exports变量是同一个变量，空对象&#123;&#125;</span></div><div class="line"><span class="keyword">var</span> exported = load(<span class="built_in">module</span>.exports, <span class="built_in">module</span>);</div><div class="line"><span class="comment">// 保存module</span></div><div class="line">save(<span class="built_in">module</span>, exported);</div><div class="line"><span class="comment">// 当require()获取module时，Node把对应的module的exports变量返回</span></div><div class="line"><span class="keyword">var</span> greet = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，exports和module.exports变量是同一个变量，并且初始化为空对象{}：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以写</span></div><div class="line">exports.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span>&#125;;</div><div class="line"><span class="comment">// 也可以写</span></div><div class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span>.<span class="title">foo</span> =</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span>&#125;;</div><div class="line"><span class="comment">// 但如果输出函数或数组，只能给module.exports赋值</span></div><div class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span>&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>load()函数最终返回module.exports，给exports赋值是无效的，因为赋值后，module.exports仍然是空对象{}。</p>
</li>
<li>exports 和 module.exports 指向同一对象，本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 改变访问接口；</li>
<li>如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，继续在上面添加新的键值；</li>
<li>如果要输出一个函数或数组，必须直接对module.exports对象赋值。</li>
<li><p>建议对module.exports赋值输出模块变量，可以应对任何情况：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> &#123;</div><div class="line">	foo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span>&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 或：</span></div><div class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span>&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>在外部引用该模块时，其接口对象就是要输出的 greet 对象本身，而不是原先的exports 。</p>
</li>
<li>exports 本身仅仅是一个普通的空对象，即 {} ，专门用来声明接口，通过它为模块闭包的内部建立了一个有限的访问接口。</li>
<li><p>它没有任何特殊的地方，可以用其他代替，譬如 greet 对象。</p>
</li>
<li><p><code>module.exports = variable;</code>：对外暴露模块变量</p>
</li>
<li><code>var ref = require(&#39;module_name&#39;);</code>：引用其他模块暴露的接口</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
