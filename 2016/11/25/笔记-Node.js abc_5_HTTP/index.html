<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-Node.js abc_5_HTTP | 用手记笔记，用心记笔记，用脑记笔记</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="一个放笔记的地方">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Node.js abc_5_HTTP"/>
		
		<meta property="og:site_name" content="用手记笔记，用心记笔记，用脑记笔记"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">用手记笔记，用心记笔记，用脑记笔记</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="/https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Node.js abc_5_HTTP</h2>
				
				<div>
					<span class="post-time">2016-11-25 11:30</span>
				</div>	
				
				<div class="article-content">
				<p><strong>参考：</strong></p>
<ul>
<li><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-tutorial.html</a></li>
<li><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">http://www.liaoxuefeng.com/</a></li>
<li>Node.js开发指南 BYVoid</li>
</ul>
<p>大多数服务器都支持服务端的脚本语言（php、python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。目前主流的Web服务器是Apache、Nginx、IIS。</p>
<ul>
<li>Node.js 是单进程单线程应用程序，通过事件和回调支持并发。</li>
<li>Node.js 每个 API 都是异步的，作为一个独立线程运行，使用异步函数调用，处理并发。</li>
<li>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</li>
<li>Node.js 单线程类似进入while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数。</li>
</ul>
<p>Node.js 标准库提供了<strong> http 模块</strong>，封装了 HTTP 服务器和 HTTP 客户端。 </p>
<ul>
<li><strong>http.Server</strong>：基于事件的 HTTP 服务器，继承自 EventEmitter ，提供以下事件：<ul>
<li>request ：客户端请求到时触发，提供两个参数 request 和 response ，分别是 http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。</li>
<li>connection ：当 TCP 连接建立时触发，提供一个参数 socket ，为 net.Socket 的实例。客户端在 Keep-Alive 模式下可能在同一个connection内发送多次request。</li>
<li>close ：当服务器关闭时触发。注意不是在用户连接断开时。</li>
</ul>
</li>
<li><p><strong>http.request</strong>： HTTP 客户端工具，向 HTTP 服务器发起请求，例如实现 Pingback 或内容抓取。</p>
</li>
<li><p><strong>http.ServerResponse</strong>：响应给客户端的信息，它也是由 http.Server 的 request 事件发送的，作为第二个参数传递，有三个重要的函数，用于返回响应头、响应内容以及结束请求。</p>
<ul>
<li><p>response.writeHead(statusCode, [headers]) ：向请求的客户端发送响应头。</p>
<ul>
<li>headers是类似关联数组的对象，表示响应头的属性。在一个请求内只能调用一次，如果不调用，自动生成一个响应头。</li>
</ul>
</li>
<li><p>response.write(data, [encoding]) ：向请求的客户端发送响应内容。 </p>
<ul>
<li>data 是 Buffer 或字符串，如果 data 是字符串，需要指定encoding，默认 utf-8 。</li>
<li>在 response.end 之前，response.write 可以多次调用。</li>
</ul>
</li>
<li><p>response.end([data], [encoding]) ：结束响应，告知客户端所有发送已经完成。</p>
<ul>
<li>当所有要返回的内容发送完毕的时候，该函数必须调用一次。</li>
<li>它接受两个可选参数，意义和 response.write 相同。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>http.ServerRequest</strong>： HTTP 请求的信息，由 http.Server 的 request 事件发送，HTTP 请求一般可分：请求头（Request Header）和请求体（Requset Body）。请求体较长，需要时间传输， http.ServerRequest 提供了以下3个事件控制请求体传输。作为第一个参数传递，提供属性：</p>
<ul>
<li>data ：请求体数据到来时触发。该事件提供一个参数 chunk ，表示接收到的数据。如果该事件没有被监听，请求体被抛弃。该事件可能被调用多次。</li>
<li>end ：请求体数据传输完成时触发，此后不会再有数据到来。</li>
<li>close ：用户当前请求结束时触发。不同于 end ，如果用户强制终止传输，也还是调用 close 。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根目录下 server.js</span></div><div class="line"><span class="comment">// 导入http模块并把返回值赋给变量</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>); </div><div class="line"><span class="comment">// http.createServer 创建了一个 http.Server 实例，将一个匿名函数作为 HTTP 请求处理函数</span></div><div class="line"><span class="comment">// request, response 参数对象接收和响应数据</span></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</div><div class="line">	<span class="comment">// 获得HTTP请求的method和url</span></div><div class="line">	<span class="built_in">console</span>.log(request.method + <span class="string">': '</span> + request.url);</div><div class="line">	<span class="comment">// 发送 HTTP 头部，将HTTP响应200写入response, 设置Content-Type: text/html:</span></div><div class="line">	response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">	<span class="comment">// 将HTTP响应的HTML内容写入response</span></div><div class="line">	response.write(<span class="string">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</div><div class="line">	response.end(<span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 服务器监听8080端口:</span></div><div class="line">server.listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure>
<p>http.Server事件中，最常用的是 request ，因此提供了捷径：http.createServer([requestListener]) ，创建一个 HTTP 服务器并将requestListener 作为 request 事件的监听函数，它显式的实现方法是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// httpserver.js</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> http.Server();</div><div class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">	res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">	res.write(<span class="string">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</div><div class="line">	res.end(<span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>HTTP 协议 1.1 提供了8种标准的请求方法，最常见的就是 GET 和 POST。<br>GET 请求把所有内容编码到访问路径中，POST 请求的内容全部都在请求体中。<br>http.ServerRequest 并没有一个属性内容为请求体，因为等待请求体可能非常耗时，譬如上传文件。<br>而很多时候并不需要理会请求体的内容，恶意的 POST 请求会大大消耗服务器的资源。<br>Node.js 默认不解析请求体，需要手动去做。</p>
<ul>
<li><p>获取GET请求内容</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="built_in">var</span> <span class="built_in">url</span> = <span class="built_in">require</span>(<span class="string">'url'</span>); <span class="comment">// 解析URL，parse()将字符串解析为Url对象</span></div><div class="line"><span class="built_in">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</div><div class="line">		res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">		res.end(util.inspect(<span class="built_in">url</span>.parse(req.url, <span class="literal">true</span>)));</div><div class="line">&#125;).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 浏览器中访问 http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com 返回</span></div><div class="line">&#123; </div><div class="line">	<span class="attribute">search</span>: <span class="string">'?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</div><div class="line">	<span class="attribute">query</span>: &#123; <span class="attribute">name</span>: <span class="string">'byvoid'</span>, <span class="attribute">email</span>: <span class="string">'byvoid@byvoid.com'</span> &#125;, <span class="comment">// GET请求的内容</span></div><div class="line">	<span class="attribute">pathname</span>: <span class="string">'/user'</span>, <span class="comment">// 路径</span></div><div class="line">	<span class="attribute">path</span>: <span class="string">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span>,</div><div class="line">	<span class="attribute">href</span>: <span class="string">'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获取POST请求内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> post = <span class="string">''</span>; <span class="comment">// 用于暂存请求体的信息</span></div><div class="line">	<span class="comment">// 通过req的data事件监听函数，每接受到请求体的数据，就累加到post中</span></div><div class="line">	req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123; 		</div><div class="line">		post += chunk;</div><div class="line">	&#125;);</div><div class="line">	<span class="comment">// end事件触发后，querystring.parse将post解析为真正的POST请求格式，返回客户端</span></div><div class="line">	req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; 		</div><div class="line">		post = querystring.parse(post);</div><div class="line">		res.end(util.inspect(post));</div><div class="line">	&#125;);</div><div class="line">&#125;).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>不要在真正的生产中使用上面这种简单的方法来获取 POST 请求，它有严重的效率和安全问题。</p>
</li>
</ul>
<p>静态 HTML 的扩展性非常有限，无法与用户有效交互。如果有大量相似内容，如产品介绍页面，1000个产品就要1000个静态的 HTML 页面。</p>
<p>Node.js 和 PHP、Perl、ASP、JSP 一样，都是实现动态网页，由服务器动态生成 HTML 页面。</p>
<p>最早实现动态网页是使用Perl 和 CGI。在 Perl 程序中输出 HTML 内容， HTTP服务器调用 Perl 程序，将结果返回给客户端。这种方式在互联网刚兴起的90年代非常流行，但如果 HTML 内容比较多，维护非常不方便。</p>
<p>2000年左右，以 ASP、PHP、JSP 为代表的模板为中心的语言出现了，与 CGI 相反，在以 HTML 为主的模板中插入程序代码 。2002年前后非常流行，但页面和程序逻辑紧密耦合，规模变大后会遇到结构混乱的问题。</p>
<p>为了解决这种问题，以 MVC 架构为基础的平台逐渐兴起， Ruby on Rails、Django、Zend Framework 都是基于 MVC 架构的。</p>
<ul>
<li>MVC （Model-View-Controller，模型-视图-控制器）是一种软件设计模式：<ul>
<li>模型是对象及其数据结构的实现，通常包含数据库操作。</li>
<li>视图表示用户界面，通常是 HTML 。</li>
<li>控制器处理用户请求和数据流、复杂模型，将输出传递给视图。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特 性</th>
<th style="text-align:right">模板为中心架构</th>
<th style="text-align:right">MVC 架构</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面产生</td>
<td style="text-align:right">执行并替换标签中的语句</td>
<td style="text-align:right">由模板引擎生成 HTML 页面</td>
</tr>
<tr>
<td>路径解析机</td>
<td style="text-align:right">对应文件系统</td>
<td style="text-align:right">由控制器定义</td>
</tr>
<tr>
<td>数据访问</td>
<td style="text-align:right">通过 SQL 语句查询或访问文件系统</td>
<td style="text-align:right">对象关系模型</td>
</tr>
<tr>
<td>架构中心</td>
<td style="text-align:right">脚本语言是静态 HTTP 服务器的扩展</td>
<td style="text-align:right">静态 HTTP 服务器是脚本语言的补充</td>
</tr>
<tr>
<td>适用范围</td>
<td style="text-align:right">小规模网站</td>
<td style="text-align:right">大规模网站</td>
</tr>
<tr>
<td>学习难度</td>
<td style="text-align:right">容易</td>
<td style="text-align:right">较难</td>
</tr>
</tbody>
</table>
<p>WebSocket是HTML5新增的协议，在浏览器和服务器之间建立一个不受限的双向通信的通道，服务器可以在任意时刻发送消息给浏览器。<br>传统的HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求。浏览器不主动请求，服务器没法主动发数据给浏览器。<br>这样要在浏览器中搞一个实时聊天，在线炒股，或者在线多人游戏就没法实现了，只能借助Flash这些插件。<br>有人说，HTTP协议也能实现啊，比如轮询或Comet。<br>轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息。缺点一是实时性不够，二是频繁的请求会给服务器带来极大压力。<br>Comet本质上也是轮询，但在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。暂时地解决了实时性问题，但以多线程模式运行的服务器让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是不可控的，这就要求Comet必须定期发一些ping数据表示连接“正常工作”。</p>
<p>WebSocket并不是全新的协议，而是利用了HTTP协议建立连接。<br>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GET <span class="string">ws:</span><span class="comment">//localhost:3000/ws/chat HTTP/1.1</span></div><div class="line"><span class="string">Host:</span> localhost</div><div class="line"><span class="string">Upgrade:</span> websocket</div><div class="line"><span class="string">Connection:</span> Upgrade</div><div class="line"><span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//localhost:3000</span></div><div class="line">Sec-WebSocket-<span class="string">Key:</span> client-random-string</div><div class="line">Sec-WebSocket-<span class="string">Version:</span> <span class="number">13</span></div></pre></td></tr></table></figure></p>
<ul>
<li>该请求和普通的HTTP请求有几点不同：<ul>
<li>GET请求的地址不是/path/，而是以ws://开头的地址；</li>
<li>请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；</li>
<li>Sec-WebSocket-Key标识这个连接，并非用于加密数据；</li>
<li>Sec-WebSocket-Version指定WebSocket的协议版本。</li>
</ul>
</li>
</ul>
<p>服务器如果接受该请求，就会返回如下响应：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols // <span class="number">101</span>表示本次连接的HTTP协议将被更改</div><div class="line"><span class="attribute">Upgrade</span>: websocket // 更改后的协议是Upgrade: websocket指定的WebSocket协议</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: server-random-string</div></pre></td></tr></table></figure></p>
<p>消息有两种，一种是文本，一种是二进制数据。通常可以发送JSON格式的文本，在浏览器处理起来十分容易。</p>
<p>为什么WebSocket连接可以实现全双工通信而HTTP连接不行？</p>
<ul>
<li>HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但HTTP协议的请求－应答机制限制了全双工通信。</li>
<li>WebSocket连接不是请求－应答机制。</li>
</ul>
<p>安全的WebSocket连接机制和HTTPS类似。<br>首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p>
<p>WebSocket协议本身不要求同源策略（Same-origin Policy），但浏览器会发送Origin的HTTP头给服务器，服务器可以根据Origin拒绝这个WebSocket请求。所以是否要求同源要看服务器端。</p>
<p>服务器在响应connection事件时并未检查请求的路径，因此，在客户端打开ws://localhost:3000/any/path可以写任意的路径。实际应用中需要根据不同的路径实现不同的功能。</p>
<p><strong>其它</strong>：REST API规范没有仔细看，Express，koa等也只是略看了看，因为我不打算使用这些框架，暂时不学，以上。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
