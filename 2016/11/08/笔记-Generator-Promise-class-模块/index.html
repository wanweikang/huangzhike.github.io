<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-Generator-Promise-class-模块 | 一切都沉淀为笔记</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="Generator函数是ES6提供的一种异步编程解决方案，function命令与函数名之间有一个星号；函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态。Generator函数的调用与普通函数一样，不同的是，调用Generator函数后，该函数并不执行，返回一个指向内部状态的指针对">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Generator-Promise-class-模块"/>
		
		<meta property="og:site_name" content="一切都沉淀为笔记"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一切都沉淀为笔记</a>
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="/resume" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Generator-Promise-class-模块</h2>
				
				<div>
					<span class="post-time">2016-11-08 12:22</span>
				</div>	
				
				<div class="article-content">
				<p>Generator函数是ES6提供的一种异步编程解决方案，function命令与函数名之间有一个星号；函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态。<br>Generator函数的调用与普通函数一样，不同的是，调用Generator函数后，该函数并不执行，返回一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。<br>调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。<br>Generator函数是分段执行的，yield命令是暂停执行的标记，而next方法可以恢复执行。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 定义了一个Generator函数helloWorldGenerator</div><div class="line"><span class="keyword">function</span>* helloWorldGenerator() &#123;</div><div class="line">	// 内部有两个yield语句“hello”和“world”</div><div class="line">	// 该函数有三个状态：hello，world和return语句（结束执行）</div><div class="line">	yield <span class="string">'hello'</span>;</div><div class="line">	yield <span class="string">'world'</span>;</div><div class="line">	return <span class="string">'ending'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var hw = helloWorldGenerator();</div><div class="line"></div><div class="line">hw.<span class="keyword">next</span>() // &#123; value: <span class="string">'hello'</span>, done: false &#125;</div><div class="line">hw.<span class="keyword">next</span>() // &#123; value: <span class="string">'world'</span>, done: false &#125;</div><div class="line">hw.<span class="keyword">next</span>() // &#123; value: <span class="string">'ending'</span>, done: true &#125;</div><div class="line">hw.<span class="keyword">next</span>() // &#123; value: undefined, done: true &#125;</div><div class="line">// 一共调用了四次<span class="keyword">next</span>方法</div><div class="line"></div><div class="line">// 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。<span class="keyword">next</span>方法返回一个对象，它的<span class="keyword">value</span>属性就是当前yield语句的值hello，done属性的值<span class="literal">false</span>，表示遍历还没有结束。</div><div class="line"></div><div class="line">// 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。<span class="keyword">next</span>方法返回的对象的<span class="keyword">value</span>属性就是当前yield语句的值world，done属性的值<span class="literal">false</span>，表示遍历还没有结束。</div><div class="line"></div><div class="line">// 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到<span class="keyword">return</span>语句（如果没有<span class="keyword">return</span>语句，就执行到函数结束）。<span class="keyword">next</span>方法返回的对象的<span class="keyword">value</span>属性，就是紧跟在<span class="keyword">return</span>语句后面的表达式的值（如果没有<span class="keyword">return</span>语句，则<span class="keyword">value</span>属性的值为undefined），done属性的值<span class="literal">true</span>，表示遍历已经结束。</div><div class="line"></div><div class="line">// 第四次调用，此时Generator函数已经运行完毕，<span class="keyword">next</span>方法返回对象的<span class="keyword">value</span>属性为undefined，done属性为<span class="literal">true</span>。以后再调用<span class="keyword">next</span>方法，返回的都是这个值。</div></pre></td></tr></table></figure></p>
<p>调用Generator函数，返回一个部署了Iterator接口的遍历器对象，用来操作内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。<br>value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<p>yield语句：由于Generator函数返回的遍历器，只有调用next方法才会遍历下一个内部状态，所以提供了一种可以暂停执行的函数。yield语句就是暂停标志。</p>
<ul>
<li>遇到yield语句，暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>
<li>如果没再遇到yield语句，就一直运行到函数结束，直到return语句，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>如果没有return语句，则返回的对象的value属性值为undefined。</li>
</ul>
<p>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）功能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span></span>&#123;</div><div class="line">	<span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。</span></div></pre></td></tr></table></figure></p>
<p>yield语句与return语句相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于遇到yield，函数暂停执行，下一次再从该位置继续向后执行。一个函数里面，只能执行一个return语句，但可以执行多个yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。</p>
<p>Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'执行了！'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> generator = f();</div><div class="line"><span class="comment">// 函数f如果是普通函数，在为变量generator赋值时就会执行</span></div><div class="line"><span class="comment">// 但是函数f是一个Generator函数，只有调用next方法时，函数f才会执行</span></div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	generator.next()</div><div class="line">&#125;, <span class="number">2000</span>);</div></pre></td></tr></table></figure></p>
<p>yield语句不能用在普通函数中，否则会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</div><div class="line"></div><div class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>)</span>&#123;</div><div class="line">	a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>)&#123;</div><div class="line">			<span class="keyword">yield</span>* flat(item);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">yield</span> item;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</div><div class="line">	<span class="built_in">console</span>.log(f);</div><div class="line">&#125;</div><div class="line"><span class="comment">// forEach方法的参数是一个普通函数，但是在里面使用了yield语句。</span></div><div class="line"><span class="comment">// 一种修改方法是改用for循环</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</div><div class="line"></div><div class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> length = a.length;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">		<span class="keyword">var</span> item = a[i];</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>)&#123;</div><div class="line">			<span class="keyword">yield</span>* flat(item);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">yield</span> item;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</div><div class="line">	<span class="built_in">console</span>.log(f);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></div></pre></td></tr></table></figure></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 任意一个对象的Symbol.iterator属性，等于该对象的遍历器函数，调用该函数会返回该对象的一个遍历器</div><div class="line">// 遍历器本身也是一个对象，它的Symbol.iterator属性执行后，返回自身</div><div class="line">function* gen()&#123;</div><div class="line"><span class="code">	// some code</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">var g = gen();</div><div class="line">// gen是一个Generator函数，调用它会生成一个遍历器g</div><div class="line"></div><div class="line">g[<span class="string">Symbol.iterator</span>](<span class="link"></span>) === g // true</div><div class="line">// 遍历器g的Symbol.iterator属性是一个遍历器函数，执行后返回它自己</div></pre></td></tr></table></figure>
<p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义了一个可以无限运行的Generator函数f</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</div><div class="line">		<span class="comment">// 如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined</span></div><div class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</div><div class="line">		<span class="comment">// 当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true）</span></div><div class="line">		<span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125; <span class="comment">// i会等于-1，下一轮循环就会从-1开始递增</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = f();</div><div class="line"></div><div class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></div><div class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></div></pre></td></tr></table></figure></p>
<p>Generator函数从暂停状态到恢复运行，上下文状态（context）是不变的。通过next方法的参数，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</div><div class="line">	<span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</div><div class="line">	<span class="keyword">return</span> (x + y + z);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</div><div class="line"></div><div class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></div><div class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></div><div class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></div><div class="line"><span class="comment">// 第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。</span></div><div class="line"><span class="comment">// 第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。</span></div></pre></td></tr></table></figure></p>
<p>如果向next方法提供参数，返回结果就完全不一样了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</div><div class="line">	<span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</div><div class="line">	<span class="keyword">return</span> (x + y + z);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = foo(<span class="number">5</span>);</div><div class="line"></div><div class="line">it.next() <span class="comment">// &#123; value:6, done:false &#125;</span></div><div class="line">it.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></div><div class="line">it.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 第一次调用next方法时，返回x+1的值6；</span></div><div class="line"><span class="comment">// 第二次调用next方法，将上一次yield语句的值设为12，y等于24，返回y / 3的值8；</span></div><div class="line"><span class="comment">// 第三次调用next方法，将上一次yield语句的值设为13，z等于13，x等于5，y等于24，return语句的值等于42。</span></div></pre></td></tr></table></figure></p>
<p>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。</p>
<p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function* foo() &#123;</div><div class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">&#125;</div><div class="line">// 使用<span class="keyword">for</span>...<span class="keyword">of</span>循环，依次显示<span class="number">5</span>个<span class="keyword">yield</span>语句的值。</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">	console.log(v);</div><div class="line">&#125;</div><div class="line">// <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line">// 一旦next方法的返回对象的done属性为<span class="literal">true</span>，<span class="keyword">for</span>...<span class="keyword">of</span>循环就会中止，且不包含该返回对象，所以<span class="keyword">return</span>语句返回的<span class="number">6</span>，不包括在<span class="keyword">for</span>...<span class="keyword">of</span>循环中。</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 利用generator函数和for...of循环，实现斐波那契数列</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">	<span class="keyword">for</span> (;;) &#123;</div><div class="line">		[prev, curr] = [curr, prev + curr];</div><div class="line">		<span class="keyword">yield</span> curr;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> fibonacci()) &#123;</div><div class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</div><div class="line">	<span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用for...of语句时不需要使用next方法</span></div></pre></td></tr></table></figure>
<p>ES6将Promise写进语言标准，统一了用法，原生提供了Promise对象。所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<p>Promise对象有以下两个特点。<br>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果错过了它，再去监听，是得不到结果的。<br>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。<br>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	<span class="comment">// ... some code</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">		resolve(value);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		reject(error);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供。<br>resolve，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br>reject，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></div><div class="line">	<span class="comment">// success</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></div><div class="line">	<span class="comment">// failure</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// then方法接受两个回调函数作为参数。</span></div><div class="line"><span class="comment">// 第一个回调函数是Promise对象的状态变为Resolved时调用；</span></div><div class="line"><span class="comment">// 第二个回调函数是Promise对象的状态变为Reject时调用，可选。</span></div><div class="line"><span class="comment">// 这两个函数都接受Promise对象传出的值作为参数。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">	<span class="comment">// timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">		setTimeout(resolve, ms, <span class="string">'done'</span>);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 过了ms后，Promise实例的状态变为Resolved，触发then方法绑定的回调函数</span></div><div class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">	<span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用Promise对象实现的Ajax操作</span></div><div class="line"><span class="comment">// getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象</span></div><div class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">		client.open(<span class="string">"GET"</span>, url);</div><div class="line">		client.onreadystatechange = handler;</div><div class="line">		client.responseType = <span class="string">"json"</span>;</div><div class="line">		client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</div><div class="line">		client.send();</div><div class="line">		<span class="comment">// 在getJSON内部，resolve函数和reject函数调用时，都带有参数</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</div><div class="line">				resolve(<span class="keyword">this</span>.response);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> promise;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。<br>reject函数的参数通常是Error对象的实例，表示抛出的错误；<br>resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如下面。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">var</span> <span class="built_in">p1</span> = new Promise(<span class="meta">function</span>(resolve, reject)&#123;</div><div class="line">	// ...</div><div class="line">&#125;)<span class="comment">;</span></div><div class="line"></div><div class="line"><span class="symbol">var</span> <span class="built_in">p2</span> = new Promise(<span class="meta">function</span>(resolve, reject)&#123;</div><div class="line">	// ...</div><div class="line">	resolve(<span class="built_in">p1</span>)<span class="comment">;</span></div><div class="line">&#125;)</div><div class="line">// <span class="built_in">p1</span>和<span class="built_in">p2</span>都是Promise的实例，但是<span class="built_in">p2</span>的resolve方法将<span class="built_in">p1</span>作为参数，即一个异步操作的结果是返回另一个异步操作。</div><div class="line">// 这时<span class="built_in">p1</span>的状态就会传递给<span class="built_in">p2</span>，<span class="built_in">p1</span>的状态决定了<span class="built_in">p2</span>的状态。</div><div class="line">// 如果<span class="built_in">p1</span>的状态是Pending，那么<span class="built_in">p2</span>的回调函数就会等待<span class="built_in">p1</span>的状态改变；</div><div class="line">// 如果<span class="built_in">p1</span>的状态已经是Resolved或者Rejected，那么<span class="built_in">p2</span>的回调函数将会立刻执行。</div></pre></td></tr></table></figure></p>
<p>Promise.prototype.then()：Promise实例具有then方法，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。then方法返回一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> json.post;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</span></div><div class="line"></div><div class="line"><span class="comment">// 采用链式的then，可以指定一组按照次序调用的回调函数。</span></div><div class="line"><span class="comment">// 这时，前一个回调函数，可能返回一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</span></div><div class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> getJSON(post.commentURL);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 第一个then方法指定的回调函数，返回的是另一个Promise对象。</span></div><div class="line"><span class="comment">// 第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。</span></div><div class="line"><span class="comment">// 如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</span></div><div class="line"></div><div class="line"><span class="comment">// 采用箭头函数，上面的代码可以写得更简洁</span></div><div class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</div><div class="line">	<span class="function"><span class="params">post</span> =&gt;</span> getJSON(post.commentURL)</div><div class="line">).then(</div><div class="line">	<span class="function"><span class="params">comments</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments),</div><div class="line">	err =&gt; <span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数</span></div><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="comment">// 处理前一个回调函数运行时发生的错误</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；</span></div><div class="line"><span class="comment">// 如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。</span></div><div class="line"></div><div class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"fulfilled:"</span>, val))</div><div class="line">	.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"fulfilled:"</span>, val))</div><div class="line">	.then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Promise抛出一个错误，就被catch方法指定的回调函数捕获</span></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</div><div class="line"><span class="comment">// Error: test</span></div><div class="line"></div><div class="line"><span class="comment">// 如果Promise状态已经变成resolved，再抛出错误是无效的</span></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">"ok"</span>);</div><div class="line">	<span class="comment">// Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出</span></div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</div><div class="line">&#125;);</div><div class="line">promise</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</div><div class="line">	.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</div><div class="line"><span class="comment">// ok</span></div><div class="line"></div><div class="line"><span class="comment">// Promise对象的错误具有“冒泡”性质，一直向后传递，直到被捕获为止，即，错误总是会被下一个catch语句捕获</span></div><div class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> getJSON(post.commentURL);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</div><div class="line">	<span class="comment">// some code</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="comment">// 处理前面三个Promise产生的错误</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// 一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</span></div><div class="line"></div><div class="line"><span class="comment">// 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</span></div><div class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		<span class="comment">// 下面一行会报错，因为x没有声明</span></div><div class="line">		resolve(x + <span class="number">2</span>);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// someAsyncThing函数产生的Promise对象会报错，但是由于没有调用catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">	resolve(<span class="string">"ok"</span>);</div><div class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</div><div class="line">&#125;);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;); <span class="comment">// ok</span></div><div class="line"><span class="comment">// Uncaught Error: test</span></div><div class="line"><span class="comment">// Promise指定在下一轮“事件循环”再抛出错误，由于没有指定catch语句，就冒泡到最外层，成了未捕获的错误。</span></div><div class="line"></div><div class="line"><span class="comment">// catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法</span></div><div class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		<span class="comment">// 下面一行会报错，因为x没有声明</span></div><div class="line">		resolve(x + <span class="number">2</span>);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> someOtherAsyncThing();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></div><div class="line"><span class="comment">// carry on</span></div><div class="line"></div><div class="line"><span class="comment">// catch方法之中，还能再抛出错误</span></div><div class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		<span class="comment">// 下面一行会报错，因为x没有声明</span></div><div class="line">		resolve(x + <span class="number">2</span>);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> someOtherAsyncThing();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</div><div class="line">	<span class="comment">// 下面一行会报错，因为y没有声明</span></div><div class="line">	y + <span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></div><div class="line"><span class="comment">// catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。</span></div><div class="line"><span class="comment">// 如果改写一下，结果就不一样了</span></div><div class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> someOtherAsyncThing();</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</div><div class="line">	<span class="comment">// 下面一行会报错，因为y没有声明</span></div><div class="line">	y + <span class="number">2</span>;</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></div><div class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></div><div class="line"><span class="comment">// 第二个catch方法用来捕获，前一个catch方法抛出的错误。</span></div></pre></td></tr></table></figure></p>
<p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		resolve(<span class="string">'foo'</span>);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">var</span> foo = <span class="keyword">yield</span> getFoo();</div><div class="line">		<span class="built_in">console</span>.log(foo);</div><div class="line">	&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">		<span class="built_in">console</span>.log(e);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。</span></div><div class="line"><span class="comment">// 函数run用来处理这个Promise对象，并调用下一个next方法。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> it = generator();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">			<span class="keyword">return</span> go(it.next(value));</div><div class="line">		&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">			<span class="keyword">return</span> go(it.throw(value));</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	go(it.next());</div><div class="line">&#125;</div><div class="line"></div><div class="line">run(g);</div></pre></td></tr></table></figure></p>
<p>ES6诞生以前，异步编程的方法，大概有四种：回调函数，事件监听，发布/订阅，Promise 对象。</p>
<p>异步：所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<p>回调函数：JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取文件进行处理</span></div><div class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">	<span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// readFile函数的第二个参数，就是回调函数，等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。</span></div></pre></td></tr></table></figure></p>
<p>为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>&#123;</div><div class="line">	fs.readFile(fileB, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>&#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 如果依次读取多个文件，就会出现多重嵌套。很快就会乱成一团。这种情况就称为“回调函数噩梦”（callback hell）。</span></div></pre></td></tr></table></figure></p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用Promise，连续读取多个文件</span></div><div class="line"><span class="comment">// 使用fs-readfile-promise模块，作用是返回一个Promise版本的readFile函数</span></div><div class="line">var readFile = require(<span class="string">'fs-readfile-promise'</span>);</div><div class="line"><span class="comment">// Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</span></div><div class="line">readFile(fileA)</div><div class="line">	.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">		console.<span class="built_in">log</span>(data.toString());</div><div class="line">	&#125;)</div><div class="line">	.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></div><div class="line">		<span class="keyword">return</span> readFile(fileB);</div><div class="line">	&#125;)</div><div class="line">	.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span>&#123;</span></div><div class="line">		console.<span class="built_in">log</span>(data.toString());</div><div class="line">	&#125;)</div><div class="line">	.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(err)</span> &#123;</span></div><div class="line">		console.<span class="built_in">log</span>(err);</div><div class="line">	&#125;);</div><div class="line"><span class="comment">// Promise写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，并无新意。</span></div><div class="line"><span class="comment">// Promise 的最大问题是代码冗余。</span></div></pre></td></tr></table></figure></p>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。它的运行流程大致如下。</p>
<p>第一步，协程A开始执行。<br>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。<br>第三步，（一段时间后）协程B交还执行权。<br>第四步，协程A恢复执行。上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取文件的协程写法如下</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="comment">// ...其他代码</span></div><div class="line">	<span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</div><div class="line">	<span class="comment">// ...其他代码</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数asyncJob是一个协程，奥妙在yield命令。它表示执行到此处，执行权将交给其他协程。</span></div><div class="line"><span class="comment">// 也就是说，yield命令是异步两个阶段的分界线。</span></div><div class="line"><span class="comment">// 协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。</span></div><div class="line"><span class="comment">// 最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</span></div></pre></td></tr></table></figure></p>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">	<span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 调用Generator函数，会返回一个内部指针（即遍历器）g </span></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</div><div class="line"><span class="comment">// Generator函数不同于普通函数，执行它不会返回结果，返回的是指针对象。</span></div><div class="line"><span class="comment">// 调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句</span></div><div class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></div><div class="line"><span class="comment">// 执行到x + 2为止</span></div></pre></td></tr></table></figure></p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">	<span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</div><div class="line"></div><div class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></div><div class="line"><span class="comment">// 第一个next方法的value属性，返回表达式x + 2的值</span></div><div class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></div><div class="line"><span class="comment">// 第二个next方法带有参数2，传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。</span></div><div class="line"><span class="comment">// 因此，这一步的 value 属性，返回的就是2（变量y的值）。</span></div></pre></td></tr></table></figure></p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">	&#125; <span class="keyword">catch</span> (e)&#123;</div><div class="line">		<span class="built_in">console</span>.log(e);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</div><div class="line">g.next();</div><div class="line">g.throw（<span class="string">'出错了'</span>）<span class="comment">// 出错了</span></div><div class="line"><span class="comment">// 最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。</span></div><div class="line"><span class="comment">// 出错的代码与处理错误的代码，实现了时间和空间上的分离。</span></div></pre></td></tr></table></figure></p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">var</span> <span class="built_in">url</span> = <span class="string">'https://api.github.com/users/github'</span>;</div><div class="line">	<span class="built_in">var</span> result = <span class="keyword">yield</span> fetch(<span class="built_in">url</span>);</div><div class="line">	<span class="built_in">console</span>.log(result.bio);</div><div class="line">&#125;</div><div class="line"><span class="comment">// enerator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。</span></div><div class="line"><span class="comment">// 这段代码非常像同步操作，除了加上了yield命令。</span></div><div class="line"></div><div class="line"><span class="comment">// 执行这段代码的方法如下</span></div><div class="line"><span class="built_in">var</span> g = gen();</div><div class="line"><span class="built_in">var</span> result = g.next();</div><div class="line"></div><div class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> data.json();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	g.next(data);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。</span></div><div class="line"><span class="comment">// 由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</span></div></pre></td></tr></table></figure>
<p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。这种写法跟传统的面向对象语言（比如C++和Java）差异很大。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>&#123;</div><div class="line">	<span class="keyword">this</span>.x = x;</div><div class="line">	<span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。类和模块的内部，默认就是严格模式，不需要使用use strict指定运行模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="comment">// 定义了一个“类”，里面有一个constructor方法，这就是构造方法</span></div><div class="line">	<span class="comment">// ES5的构造函数Point，对应ES6的Point类的构造方法</span></div><div class="line">	<span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">		<span class="comment">// this关键字代表实例对象</span></div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.y = y;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Point类除了构造方法，还定义了一个toString方法，前面不需要加function</span></div><div class="line">	toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">'('</span>+<span class="keyword">this</span>.x+<span class="string">', '</span>+<span class="keyword">this</span>.y+<span class="string">')'</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></div><div class="line"><span class="comment">// 类的数据类型就是函数。</span></div><div class="line"></div><div class="line"><span class="comment">// 类的方法（除constructor以外）都定义在prototype对象上面</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>()&#123;&#125;</div><div class="line">	toString()&#123;&#125;</div><div class="line">	toValue()&#123;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">Point.prototype = &#123;</div><div class="line">	toString()&#123;&#125;,</div><div class="line">	toValue()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 类的内部所有定义的方法，都是不可枚举的（enumerable）</span></div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span></div><div class="line"><span class="comment">// toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5不一致。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;&#125;</div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// ["toString"]</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span></div><div class="line"><span class="comment">// 采用ES5的写法，toString方法就是可枚举的</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类的属性名，可以采用表达式</span></div><div class="line"><span class="keyword">let</span> methodName = <span class="string">"getArea"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">	[methodName]() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span></div><div class="line"><span class="comment">// 一个类必须有constructor方法，如果没有显式定义，空的constructor方法会被默认添加。</span></div><div class="line"><span class="comment">// 可以指定constructor方法返回另外一个对象。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">// false</span></div></pre></td></tr></table></figure>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 本质上，ES6的<span class="keyword">Class</span>只是ES5的构造函数的包装，函数的许多特性都被<span class="keyword">Class</span>继承，包括<span class="keyword">name</span>属性</div><div class="line"><span class="keyword">class</span> Point &#123;&#125;</div><div class="line">Point.<span class="keyword">name</span> // <span class="string">"Point"</span></div><div class="line">// <span class="keyword">name</span>属性总是返回紧跟在<span class="keyword">class</span>关键字后面的类名。</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 与函数一样，Class也可以使用表达式定义</span></div><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</div><div class="line">	getClassName() &#123;</div><div class="line">		<span class="keyword">return</span> Me.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line">inst.getClassName() <span class="comment">// Me</span></div><div class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></div><div class="line"><span class="comment">// Me只在Class内部有定义</span></div><div class="line"></div><div class="line"><span class="comment">// 如果Class内部没用到的话，可以省略Me</span></div><div class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 采用Class表达式，可以写出立即执行的Class</span></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sayName() &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;(<span class="string">"张三"</span>);</div><div class="line"></div><div class="line">person.sayName(); <span class="comment">// "张三"</span></div><div class="line"><span class="comment">// person是一个立即执行的Class的实例。</span></div></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Class不存在变量提升（hoist），这一点与ES5完全不同</span></div><div class="line"><span class="keyword">new</span> <span class="type">Foo</span>(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>Class的继承：Class之间可以通过extends关键字，实现继承。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// 定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。</span></div><div class="line"><span class="comment">// 但是由于没有部署任何代码，这两个类完全一样，等于复制了一个Point类。</span></div><div class="line"></div><div class="line"><span class="comment">// 在ColorPoint内部加上代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">	constructor(x, y, color) &#123;</div><div class="line">		<span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">		<span class="keyword">this</span>.color = color;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// super关键字，它指代父类的实例（即父类的this对象）。</span></div></pre></td></tr></table></figure></p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象，然后对其加工。如果不调用super方法，子类就得不到this对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	constructor() &#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let cp = <span class="keyword">new</span> <span class="type">ColorPoint</span>(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="comment">// ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</span></div></pre></td></tr></table></figure></p>
<p>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。如果子类没有定义constructor方法，这个方法会被默认添加。即，不管有没有显式定义，任何一个子类都有constructor方法。另一个是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	constructor(x, y) &#123;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.y = y;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	constructor(x, y, color) &#123;</div><div class="line">		<span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></div><div class="line">		<span class="comment">// 子类的constructor方法没有调用super之前，就使用this关键字，报错</span></div><div class="line">		<span class="keyword">super</span>(x, y);</div><div class="line">		<span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></div><div class="line">		<span class="comment">// 放在super方法之后就是正确的</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ES5中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。<br>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></div><div class="line"><span class="comment">// 子类B的__proto__属性指向父类A</span></div><div class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// 子类B的prototype属性的proto属性指向父类A的prototype属性</span></div></pre></td></tr></table></figure></p>
<p>作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；<br>作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">B</span>.proto<span class="keyword">type</span> = new <span class="type">A</span>();</div><div class="line">// 等同于</div><div class="line"><span class="type">B</span>.proto<span class="keyword">type</span>.__proto__ = <span class="type">A</span>.prototype;</div></pre></td></tr></table></figure></p>
<p>三种特殊情况。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种，子类继承Object类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Object</span> <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// A其实就是构造函数Object的复制，A的实例就是Object的实例。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二种，不存在任何继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。</span></div><div class="line"><span class="comment">// 但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span></div><div class="line"></div><div class="line"><span class="comment">// 第三种，子类继承null</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></div><div class="line"><span class="comment">// A也是一个普通函数，所以直接继承Funciton.prototype。</span></div><div class="line"><span class="comment">// 但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</div><div class="line">	constructor() &#123; <span class="keyword">return</span> <span class="type">Object</span>.create(<span class="literal">null</span>); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point <span class="comment">// true</span></div><div class="line"><span class="comment">// 父类实例和子类实例的proto属性，指向不一样</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'red'</span>);</div><div class="line"></div><div class="line">p2.__proto__ === p1.__proto <span class="comment">// false</span></div><div class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></div><div class="line"></div><div class="line">p2.__proto__.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Ha'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">p1.printName() <span class="comment">// "Ha"</span></div></pre></td></tr></table></figure>
<p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构，比如Array()。以前，这些原生构造函数是无法继承的，即不能自己定义一个Array的子类。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</div><div class="line">	<span class="keyword">constructor</span>: &#123;</div><div class="line">		value: MyArray,</div><div class="line">		writable: <span class="literal">true</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		enumerable: <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors.length <span class="comment">// 0</span></div><div class="line">colors.length = <span class="number">0</span>;</div><div class="line">colors[<span class="number">0</span>] <span class="comment">// "red"</span></div><div class="line"><span class="comment">// 因为原生构造函数无法外部获取，通过Array.apply()或者分配给原型对象都不行。</span></div><div class="line"><span class="comment">// ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</span></div></pre></td></tr></table></figure></p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">	constructor(...args) &#123;</div><div class="line">		<span class="keyword">super</span>(...args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</div><div class="line">arr.length <span class="comment">// 1</span></div><div class="line">arr.length = <span class="number">0</span>;</div><div class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></div><div class="line"><span class="comment">// 定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。</span></div><div class="line"><span class="comment">// 这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</span></div></pre></td></tr></table></figure></p>
<p>上面例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义Error子类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyError</span>(<span class="symbol">'Something</span> happened!');</div></pre></td></tr></table></figure></p>
<p>Class的静态方法：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，称为“静态方法”。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	static classMethod() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="symbol">'hell</span>o';</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">Foo</span>.classMethod() <span class="comment">// 'hello'</span></div><div class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="type">Foo</span>();</div><div class="line">foo.classMethod() <span class="comment">// TypeError: undefined is not a function</span></div><div class="line"></div><div class="line"><span class="comment">// 父类的静态方法，可以被子类继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	static classMethod() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="symbol">'hell</span>o';</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</div><div class="line"><span class="type">Bar</span>.classMethod(); <span class="comment">// 'hello'</span></div><div class="line"></div><div class="line"><span class="comment">// 静态方法也可以从super对象上调用</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	static classMethod() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="symbol">'hell</span>o';</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	static classMethod() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + ', too';</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">Bar</span>.classMethod();</div></pre></td></tr></table></figure></p>
<p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。在ES6之前，社区制定了一些模块加载方案，主要有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性：<code>var { stat, exists, readFile } = require(&#39;fs&#39;);</code>。ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式：<code>import { stat, exists, readFile } from &#39;fs&#39;;</code>所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。</p>
<p>模块功能主要由两个命令构成：export和import。export用于用户自定义模块，规定对外接口；import用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突。</p>
<p>ES6允许将独立的JS文件作为模块，允许一个JavaScript脚本文件调用另一个脚本文件。该文件内部的所有变量，外部无法获取，必须使用export关键字输出变量。下面是一个JS文件，里面使用export命令输出变量。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// profile.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="comment">// profile.js文件，保存用户信息。ES6将其视为一个模块，用export命令对外部输出了三个变量。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二种export写法</span></div><div class="line"><span class="comment">// profile.js</span></div><div class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div><div class="line"><span class="comment">// 优先考虑使用这种写法。这样可以在脚本尾部，一眼看清楚输出了哪些变量。</span></div></pre></td></tr></table></figure></p>
<p>export命令除了输出变量，还可以输出函数或类（class）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 对外输出函数multiply</span></div></pre></td></tr></table></figure></p>
<p>import命令：使用export命令定义了模块的对外接口后，其他JS文件可以通过import命令加载这个模块（文件）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="comment">// import加载profile.js文件</span></div><div class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sfirsetHeader</span>(<span class="params">element</span>) </span>&#123;</div><div class="line">	element.textContent = firstName + <span class="string">' '</span> + lastName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果想为输入的变量重新命名，import语句中使用as关键字</span></div><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> newName &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="comment">// ES6支持多重加载，即所加载的模块中又加载其他模块</span></div><div class="line"><span class="comment">// 先加载Vehicle模块</span></div><div class="line"><span class="keyword">import</span> &#123; Vehicle &#125; <span class="keyword">from</span> <span class="string">'./Vehicle'</span>;</div><div class="line"><span class="comment">// 在Vehicle基础上添加了move方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">	move () &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is spinning wheels...'</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; Car &#125;</div><div class="line"><span class="comment">// 作为一个新模块输出</span></div></pre></td></tr></table></figure></p>
<p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// circle.js文件，输出两个方法area和circumference</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js文件输入circlek.js模块</span></div><div class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"圆面积："</span> + area(<span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"圆周长："</span> + circumference(<span class="number">14</span>));</div><div class="line"><span class="comment">// 上面写法逐一指定要输入的方法</span></div><div class="line"></div><div class="line"><span class="comment">// 另一种写法是整体输入</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"圆面积："</span> + circle.area(<span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"圆周长："</span> + circle.circumference(<span class="number">14</span>));</div></pre></td></tr></table></figure>
<p>module命令可以取代import语句，达到整体输入模块<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line">module <span class="keyword">circle</span> from <span class="string">'circle'</span>;</div><div class="line"><span class="comment">// module命令后面跟一个变量，表示输入的模块定义在该变量上</span></div><div class="line">console.<span class="keyword">log</span>(<span class="string">"圆面积："</span> + <span class="keyword">circle</span>.area(<span class="number">4</span>));</div><div class="line">console.<span class="keyword">log</span>(<span class="string">"圆周长："</span> + <span class="keyword">circle</span>.circumference(<span class="number">14</span>));</div></pre></td></tr></table></figure></p>
<p>使用import需要知道所要加载的变量名或函数名，否则无法加载。export default命令，为模块指定默认输出。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 一个模块文件export-default.js，它的默认输出是一个函数</span></div><div class="line"><span class="comment">// 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字</span></div><div class="line"></div><div class="line"><span class="comment">// import-default.js</span></div><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line">customName(); <span class="comment">// 'foo'</span></div><div class="line"><span class="comment">// import命令用任意名称指向export-default.js输出的方法。这时import命令后面，不使用大括号。</span></div></pre></td></tr></table></figure></p>
<p>export default命令也可以用在非匿名函数前。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载</span></div><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</div><div class="line"><span class="comment">// 使用export default时，对应的import语句不需要使用大括号</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">import</span> &#123; crc32 &#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</div><div class="line"><span class="comment">// 不使用export default时，对应的import语句需要使用大括号</span></div></pre></td></tr></table></figure>
<p>export default命令用于指定模块的默认输出。一个模块只能有一个默认输出，export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。本质上，export default就是输出一个叫做default的变量或方法，然后系统允许为它取任意名字。所以，下面的写法是有效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// modules.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * y;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输入jQuery模块</span></div><div class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在一条import语句中，同时输入默认方法和其他变量</span></div><div class="line"><span class="keyword">import</span> customName, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将值跟在export default之后可输出默认的值</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// export default也可以用来输出类</span></div><div class="line"><span class="comment">// MyClass.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span></div><div class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line"><span class="comment">// 模块之间也可以继承。假设有一个circleplus模块，继承了circle模块</span></div><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// “export *”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。</span></div><div class="line"></div><div class="line"><span class="comment">// 也可以将circle的属性或方法，改名后再输出</span></div><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"><span class="keyword">export</span> &#123; area <span class="keyword">as</span> circleArea &#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"><span class="comment">// 只输出circle模块的area方法，且将其改名为circleArea</span></div><div class="line"></div><div class="line"><span class="comment">// 加载上面模块的写法如下</span></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="built_in">module</span> math <span class="keyword">from</span> <span class="string">"circleplus"</span>;</div><div class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">"circleplus"</span>;</div><div class="line"><span class="built_in">console</span>.log(exp(math.pi));</div><div class="line"><span class="comment">// "import exp"表示将circleplus模块的默认方法加载为exp方法</span></div></pre></td></tr></table></figure>
<p>ES6 module transpiler是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 安装这个转玛器</span></div><div class="line">$ npm install -g es6-module-transpiler</div><div class="line"></div><div class="line"><span class="comment">// 使用compile-modules convert命令，将ES6模块文件转码</span></div><div class="line">$ compile-modules convert file1<span class="selector-class">.js</span> file2<span class="selector-class">.js</span></div><div class="line"><span class="comment">// $ compile-modules convert -o out.js file1.js</span></div><div class="line"><span class="comment">// o参数指定转码后的文件名</span></div></pre></td></tr></table></figure></p>
<p>另一种解决方法是使用SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 使用时，先在网页内载入system.js文件</div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">// 然后使用System.import方法加载模块文件</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">	System.import(<span class="string">'./app'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">// ./app，指的是当前目录下的app.js文件。它可以是ES6模块文件，System.import会自动将其转码。</div></pre></td></tr></table></figure></p>
<p>需要注意的是，System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// app/es6-file.js</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">q</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		<span class="keyword">this</span>.es6 = <span class="string">'hello'</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 然后在网页内加载这个模块文件</span></div><div class="line">&lt;script&gt;</div><div class="line">	System.import(<span class="string">'app/es6-file'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">new</span> m.q().es6); <span class="comment">// hello</span></div><div class="line">	&#125;);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"><span class="comment">// System.import方法返回的是一个Promise对象，所以可以用then方法指定回调函数。</span></div></pre></td></tr></table></figure></p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by  Huangzhike </p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"> Huangzhike </a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
