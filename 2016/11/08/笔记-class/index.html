<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-class | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-class">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-class</h2>
				
				<div>
					<div class="post-time">2016-11-08</div>
				</div>
				
				<div class="article-content">
				<p><strong>2016-11-20更新</strong><br>参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a><br><a href="http://www.kancloud.cn/kancloud/es6-in-depth" target="_blank" rel="noopener">http://www.kancloud.cn/kancloud/es6-in-depth</a></p>
<ul>
<li><p>ES6的class可看作语法糖；类和模块的内部，默认是严格模式，不需要使用use strict。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">	// 定义了一个“类”，有constructor方法，这就是构造方法</span><br><span class="line">	// ES5的构造函数Point，对应ES6的Point类的构造方法</span><br><span class="line">	constructor(x, y) &#123;</span><br><span class="line">		// this关键字代表实例对象</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	// Point类除了构造方法，还定义了toString方法，不需加function</span><br><span class="line">	toString() &#123;</span><br><span class="line">		return &apos;(&apos;+this.x+&apos;, &apos;+this.y+&apos;)&apos;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 类的数据类型是函数</span><br><span class="line">typeof Point // &quot;function&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的方法（除constructor外）都定义在prototype对象上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">	constructor()&#123;&#125;</span><br><span class="line">	toString()&#123;&#125;</span><br><span class="line">	toValue()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 等同于</span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">	toString()&#123;&#125;,</span><br><span class="line">	toValue()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的内部所有定义的方法，都是不可枚举的（enumerable）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Point.prototype) // []</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class="line">// toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5不一致。</span><br><span class="line">// 采用ES5的写法，toString方法就是可枚举的</span><br><span class="line">var Point = function (x, y)&#123;&#125;</span><br><span class="line">Point.prototype.toString = function() &#123;&#125;</span><br><span class="line">Object.keys(Point.prototype) // [&quot;toString&quot;]</span><br><span class="line">Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>类的属性名，可以采用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let methodName = &quot;getArea&quot;;</span><br><span class="line">class Square&#123;</span><br><span class="line">	constructor() &#123;&#125;</span><br><span class="line">	[methodName]() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本质上，Class只是ES5的构造函数的包装，函数的许多特性都被Class继承，包括name属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;&#125;</span><br><span class="line">Point.name // &quot;Point&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与函数一样，Class也可以使用表达式定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const MyClass = class Me &#123;</span><br><span class="line">	getClassName() &#123;</span><br><span class="line">		return Me.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 类的名字是MyClass而不是Me，Me只在Class的内部用，指代当前类</span><br><span class="line">let inst = new MyClass();</span><br><span class="line">inst.getClassName() // Me</span><br><span class="line">// Me只在Class内部有定义</span><br><span class="line">Me.name // ReferenceError: Me is not defined</span><br><span class="line">// 如果Class内部没用到的话，可以省略Me</span><br><span class="line">const MyClass = class &#123; /* ... */ &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Class表达式，写立即执行Class。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let person = new class &#123;</span><br><span class="line">	constructor(name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sayName() &#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;(&quot;张三&quot;);</span><br><span class="line">// person是一个立即执行的Class的实例。</span><br><span class="line">person.sayName(); // &quot;张三&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</p>
</li>
<li>一个类必须有constructor方法，如果没有显式定义，空的constructor方法会被默认添加。</li>
<li><p>可以指定constructor方法返回另外一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		return Object.create(null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Class不存在变量提升（hoist），与ES5不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Foo(); // ReferenceError</span><br><span class="line">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Class之间通过extends关键字实现继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义ColorPoint类，通过extends，继承了Point类的所有属性和方法</span><br><span class="line">class ColorPoint extends Point &#123;&#125;</span><br><span class="line">// 由于没有部署任何代码，这两个类完全一样，等于复制了Point类</span><br><span class="line"></span><br><span class="line">// 加代码</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line"></span><br><span class="line">	constructor(x, y, color) &#123;</span><br><span class="line">		super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">		this.color = color;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	toString() &#123;</span><br><span class="line">		return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// super关键字指代父类的实例（即父类的this对象）</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。因为子类没有自己的this对象。</p>
</li>
<li>ES5的继承，实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。</li>
<li>ES6的继承不同，实质是先创造父类的实例对象this（所以必须先调用super方法），再用子类的构造函数修改this。</li>
<li><p>如果子类没有定义constructor方法，会被默认添加。不管有没有显式定义，任何子类都有constructor方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">	constructor(x, y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">	constructor(x, y, color) &#123;</span><br><span class="line">		this.color = color; // ReferenceError</span><br><span class="line">		// 子类的constructor方法没有调用super之前，使用this关键字，报错</span><br><span class="line">		super(x, y);</span><br><span class="line">		this.color = color; // 正确</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类实例和子类实例的proto属性，指向不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(ColorPoint) === Point // true</span><br><span class="line"></span><br><span class="line">var p1 = new Point(2, 3);</span><br><span class="line">var p2 = new ColorPoint(2, 3, &apos;red&apos;);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto // false</span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ // true</span><br><span class="line"></span><br><span class="line">p2.__proto__.__proto__.printName = function () &#123;</span><br><span class="line">	console.log(&apos;Ha&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() // &quot;Ha&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES5中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class同时有prototype属性和<strong>proto</strong>属性，因此存在两条继承链。<br>   （1）子类的<strong>proto</strong>属性，表示构造函数的继承，指向父类。<br>   （2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，指向父类的prototype属性。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B extends A &#123;&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A // true</span><br><span class="line">// 子类B的__proto__属性指向父类A</span><br><span class="line">B.prototype.__proto__ === A.prototype // true</span><br><span class="line">// 子类B的prototype属性的proto属性指向父类A的prototype属性</span><br><span class="line"></span><br><span class="line">B.prototype = new A();</span><br><span class="line">// 等同于</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种特殊情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 第一种，子类继承Object类</span><br><span class="line">class A extends Object &#123;&#125;</span><br><span class="line">A.__proto__ === Object // true</span><br><span class="line">A.prototype.__proto__ === Object.prototype // true</span><br><span class="line">// A其实就是构造函数Object的复制，A的实例就是Object的实例。</span><br><span class="line"></span><br><span class="line">// 第二种，不存在任何继承</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype // true</span><br><span class="line">A.prototype.__proto__ === Object.prototype // true</span><br><span class="line">// A作为一个基类（即不存在任何继承），是普通函数，直接继承Funciton.prototype。</span><br><span class="line">// 但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span><br><span class="line"></span><br><span class="line">// 第三种，子类继承null</span><br><span class="line">class A extends null &#123;&#125;</span><br><span class="line">A.__proto__ === Function.prototype // true</span><br><span class="line">A.prototype.__proto__ === null // true</span><br><span class="line">// A也是普通函数，直接继承Funciton.prototype。</span><br><span class="line">// 但是，A调用后返回的对象不继承任何方法，所以__proto__指向Function.prototype，实质上执行了下面代码</span><br><span class="line">class C extends null &#123;</span><br><span class="line">	constructor() &#123; return Object.create(null); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以前，原生构造函数是无法继承的，即不能自定义一个Array的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function MyArray() &#123;</span><br><span class="line">	Array.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class="line">	constructor: &#123;</span><br><span class="line">		value: MyArray,</span><br><span class="line">		writable: true,</span><br><span class="line">		configurable: true,</span><br><span class="line">		enumerable: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 定义了一个继承Array的MyArray类。但这个类的行为与Array完全不一致</span><br><span class="line"></span><br><span class="line">var colors = new MyArray();</span><br><span class="line">colors[0] = &quot;red&quot;;</span><br><span class="line">colors.length // 0</span><br><span class="line">// 因为原生构造函数无法外部获取，通过Array.apply()或者分配给原型对象都不行。</span><br><span class="line">// ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6允许继承原生构造函数定义子类，因为ES6先新建父类的实例对象this，再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyArray extends Array &#123;</span><br><span class="line">	constructor(...args) &#123;</span><br><span class="line">		super(...args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new MyArray();</span><br><span class="line">arr[0] = 1;</span><br><span class="line">arr.length // 1</span><br><span class="line">arr.length = 0;</span><br><span class="line">arr[0] // undefined</span><br><span class="line">// 定义了一个MyArray类，继承了Array构造函数，可以从MyArray生成数组的实例。</span><br><span class="line">// ES6可以自定义原生数据结构（比如Array、String等）的子类，ES5无法做到。</span><br></pre></td></tr></table></figure>
</li>
<li><p>上例说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 自定义Error子类</span><br><span class="line">class MyError extends Error &#123;&#125;</span><br><span class="line">throw new MyError(&apos;Something happened!&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在方法前，加上static关键字，该方法不会被实例继承，而是直接通过类来调用，称为“静态方法”。</p>
</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
