<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-Iterator-for...of | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Iterator-for...of">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Iterator-for...of</h2>
				
				<div>
					<div class="post-time">2016-11-08</div>
				</div>
				
				<div class="article-content">
				<p><strong>2016-11-20重新整理更新</strong><br>参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a><br><a href="http://www.kancloud.cn/kancloud/es6-in-depth" target="_blank" rel="noopener">http://www.kancloud.cn/kancloud/es6-in-depth</a></p>
<ul>
<li><p>数据结构Set类似数组，但成员值唯一，没有重复值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set(); // 构造函数，生成Set数据结构</span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x))</span><br><span class="line">for (i of s) &#123;console.log(i)&#125; // 2 3 5 4</span><br><span class="line">// Set接受一个数组为参数</span><br><span class="line">new Set([1, 2, 3, 4, 5, 5, 5, 5]).size // 5</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象是键值对的集合（Hash结构），但只能用字符串作键。</p>
</li>
<li>Map数据结构类似对象，也是键值对的集合，但各种类型的值（包括对象）都可以当作键。</li>
<li>Object提供“字符串—值”对应；</li>
<li><p>Map提供“值—值”对应，是更完善的Hash结构实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">var o = &#123;p: &quot;Hello World&quot;&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, &quot;content&quot;) // 使用set方法，将对象o当作m的一个键</span><br><span class="line">m.get(o) // &quot;content&quot;</span><br><span class="line"></span><br><span class="line">m.delete(o) // true</span><br><span class="line">m.has(o) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map作为构造函数接受一个数组为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map([ [&quot;name&quot;, &quot;张三&quot;], [&quot;title&quot;, &quot;Author&quot;]]);</span><br><span class="line">map.size // 2</span><br><span class="line">map.has(&quot;name&quot;) // true</span><br><span class="line">map.get(&quot;name&quot;) // &quot;张三&quot;</span><br><span class="line">map.has(&quot;title&quot;) // true</span><br><span class="line">map.get(&quot;title&quot;) // &quot;Author&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对同一个键多次赋值，后面覆盖前面</p>
</li>
<li>读取未知的键，返回undefined</li>
<li><p>只有对同一个对象的引用，Map才是同一个键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map();</span><br><span class="line"></span><br><span class="line">map.set([&apos;a&apos;], 555);</span><br><span class="line">map.get([&apos;a&apos;]) // undefined</span><br><span class="line">// 表面是对同一个键，实际上是两个值，内存地址不一样</span><br></pre></td></tr></table></figure>
</li>
<li><p>Map的键跟内存地址绑定，只要内存地址不一样，就视为两个键。</p>
</li>
<li>如果Map的键是简单类型的值（数字、字符串、布尔值），只要两个值严格相等，视为一个键，包括0和-0。</li>
<li><p>虽然NaN不严格相等于自身，Map将其视为同一个键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line"></span><br><span class="line">map.set(NaN, 123);</span><br><span class="line">map.get(NaN) // 123</span><br><span class="line"></span><br><span class="line">map.set(-0, 123);</span><br><span class="line">map.get(+0) // 123</span><br></pre></td></tr></table></figure>
</li>
<li><p>JavaScript原有“集合”的数据结构，主要是数组和对象，ES6添加了Map和Set。</p>
</li>
<li>遍历器（Iterator）是一种接口，为不同的数据结构提供统一的访问机制。</li>
<li>任何数据结构只要部署Iterator接口，就可以完成遍历操作，依次处理该数据结构的所有成员。</li>
<li>Iterator接口主要供for…of使用。</li>
<li><p>Iterator的遍历过程：</p>
<ul>
<li>创建一个指针，指向当前数据结构的起始。遍历器的返回值是指针对象，包含value和done属性。</li>
<li>其中，value属性是当前成员的值，done属性是布尔值，表示遍历是否结束。</li>
<li>第一次调用指针对象的next方法，指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的next方法，指针指向数据结构的第二个成员。</li>
<li>调用指针对象的next方法，直到指向数据结构的结束。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 模拟next方法返回值</span><br><span class="line">function makeIterator(array) &#123;</span><br><span class="line">	let nextIndex = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		next: function() &#123;</span><br><span class="line">			return nextIndex &lt; array.length ?</span><br><span class="line">				&#123;value: array[nextIndex++], done: false&#125; :</span><br><span class="line">				&#123;value: undefined, done: true&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);</span><br><span class="line">// 闭包</span><br><span class="line">it.next() // &#123; value: &quot;a&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: &quot;b&quot;, done: false &#125;</span><br><span class="line">it.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有些数据结构，如数组，原生部署System.iterator属性，被for…of循环遍历，有些不行，如对象。</p>
</li>
<li>调用这个接口，返回一个指针对象。</li>
<li><p>原生具备Iterator接口：数组、某些类数组对象、Set和Map结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// arr是数组，原生具有遍历器接口，在arr的Symbol.iterator属性上</span><br><span class="line">let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">let iter = arr[Symbol.iterator]();</span><br><span class="line">// 调用这个属性得到遍历器</span><br><span class="line">iter.next() // &#123; value: &apos;a&apos;, done: false &#125;</span><br><span class="line">iter.next() // &#123; value: &apos;b&apos;, done: false &#125;</span><br><span class="line">iter.next() // &#123; value: &apos;c&apos;, done: false &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象属性遍历顺序是不确定的，没有默认部署Iterator接口。</p>
</li>
<li>遍历器是线性处理，对于非线性的数据结构，部署遍历器接口，等于部署线性转换。</li>
<li><p>对象要有被for…of调用的Iterator接口，必须在Symbol.iterator的属性上部署遍历器方法，原型链上也行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 部署Iterator接口，Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器</span><br><span class="line">class RangeIterator &#123;</span><br><span class="line">	constructor(start, stop) &#123;</span><br><span class="line">		this.value = start;</span><br><span class="line">		this.stop = stop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[Symbol.iterator]() &#123;return this;&#125;</span><br><span class="line"></span><br><span class="line">	next() &#123;</span><br><span class="line">		let value = this.value;</span><br><span class="line">		if (value &lt; this.stop) &#123;</span><br><span class="line">			this.value++;</span><br><span class="line">			return &#123;done: false, value: value&#125;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return &#123;done: true, value: undefined&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function range(start, stop) &#123;</span><br><span class="line">	return new RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let value of range(0, 3)) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 通过遍历器实现指针结构</span><br><span class="line">function Obj(value) &#123;</span><br><span class="line">	this.value = value;</span><br><span class="line">	this.next = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator</span><br><span class="line">Obj.prototype[Symbol.iterator] = function()&#123;</span><br><span class="line">	// 调用该对象的next方法，返回值的同时，自动将内部指针移到下一个实例</span><br><span class="line">	var iterator = &#123;</span><br><span class="line">		next: next</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	var current = this;</span><br><span class="line"></span><br><span class="line">	function next()&#123;</span><br><span class="line">		if (current)&#123;</span><br><span class="line">			var value = current.value;</span><br><span class="line">			var done = current == null;</span><br><span class="line">			current = current.next;</span><br><span class="line">			return &#123;</span><br><span class="line">				done: done,</span><br><span class="line">				value: value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				done: true</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var one = new Obj(1);</span><br><span class="line">var two = new Obj(2);</span><br><span class="line">var three = new Obj(3);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line">for (let i of one)&#123;</span><br><span class="line">	console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个为对象添加Iterator接口的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">	data: [ &apos;hello&apos;, &apos;world&apos; ],</span><br><span class="line">	[Symbol.iterator]() &#123;</span><br><span class="line">		const self = this;</span><br><span class="line">		let index = 0;</span><br><span class="line">		return &#123;</span><br><span class="line">			next() &#123;</span><br><span class="line">				if (index &lt; self.data.length) &#123;</span><br><span class="line">					return &#123;</span><br><span class="line">						value: self.data[index++],</span><br><span class="line">						done: false</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					return &#123; value: undefined, done: true &#125;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于类数组对象（存在数值键名和length属性），部署Iterator接口简便方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Symbol.iterator方法返回的不是遍历器，解释引擎将会报错。</p>
</li>
<li><p>有了遍历器接口，数据结构就可以用for…of循环遍历，也可以使用while循环遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var $iterator = ITERABLE[Symbol.iterator]();</span><br><span class="line">var $result = $iterator.next();</span><br><span class="line">// ITERABLE代表可遍历的数据结构，$iterator是它的遍历器</span><br><span class="line">while (!$result.done) &#123;</span><br><span class="line">	var x = $result.value;</span><br><span class="line">	// ...</span><br><span class="line">	$result = $iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些场合会默认调用iterator接口（即Symbol.iterator方法），除了for…of循环，还有几个别的场合。</p>
<ul>
<li><p>解构赋值：对数组和Set结构进行解构赋值时，会默认调用iterator接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set().add(&apos;a&apos;).add(&apos;b&apos;).add(&apos;c&apos;);</span><br><span class="line">let [x,y] = set; // x=&apos;a&apos;; y=&apos;b&apos;</span><br><span class="line">let [first, ...rest] = set; // first=&apos;a&apos;; rest=[&apos;b&apos;,&apos;c&apos;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符：扩展运算符（…）也会调用默认的iterator接口。</p>
</li>
<li><p>只要数据结构部署了iterator接口，可以使用扩展运算符，转为数组<code>let arr = [...iterable];</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;hello&apos;;</span><br><span class="line">[...str] // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</span><br><span class="line"></span><br><span class="line">let arr = [&apos;b&apos;, &apos;c&apos;];</span><br><span class="line">[&apos;a&apos;, ...arr, &apos;d&apos;] // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yield*</span><br><span class="line">Array.from()</span><br><span class="line">Map(), Set(), WeakMap(), WeakSet()</span><br><span class="line">Promise.all(), Promise.race()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>ES6对数组提供entries()、keys()和values()三个方法，就是返回三个遍历器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 5, 7];</span><br><span class="line">var arrEntries = arr.entries();</span><br><span class="line">arrEntries.toString() // &quot;[object Array Iterator]&quot;</span><br><span class="line">arrEntries === arrEntries[Symbol.iterator]() // true</span><br><span class="line">// entries方法返回遍历器（iterator），本质上调用了Symbol.iterator方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串是类数组对象，也原生具有Iterator接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var someString = &quot;hi&quot;;</span><br><span class="line">typeof someString[Symbol.iterator] // &quot;function&quot;</span><br><span class="line">var iterator = someString[Symbol.iterator]();</span><br><span class="line">iterator.next()  // &#123; value: &quot;h&quot;, done: false &#125;</span><br><span class="line">iterator.next()  // &#123; value: &quot;i&quot;, done: false &#125;</span><br><span class="line">iterator.next()  // &#123; value: undefined, done: true &#125;</span><br><span class="line">// 调用Symbol.iterator方法返回一个遍历器，在这个遍历器上可以调用next方法，实现对于字符串的遍历。</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以覆盖原生的Symbol.iterator方法，修改遍历器行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var str = new String(&quot;hi&quot;);</span><br><span class="line">[...str] // [&quot;h&quot;, &quot;i&quot;]</span><br><span class="line"></span><br><span class="line">str[Symbol.iterator] = function() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">		next: function() &#123;</span><br><span class="line">			if (this._first) &#123;</span><br><span class="line">				this._first = false;</span><br><span class="line">				return &#123;value: &quot;bye&quot;, done: false&#125;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return &#123;done: true&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		_first: true</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">// 字符串str的Symbol.iterator方法被修改了</span><br><span class="line">[...str] // [&quot;bye&quot;]</span><br><span class="line">str // &quot;hi&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.iterator方法的最简单实现，用Generator函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[Symbol.iterator] = function* () &#123;</span><br><span class="line">	yield 1;</span><br><span class="line">	yield 2;</span><br><span class="line">	yield 3;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 简洁写法</span><br><span class="line">let obj = &#123;</span><br><span class="line">	* [Symbol.iterator]() &#123;</span><br><span class="line">		yield &apos;hello&apos;;</span><br><span class="line">		yield &apos;world&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (let x of obj) &#123;</span><br><span class="line">	console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br><span class="line">// Symbol.iterator几乎不用部署代码，用yield命令给出每一步返回值</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历器返回的指针对象除了next方法，还可以有return和throw方法。</p>
</li>
<li>next方法是必须的，return和throw方法是可选的。</li>
<li>如果for…of循环提前退出（因为出错，break或continue语句），就会调用return方法。</li>
<li>如果一个对象在完成遍历前，需要清理或释放资源，可以部署return方法。</li>
<li><p>throw方法主要配合Generator函数使用。</p>
</li>
<li><p>for…of循环使用范围包括数组、Set和Map结构、某些类数组对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 数组原生具备iterator接口，for...of循环调用这个接口产生的遍历器，证明：</span><br><span class="line">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class="line">let iterator = arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">for(let v of arr) &#123;</span><br><span class="line">	console.log(v); // red green blue</span><br><span class="line">&#125;</span><br><span class="line">// 等价</span><br><span class="line">for(let v of iterator) &#123;</span><br><span class="line">	console.log(v); // red green blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…of循环可代替数组实例的forEach方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];</span><br><span class="line"></span><br><span class="line">arr.forEach(function (element, index) &#123;</span><br><span class="line">	console.log(element); // red green blue</span><br><span class="line">	console.log(index); // 0 1 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…in循环，只能获得对象的键名，不能直接获取键值。for…of循环，允许遍历获得键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</span><br><span class="line">// for...in循环读取键名</span><br><span class="line">for (a in arr) &#123;</span><br><span class="line">	console.log(a); // 0 1 2 3</span><br><span class="line">&#125;</span><br><span class="line">// for...of循环读取键值</span><br><span class="line">for (a of arr) &#123;</span><br><span class="line">	console.log(a); // a b c d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Set和Map结构也原生具有Iterator接口，可直接使用for…of循环；</p>
</li>
<li>遍历顺序是各个成员被添加进数据结构的顺序；</li>
<li>Set结构遍历时，返回一个值；</li>
<li><p>Map结构遍历时，返回一个数组，两个成员分别为当前的键名和键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);</span><br><span class="line">for (var e of engines) &#123;</span><br><span class="line">	console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// Gecko</span><br><span class="line">// Trident</span><br><span class="line">// Webkit</span><br><span class="line"></span><br><span class="line">let map = new Map().set(&apos;a&apos;, 1).set(&apos;b&apos;, 2);</span><br><span class="line">for (let pair of map) &#123;</span><br><span class="line">	console.log(pair);</span><br><span class="line">&#125;</span><br><span class="line">// [&apos;a&apos;, 1]</span><br><span class="line">// [&apos;b&apos;, 2]</span><br><span class="line"></span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">	console.log(key + &apos; : &apos; + value);</span><br><span class="line">&#125;</span><br><span class="line">// a : 1</span><br><span class="line">// b : 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6的Array、Set、Map都部署了以下三个方法，调用后都返回遍历器。</p>
<ul>
<li>entries() 返回一个遍历器，用来遍历 [键名, 键值] 组成的数组。<ul>
<li>对于数组，键名就是索引值；对于Set，键名与键值相同。Map的iterator接口，默认调用entries。</li>
</ul>
</li>
<li>keys() 返回一个遍历器，用来遍历所有的键名。</li>
<li>values() 返回一个遍历器，用来遍历所有的键值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">for (let pair of arr.entries()) &#123;</span><br><span class="line">	console.log(pair);</span><br><span class="line">&#125;</span><br><span class="line">// [0, &apos;a&apos;]</span><br><span class="line">// [1, &apos;b&apos;]</span><br><span class="line">// [2, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类数组对象包括字符串、DOM NodeList对象、arguments对象等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 字符串</span><br><span class="line">let str = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">for (let s of str) &#123;</span><br><span class="line">	console.log(s); // h e l l o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// DOM NodeList对象</span><br><span class="line">let paras = document.querySelectorAll(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">for (let p of paras) &#123;</span><br><span class="line">	p.classList.add(&quot;test&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line">function printArgs() &#123;</span><br><span class="line">	for (let x of arguments) &#123;</span><br><span class="line">		console.log(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不是所有类数组对象都有iterator接口，使用Array.from方法将其转为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123; length: 2, 0: &apos;a&apos;, 1: &apos;b&apos; &#125;;</span><br><span class="line">// 报错</span><br><span class="line">for (let x of arrayLike) &#123;</span><br><span class="line">	console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// 正确</span><br><span class="line">for (let x of Array.from(arrayLike)) &#123;</span><br><span class="line">	console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>普通对象必须部署了iterator接口后才能用for…of，for…in循环依然可以遍历键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var es6 = &#123;</span><br><span class="line">	edition: 6,</span><br><span class="line">	committee: &quot;TC39&quot;,</span><br><span class="line">	standard: &quot;ECMA-262&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (e in es6) &#123;</span><br><span class="line">	console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// edition</span><br><span class="line">// committee</span><br><span class="line">// standard</span><br><span class="line"></span><br><span class="line">for (e of es6) &#123;</span><br><span class="line">	console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">// TypeError: es6 is not iterable</span><br></pre></td></tr></table></figure>
</li>
<li><p>一种解决方法是，用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var key of Object.keys(someObject)) &#123;</span><br><span class="line">	console.log(key + &quot;: &quot; + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对象上部署iterator接口的代码，一个方法是将数组的Symbol.iterator属性，直接赋值给其他对象的Symbol.iterator属性</p>
</li>
<li><p>如，让for…of循环遍历jQuery对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个方法是用Generator函数将对象重新包装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* entries(obj) &#123;</span><br><span class="line">	for (let key of Object.keys(obj)) &#123;</span><br><span class="line">		yield [key, obj[key]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let [key, value] of entries(obj)) &#123;</span><br><span class="line">	console.log(key, &quot;-&gt;&quot;, value);</span><br><span class="line">&#125;</span><br><span class="line">// a -&gt; 1</span><br><span class="line">// b -&gt; 2</span><br><span class="line">// c -&gt; 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>以数组为例，JavaScript提供多种遍历。</p>
</li>
<li><p>for循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var index = 0; index &lt; myArray.length; index++) &#123;</span><br><span class="line">	console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(function (value) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">// 无法中途跳出forEach循环，break或return都不能</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…in循环遍历数组键名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var index in myArray) &#123;</span><br><span class="line">	console.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…in主要遍历对象，不适用于遍历数组</p>
<ul>
<li>1）数组的键名是数字，但for…in以字符串为键名“0”、“1”等</li>
<li>2）for…in不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键</li>
<li>3）某些情况下，for…in循环以任意顺序遍历键名</li>
</ul>
</li>
<li><p>for…of可以与break、continue和return配合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let value of myArray) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出斐波纳契数列小于等于1000的项。如果当前项大于1000，break跳出for…of循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var n of fibonacci) &#123;</span><br><span class="line">	if (n &gt; 1000)</span><br><span class="line">		break;</span><br><span class="line">	console.log(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
