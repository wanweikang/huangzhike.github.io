<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-Iterator-for...of | 一切都沉淀为笔记</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="一个放笔记的地方">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Iterator-for...of"/>
		
		<meta property="og:site_name" content="一切都沉淀为笔记"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一切都沉淀为笔记 <span>Talk is cheap, show me the code</span></a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="/resume" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Iterator-for...of</h2>
				
				<div>
					<span class="post-time">2016-11-08 12:22</span>
				</div>	
				
				<div class="article-content">
				<p><strong>2016-11-16更新</strong><br>参考：<br><a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a><br><a href="http://www.kancloud.cn/kancloud/es6-in-depth" target="_blank" rel="external">http://www.kancloud.cn/kancloud/es6-in-depth</a></p>
<ul>
<li><p>ES6提供了新的数据结构Set。它类似数组，但成员的值唯一，没有重复值。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = new Set(); <span class="comment">// Set是构造函数，生成Set数据结构</span></div><div class="line"></div><div class="line">[<span class="number">2</span> ,<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].map(x =&gt; s.add(x))</div><div class="line">for (i of s) &#123;console.log(i)&#125; <span class="comment">// 2 3 5 4</span></div><div class="line"></div><div class="line">var items = new Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]); <span class="comment">// Set接受一个数组为参数</span></div><div class="line">items.size <span class="comment">// 5</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象（Object）是键值对的集合（Hash结构），但只能用字符串当作键。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">data</span> = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> element = document.getElementById(<span class="string">"myDiv"</span>);</div><div class="line"><span class="keyword">data</span>[element] = metadata; <span class="comment">// 代码原意是将DOM节点作为对象data的键</span></div><div class="line"><span class="keyword">data</span>[<span class="string">"[Object HTMLDivElement]"</span>] <span class="comment">// metadata</span></div><div class="line"><span class="comment">// 对象只接受字符串作为键名，element被自动转为字符串[Object HTMLDivElement]。</span></div></pre></td></tr></table></figure>
</li>
<li><p>ES6提供了Map数据结构。它类似对象，也是键值对的集合，但各种类型的值（包括对象）都可以当作键。</p>
</li>
<li>Object提供“字符串—值”对应；</li>
<li>Map提供“值—值”对应，是更完善的Hash结构实现。<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="keyword">var</span> o = &#123;p: <span class="string">"Hello World"</span>&#125;;</div><div class="line"></div><div class="line">m.<span class="keyword">set</span>(o, <span class="string">"content"</span>) <span class="comment">// 使用set方法，将对象o当作m的一个键</span></div><div class="line">m.<span class="keyword">get</span>(o) <span class="comment">// "content"</span></div><div class="line"></div><div class="line">m.has(o) <span class="comment">// true</span></div><div class="line">m.delete(o) <span class="comment">// true</span></div><div class="line">m.has(o) <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>Map作为构造函数可接受一个数组作为参数。该数组的成员是表示键值对的数组。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([ [<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</div><div class="line"><span class="comment">// 在新建Map实例时，就指定了两个键name和title</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">size</span> <span class="comment">// 2</span></div><div class="line"><span class="built_in">map</span>.has(<span class="string">"name"</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>) <span class="comment">// "张三"</span></div><div class="line"><span class="built_in">map</span>.has(<span class="string">"title"</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"title"</span>) <span class="comment">// "Author"</span></div><div class="line"></div><div class="line"><span class="comment">// 如果对同一个键多次赋值，后面的值覆盖前面的值</span></div><div class="line">let <span class="built_in">map</span> = <span class="keyword">new</span> Map();</div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">'aaa'</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">1</span>, <span class="string">'bbb'</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="number">1</span>) <span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="comment">// 如果读取一个未知的键，则返回undefined</span></div><div class="line"><span class="keyword">new</span> Map().<span class="built_in">get</span>(<span class="string">'asfddfsasadf'</span>) <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 注意，只有对同一个对象的引用，Map结构才将其视为同一个键</span></div><div class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="string">'a'</span>]) <span class="comment">// undefined</span></div><div class="line"><span class="comment">// 上面代码的set和get方法，表面是针对同一个键，实际上这是两个值，内存地址是不一样的</span></div><div class="line"></div><div class="line"><span class="comment">// 同样的值的两个实例，在Map结构中被视为两个键</span></div><div class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</div><div class="line"></div><div class="line">var k1 = [<span class="string">'a'</span>];</div><div class="line">var k2 = [<span class="string">'a'</span>];</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(k1, <span class="number">111</span>);</div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(k2, <span class="number">222</span>);</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k1) <span class="comment">// 111</span></div><div class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(k2) <span class="comment">// 222</span></div></pre></td></tr></table></figure></p>
<p>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这解决了同名属性碰撞（clash）的问题，扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">NaN</span>, <span class="number">123</span>);</div><div class="line"><span class="built_in">map</span>.get(<span class="number">NaN</span>) <span class="comment">// 123</span></div><div class="line"></div><div class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">-0</span>, <span class="number">123</span>);</div><div class="line"><span class="built_in">map</span>.get(+<span class="number">0</span>) <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p>
<p>Iterator的遍历过程是这样的：<br>（1）创建一个指针，指向当前数据结构的起始位置。即，遍历器的返回值是一个指针对象。<br>（2）第一次调用指针对象的next方法，指针指向数据结构的第一个成员。<br>（3）第二次调用指针对象的next方法，指针指向数据结构的第二个成员。<br>（4）调用指针对象的next方法，直到指向数据结构的结束位置。</p>
<p>每一次调用next方法，都会返回当前成员的信息，具体来说，返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 模拟<span class="built_in">next</span>方法返回值</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span><span class="params">(array)</span></span>&#123;</div><div class="line">	let nextIndex = <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="built_in">next</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> nextIndex &lt; array.length ?</div><div class="line">				&#123;value: array[nextIndex++], done: <span class="keyword">false</span>&#125; :</div><div class="line">				&#123;value: undefined, done: <span class="keyword">true</span>&#125;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"></div><div class="line">it.<span class="built_in">next</span>() // &#123; value: <span class="string">"a"</span>, done: <span class="keyword">false</span> &#125;</div><div class="line">it.<span class="built_in">next</span>() // &#123; value: <span class="string">"b"</span>, done: <span class="keyword">false</span> &#125;</div><div class="line">it.<span class="built_in">next</span>() // &#123; value: undefined, done: <span class="keyword">true</span> &#125;</div><div class="line">// 定义了一个makeIterator函数，它的作用就是返回数组的指针对象。对数组[<span class="string">'a'</span>, <span class="string">'b'</span>]执行这个函数，就会返回该数组的指针对象it。</div><div class="line">// 指针对象的<span class="built_in">next</span>方法，用来移动指针。开始时，指针指向数组的开始位置。</div><div class="line">// 然后，每次调用<span class="built_in">next</span>方法，指针就会指向数组的下一个成员。</div><div class="line">// 第一次调用，指向a；第二次调用，指向b。</div><div class="line">// 总之，指针对象具有<span class="built_in">next</span>方法。调用<span class="built_in">next</span>方法，就可以遍历事先给定的数据结构。</div></pre></td></tr></table></figure></p>
<p>由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器，或者说用遍历器模拟出数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个无限运行的遍历器例子</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">idMaker</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> it = idMaker();</div><div class="line"></div><div class="line">it.next().value <span class="comment">// '0'</span></div><div class="line">it.next().value <span class="comment">// '1'</span></div><div class="line">it.next().value <span class="comment">// '2'</span></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure></p>
<p>在ES6中，有些数据结构原生提供遍历器（比如数组），不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了System.iterator属性，有些没有。凡是部署了System.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个指针对象。ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="built_in">let</span> iter = arr[Symbol.iterator]();</div><div class="line"></div><div class="line">iter.next() // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</div><div class="line">iter.next() // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</div><div class="line">iter.next() // &#123; value: <span class="string">'c'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</div><div class="line">iter.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</div><div class="line">// 变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。调用这个属性，就得到遍历器。</div></pre></td></tr></table></figure></p>
<p>原生就部署iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。</p>
<p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。一个对象如果要有可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器方法（原型链上的对象具有该方法也可）。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个类部署Iterator接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器。</span></div><div class="line"><span class="keyword">class</span> <span class="title">RangeIterator</span> &#123;</div><div class="line">	constructor(start, stop) &#123;</div><div class="line">		<span class="keyword">this</span>.<span class="keyword">value</span> = start;</div><div class="line">		<span class="keyword">this</span>.stop = stop;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	[Symbol.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</div><div class="line"></div><div class="line">	next() &#123;</div><div class="line">		<span class="keyword">let</span> <span class="keyword">value</span> = <span class="keyword">this</span>.<span class="keyword">value</span>;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="keyword">this</span>.stop) &#123;</div><div class="line">			<span class="keyword">this</span>.<span class="keyword">value</span>++;</div><div class="line">			<span class="keyword">return</span> &#123;done: <span class="literal">false</span>, <span class="keyword">value</span>: <span class="keyword">value</span>&#125;;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> &#123;done: <span class="literal">true</span>, <span class="keyword">value</span>: undefined&#125;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">function <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="function"><span class="keyword">let</span> <span class="keyword">value</span> of <span class="title">range</span>(<span class="params"><span class="number">0</span>, <span class="number">3</span></span>)) </span>&#123;</div><div class="line">	console.log(<span class="keyword">value</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过遍历器实现指针结构</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.value = value;</div><div class="line">	<span class="keyword">this</span>.next = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator</span></div><div class="line"><span class="comment">// 调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例</span></div><div class="line">Obj.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> iterator = &#123;</div><div class="line">		<span class="attr">next</span>: next</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> current = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> (current)&#123;</div><div class="line">			<span class="keyword">var</span> value = current.value;</div><div class="line">			<span class="keyword">var</span> done = current == <span class="literal">null</span>;</div><div class="line">			current = current.next;</div><div class="line">			<span class="keyword">return</span> &#123;</div><div class="line">				<span class="attr">done</span>: done,</div><div class="line">				<span class="attr">value</span>: value</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> &#123;</div><div class="line">				<span class="attr">done</span>: <span class="literal">true</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> iterator;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Obj(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Obj(<span class="number">2</span>);</div><div class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Obj(<span class="number">3</span>);</div><div class="line"></div><div class="line">one.next = two;</div><div class="line">two.next = three;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> one)&#123;</div><div class="line">	<span class="built_in">console</span>.log(i)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="comment">// 另一个为对象添加Iterator接口的例子</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">	<span class="attr">data</span>: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</div><div class="line">	[<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">		<span class="keyword">const</span> self = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">let</span> index = <span class="number">0</span>;</div><div class="line">		<span class="keyword">return</span> &#123;</div><div class="line">			next() &#123;</div><div class="line">				<span class="keyword">if</span> (index &lt; self.data.length) &#123;</div><div class="line">					<span class="keyword">return</span> &#123;</div><div class="line">						<span class="attr">value</span>: self.data[index++],</div><div class="line">						<span class="attr">done</span>: <span class="literal">false</span></div><div class="line">					&#125;;</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于类数组对象（存在数值键名和length属性），部署Iterator接口，一个简便方法，就是Symbol.iterator方法直接引用数值的Iterator接口。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</div><div class="line"></div><div class="line"><span class="comment">// 如果Symbol.iterator方法返回的不是遍历器，解释引擎将会报错。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"></div><div class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</div><div class="line">[...obj] <span class="comment">// TypeError: [] is not a function</span></div><div class="line"><span class="comment">// 变量obj的Symbol.iterator方法返回的不是遍历器，因此报错。</span></div></pre></td></tr></table></figure></p>
<p>有了遍历器接口，数据结构就可以用for…of循环遍历（详见下文），也可以使用while循环遍历。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var <span class="variable">$iterator</span> = ITERABLE[Symbol.iterator]();</div><div class="line">var <span class="variable">$result</span> = <span class="variable">$iterator</span>.<span class="keyword">next</span>();</div><div class="line"><span class="keyword">while</span> (!<span class="variable">$result</span>.done) &#123;</div><div class="line">	var x = <span class="variable">$result</span>.value;</div><div class="line">	<span class="regexp">//</span> ...</div><div class="line">	<span class="variable">$result</span> = <span class="variable">$iterator</span>.<span class="keyword">next</span>();</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> ITERABLE代表某种可遍历的数据结构，<span class="variable">$iterator</span>是它的遍历器。</div><div class="line"><span class="regexp">//</span> 遍历器每次移动指针（<span class="keyword">next</span>方法），都检查一下返回值的done属性，如果遍历还没结束，就移动遍历器的指针到下一步（<span class="keyword">next</span>方法），不断循环。</div></pre></td></tr></table></figure></p>
<p>有一些场合会默认调用iterator接口（即Symbol.iterator方法），除了for…of循环，还有几个别的场合。<br>（1）解构赋值：对数组和Set结构进行解构赋值时，会默认调用iterator接口。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set().<span class="keyword">add</span>(<span class="string">'a'</span>).<span class="keyword">add</span>(<span class="string">'b'</span>).<span class="keyword">add</span>(<span class="string">'c'</span>);</div><div class="line"><span class="keyword">let</span> [x,y] = <span class="keyword">set</span>; <span class="comment">// x='a'; y='b'</span></div><div class="line"><span class="keyword">let</span> [first, ...rest] = <span class="keyword">set</span>; <span class="comment">// first='a'; rest=['b','c'];</span></div></pre></td></tr></table></figure></p>
<p>（2）扩展运算符：扩展运算符（…）也会调用默认的iterator接口。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 例一</div><div class="line">var str = <span class="string">'hello'</span>;</div><div class="line">[...str] //  [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>]</div><div class="line"></div><div class="line">// 例二</div><div class="line">let arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>] // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"></div><div class="line">// 只要某个数据结构部署了iterator接口，就可以对它使用扩展运算符，将其转为数组</div><div class="line">let arr = [...iterable];</div></pre></td></tr></table></figure></p>
<p>（3）其他场合<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">yield</span>*</div><div class="line"><span class="built_in">Array</span>.from()</div><div class="line"><span class="built_in">Map</span>(), <span class="built_in">Set</span>(), <span class="built_in">WeakMap</span>(), <span class="built_in">WeakSet</span>()</div><div class="line"><span class="built_in">Promise</span>.all(), <span class="built_in">Promise</span>.race()</div></pre></td></tr></table></figure></p>
<p>原生具备Iterator接口的数据结构<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// ES6对数组提供entries()、keys()和values()三个方法，就是返回三个遍历器</div><div class="line">var arr = [1, 5, 7];</div><div class="line">var arrEntries = arr.entries();</div><div class="line">arrEntries.toString() // "[object Array Iterator]"</div><div class="line">arrEntries === arrEntries[<span class="string">Symbol.iterator</span>](<span class="link"></span>) // true</div><div class="line">// entries方法返回的是一个遍历器（iterator），本质上就是调用了Symbol.iterator方法</div></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 字符串是一个类数组对象，也原生具有<span class="type">Iterator</span>接口。</div><div class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</div><div class="line">typeof someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] // <span class="string">"function"</span></div><div class="line"><span class="keyword">var</span> <span class="keyword">iterator</span> = someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</div><div class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"h"</span>, done: <span class="literal">false</span> &#125;</div><div class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"i"</span>, done: <span class="literal">false</span> &#125;</div><div class="line"><span class="keyword">iterator</span>.next()  // &#123; value: undefined, done: <span class="literal">true</span> &#125;</div><div class="line">// 调用<span class="type">Symbol</span>.<span class="keyword">iterator</span>方法返回一个遍历器，在这个遍历器上可以调用next方法，实现对于字符串的遍历。</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以覆盖原生的Symbol.iterator方法，修改遍历器行为</span></div><div class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>);</div><div class="line"></div><div class="line">[...str] <span class="comment">// ["h", "i"]</span></div><div class="line"></div><div class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</div><div class="line">				<span class="keyword">this</span>._first = <span class="literal">false</span>;</div><div class="line">				<span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">"bye"</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		<span class="attr">_first</span>: <span class="literal">true</span></div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">[...str] <span class="comment">// ["bye"]</span></div><div class="line">str <span class="comment">// "hi"</span></div><div class="line"><span class="comment">// 字符串str的Symbol.iterator方法被修改了，扩展运算符（...）返回的值变成了bye，而字符串本身还是hi。</span></div></pre></td></tr></table></figure>
<p>Symbol.iterator方法的最简单实现，是使用Generator函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</div><div class="line"></div><div class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></div><div class="line"></div><div class="line"><span class="comment">// 或者采用下面的简洁写法</span></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">	* [<span class="built_in">Symbol</span>.iterator]() &#123;</div><div class="line">		<span class="keyword">yield</span> <span class="string">'hello'</span>;</div><div class="line">		<span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</div><div class="line">	<span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// hello</span></div><div class="line"><span class="comment">// world</span></div><div class="line"><span class="comment">// Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。</span></div></pre></td></tr></table></figure></p>
<p>遍历器返回的指针对象除了具有next方法，还可以有return方法和throw方法。其中，next方法是必须的，return方法和throw方法是可选的。return方法：如果for…of循环提前退出（通常因为出错，break或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。throw方法主要是配合Generator函数使用，一般的遍历器用不到这个方法。</p>
<p>for…of循环：ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator方法，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。for…of循环可以使用的范围包括数组、Set和Map结构、某些类数组对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组原生具备iterator接口，for...of循环本质上就是调用这个接口产生的遍历器，下面的代码证明。</span></div><div class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"><span class="keyword">let</span> iterator  = arr[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</div><div class="line">	<span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 等价</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> iterator) &#123;</div><div class="line">	<span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for...of循环可以代替数组实例的forEach方法</span></div><div class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</div><div class="line"></div><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(element); <span class="comment">// red green blue</span></div><div class="line">	<span class="built_in">console</span>.log(index); <span class="comment">// 0 1 2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>...<span class="keyword">in</span>循环，只能获得对象的键名，不能直接获取键值。<span class="keyword">for</span>...of循环，允许遍历获得键值</div><div class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</div><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>...<span class="keyword">in</span>循环读取键名</div><div class="line"><span class="keyword">for</span> (a <span class="keyword">in</span> arr) &#123;</div><div class="line">	console.log(a); <span class="regexp">//</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>...of循环读取键值</div><div class="line"><span class="keyword">for</span> (a of arr) &#123;</div><div class="line">	console.log(a); <span class="regexp">//</span> a b c d</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set和Map结构也原生具有Iterator接口，可以直接使用for...of循环</span></div><div class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</div><div class="line">	<span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Gecko</span></div><div class="line"><span class="comment">// Trident</span></div><div class="line"><span class="comment">// Webkit</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</div><div class="line">	<span class="built_in">console</span>.log(pair);</div><div class="line">&#125;</div><div class="line"><span class="comment">// ['a', 1]</span></div><div class="line"><span class="comment">// ['b', 2]</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">	<span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// a : 1</span></div><div class="line"><span class="comment">// b : 2</span></div><div class="line"></div><div class="line"><span class="comment">// 遍历的顺序是按照各个成员被添加进数据结构的顺序</span></div><div class="line"><span class="comment">// Set结构遍历时，返回的是一个值</span></div><div class="line"><span class="comment">// Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值</span></div></pre></td></tr></table></figure>
<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器。<br>entries() 返回一个遍历器，用来遍历 [键名, 键值] 组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法。<br>keys() 返回一个遍历器，用来遍历所有的键名。<br>values() 返回一个遍历器，用来遍历所有的键值。<br>这三个方法调用后生成的遍历器，所遍历的都是计算生成的数据结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</div><div class="line">	<span class="built_in">console</span>.log(pair);</div><div class="line">&#125;</div><div class="line"><span class="comment">// [0, 'a']</span></div><div class="line"><span class="comment">// [1, 'b']</span></div><div class="line"><span class="comment">// [2, 'c']</span></div></pre></td></tr></table></figure></p>
<p>类数组对象包括好几类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for...of循环用于字符串、DOM NodeList对象、arguments对象</span></div><div class="line"><span class="comment">// 字符串</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</div><div class="line">	<span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DOM NodeList对象</span></div><div class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</div><div class="line">	p.classList.add(<span class="string">"test"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// arguments对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</div><div class="line">		<span class="built_in">console</span>.log(x);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>);</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div></pre></td></tr></table></figure></p>
<p>并不是所有类似数组的对象都具有iterator接口，一个解决方法，就是使用Array.from方法将其转为数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</div><div class="line">	<span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</div><div class="line">	<span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。这样情况下，for…in循环依然可以遍历键名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> es6 = &#123;</div><div class="line">	<span class="attr">edition</span>: <span class="number">6</span>,</div><div class="line">	<span class="attr">committee</span>: <span class="string">"TC39"</span>,</div><div class="line">	<span class="attr">standard</span>: <span class="string">"ECMA-262"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (e <span class="keyword">in</span> es6) &#123;</div><div class="line">	<span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="comment">// edition</span></div><div class="line"><span class="comment">// committee</span></div><div class="line"><span class="comment">// standard</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (e <span class="keyword">of</span> es6) &#123;</div><div class="line">	<span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="comment">// TypeError: es6 is not iterable</span></div><div class="line"></div><div class="line"><span class="comment">// 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</div><div class="line">	<span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在对象上部署iterator接口的代码，一个方便的方法是将数组的Symbol.iterator属性，直接赋值给其他对象的Symbol.iterator属性</span></div><div class="line"><span class="comment">// 比如，想要让for...of循环遍历jQuery对象，只要加上下面一行就可以了</span></div><div class="line">jQuery.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator];</div><div class="line"></div><div class="line"><span class="comment">// 另一个方法是使用Generator函数将对象重新包装</span></div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</div><div class="line">		<span class="keyword">yield</span> [key, obj[key]];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</div><div class="line">	<span class="built_in">console</span>.log(key, <span class="string">"-&gt;"</span>, value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// a -&gt; 1</span></div><div class="line"><span class="comment">// b -&gt; 2</span></div><div class="line"><span class="comment">// c -&gt; 3</span></div></pre></td></tr></table></figure></p>
<p>以数组为例，JavaScript提供多种遍历语法。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>循环</div><div class="line"><span class="keyword">for</span> (var index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</div><div class="line">	console.log(myArray[index]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="regexp">//</span> forEach方法</div><div class="line">myArray.forEach(<span class="keyword">function</span> (value) &#123;</div><div class="line">	console.log(value);</div><div class="line">&#125;);</div><div class="line"><span class="regexp">//</span> 问题在于，无法中途跳出forEach循环，<span class="keyword">break</span>命令或return命令都不能奏效。</div><div class="line"></div><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>...<span class="keyword">in</span>循环可以遍历数组的键名</div><div class="line"><span class="keyword">for</span> (var index <span class="keyword">in</span> myArray) &#123;</div><div class="line">	console.log(myArray[index]);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 缺点，<span class="keyword">for</span>...<span class="keyword">in</span>循环主要是为遍历对象而设计的，不适用于遍历数组</div><div class="line"><span class="regexp">//</span> <span class="number">1</span>）数组的键名是数字，但是<span class="keyword">for</span>...<span class="keyword">in</span>循环是以字符串作为键名“<span class="number">0</span>”、“<span class="number">1</span>”、“<span class="number">2</span>”等等</div><div class="line"><span class="regexp">//</span> <span class="number">2</span>）<span class="keyword">for</span>...<span class="keyword">in</span>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键</div><div class="line"><span class="regexp">//</span> <span class="number">3</span>）某些情况下，<span class="keyword">for</span>...<span class="keyword">in</span>循环会以任意顺序遍历键名</div><div class="line"></div><div class="line"><span class="regexp">//</span> <span class="keyword">for</span>...of</div><div class="line"><span class="keyword">for</span> (let value of myArray) &#123;</div><div class="line">	console.log(value);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 不同于forEach方法，它可以与<span class="keyword">break</span>、<span class="keyword">continue</span>和return配合使用</div><div class="line"><span class="keyword">for</span> (var n of fibonacci) &#123;</div><div class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	console.log(n);</div><div class="line">&#125;</div><div class="line"><span class="regexp">//</span> 输出斐波纳契数列小于等于<span class="number">1000</span>的项。如果当前项大于<span class="number">1000</span>，<span class="keyword">break</span>语句跳出<span class="keyword">for</span>...of循环</div></pre></td></tr></table></figure></p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by  Huangzhike </p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"> Huangzhike </a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
