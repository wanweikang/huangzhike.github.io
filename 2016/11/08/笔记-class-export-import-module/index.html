<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-class-export-import-module | 一切都沉淀为笔记</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="一个放笔记的地方">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-class-export-import-module"/>
		
		<meta property="og:site_name" content="一切都沉淀为笔记"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一切都沉淀为笔记 <span>Talk is cheap, show me the code</span></a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="/resume" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-class-export-import-module</h2>
				
				<div>
					<span class="post-time">2016-11-08 12:22</span>
				</div>	
				
				<div class="article-content">
				<p><strong>2016-11-16更新</strong></p>
<ul>
<li><p>ES6的class可看作语法糖；类和模块的内部，默认是严格模式，不需要使用use strict。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="comment">// 定义了一个“类”，有constructor方法，这就是构造方法</span></div><div class="line">	<span class="comment">// ES5的构造函数Point，对应ES6的Point类的构造方法</span></div><div class="line">	<span class="keyword">constructor</span>(x, y) &#123;</div><div class="line">		<span class="comment">// this关键字代表实例对象</span></div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.y = y;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Point类除了构造方法，还定义了toString方法，不需加function</span></div><div class="line">	toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">'('</span>+<span class="keyword">this</span>.x+<span class="string">', '</span>+<span class="keyword">this</span>.y+<span class="string">')'</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 类的数据类型是函数</span></div><div class="line">typeof Point <span class="comment">// "function"</span></div></pre></td></tr></table></figure>
</li>
<li><p>类的方法（除constructor外）都定义在prototype对象上</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class <span class="keyword">Point</span> &#123;</div><div class="line">	constructor()&#123;&#125;</div><div class="line">	toString()&#123;&#125;</div><div class="line">	toValue()&#123;&#125;</div><div class="line">&#125;</div><div class="line">// 等同于</div><div class="line"><span class="keyword">Point</span>.prototype = &#123;</div><div class="line">	toString()&#123;&#125;,</div><div class="line">	toValue()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>类的内部所有定义的方法，都是不可枚举的（enumerable）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// []</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span></div><div class="line"><span class="comment">// toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5不一致。</span></div><div class="line"><span class="comment">// 采用ES5的写法，toString方法就是可枚举的</span></div><div class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;&#125;</div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// ["toString"]</span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span></div></pre></td></tr></table></figure>
</li>
<li><p>类的属性名，可以采用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> methodName = <span class="string">"getArea"</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;&#125;</div><div class="line">	[methodName]() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>本质上，Class只是ES5的构造函数的包装，函数的许多特性都被Class继承，包括name属性。</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class <span class="keyword">Point</span> &#123;&#125;</div><div class="line"><span class="keyword">Point</span>.name // <span class="string">"Point"</span></div></pre></td></tr></table></figure>
</li>
<li><p>与函数一样，Class也可以使用表达式定义</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MyClass = <span class="keyword">class</span> <span class="title">Me</span> &#123;</div><div class="line">	getClassName() &#123;</div><div class="line">		<span class="keyword">return</span> Me.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 类的名字是MyClass而不是Me，Me只在Class的内部用，指代当前类</span></div><div class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</div><div class="line">inst.getClassName() <span class="comment">// Me</span></div><div class="line"><span class="comment">// Me只在Class内部有定义</span></div><div class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></div><div class="line"><span class="comment">// 如果Class内部没用到的话，可以省略Me</span></div><div class="line"><span class="keyword">const</span> MyClass = <span class="keyword">class</span> &#123; <span class="comment">/* ... */</span> &#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>Class表达式，写立即执行Class。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sayName() &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;(<span class="string">"张三"</span>);</div><div class="line"><span class="comment">// person是一个立即执行的Class的实例。</span></div><div class="line">person.sayName(); <span class="comment">// "张三"</span></div></pre></td></tr></table></figure>
</li>
<li><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</p>
</li>
<li>一个类必须有constructor方法，如果没有显式定义，空的constructor方法会被默认添加。</li>
<li><p>可以指定constructor方法返回另外一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>Class不存在变量提升（hoist），与ES5不同。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="type">Foo</span>(); <span class="comment">// ReferenceError</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Class之间通过extends关键字实现继承。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义ColorPoint类，通过extends，继承了Point类的所有属性和方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// 由于没有部署任何代码，这两个类完全一样，等于复制了Point类</span></div><div class="line"></div><div class="line"><span class="comment">// 加代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">	constructor(x, y, color) &#123;</div><div class="line">		<span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></div><div class="line">		<span class="keyword">this</span>.color = color;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	toString() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// super关键字指代父类的实例（即父类的this对象）</span></div></pre></td></tr></table></figure>
</li>
<li><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。因为子类没有自己的this对象。</p>
</li>
<li>ES5的继承，实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。</li>
<li>ES6的继承不同，实质是先创造父类的实例对象this（所以必须先调用super方法），再用子类的构造函数修改this。</li>
<li><p>如果子类没有定义constructor方法，会被默认添加。不管有没有显式定义，任何子类都有constructor方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	constructor(x, y) &#123;</div><div class="line">		<span class="keyword">this</span>.x = x;</div><div class="line">		<span class="keyword">this</span>.y = y;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	constructor(x, y, color) &#123;</div><div class="line">		<span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></div><div class="line">		<span class="comment">// 子类的constructor方法没有调用super之前，使用this关键字，报错</span></div><div class="line">		<span class="keyword">super</span>(x, y);</div><div class="line">		<span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>父类实例和子类实例的proto属性，指向不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'red'</span>);</div><div class="line"></div><div class="line">p2.__proto__ === p1.__proto <span class="comment">// false</span></div><div class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></div><div class="line"></div><div class="line">p2.__proto__.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Ha'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">p1.printName() <span class="comment">// "Ha"</span></div></pre></td></tr></table></figure>
</li>
<li><p>ES5中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class同时有prototype属性和<strong>proto</strong>属性，因此存在两条继承链。<br>   （1）子类的<strong>proto</strong>属性，表示构造函数的继承，指向父类。<br>   （2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，指向父类的prototype属性。</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="type">B</span>.__proto__ === <span class="type">A</span> <span class="comment">// true</span></div><div class="line"><span class="comment">// 子类B的__proto__属性指向父类A</span></div><div class="line"><span class="type">B</span>.prototype.__proto__ === <span class="type">A</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// 子类B的prototype属性的proto属性指向父类A的prototype属性</span></div><div class="line"></div><div class="line"><span class="type">B</span>.prototype = <span class="keyword">new</span> <span class="type">A</span>();</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="type">B</span>.prototype.__proto__ = <span class="type">A</span>.prototype;</div></pre></td></tr></table></figure>
</li>
<li><p>三种特殊情况。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种，子类继承Object类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Object</span> <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// A其实就是构造函数Object的复制，A的实例就是Object的实例。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二种，不存在任何继承</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="comment">// A作为一个基类（即不存在任何继承），是普通函数，直接继承Funciton.prototype。</span></div><div class="line"><span class="comment">// 但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</span></div><div class="line"></div><div class="line"><span class="comment">// 第三种，子类继承null</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;&#125;</div><div class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></div><div class="line"><span class="type">A</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></div><div class="line"><span class="comment">// A也是普通函数，直接继承Funciton.prototype。</span></div><div class="line"><span class="comment">// 但是，A调用后返回的对象不继承任何方法，所以__proto__指向Function.prototype，实质上执行了下面代码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</div><div class="line">	constructor() &#123; <span class="keyword">return</span> <span class="type">Object</span>.create(<span class="literal">null</span>); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>以前，原生构造函数是无法继承的，即不能自定义一个Array的子类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</div><div class="line">	<span class="keyword">constructor</span>: &#123;</div><div class="line">		value: MyArray,</div><div class="line">		writable: <span class="literal">true</span>,</div><div class="line">		configurable: <span class="literal">true</span>,</div><div class="line">		enumerable: <span class="literal">true</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 定义了一个继承Array的MyArray类。但这个类的行为与Array完全不一致</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors.length <span class="comment">// 0</span></div><div class="line"><span class="comment">// 因为原生构造函数无法外部获取，通过Array.apply()或者分配给原型对象都不行。</span></div><div class="line"><span class="comment">// ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</span></div></pre></td></tr></table></figure>
</li>
<li><p>ES6允许继承原生构造函数定义子类，因为ES6先新建父类的实例对象this，再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">	constructor(...args) &#123;</div><div class="line">		<span class="keyword">super</span>(...args);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">arr.length <span class="comment">// 1</span></div><div class="line">arr.length = <span class="number">0</span>;</div><div class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></div><div class="line"><span class="comment">// 定义了一个MyArray类，继承了Array构造函数，可以从MyArray生成数组的实例。</span></div><div class="line"><span class="comment">// ES6可以自定义原生数据结构（比如Array、String等）的子类，ES5无法做到。</span></div></pre></td></tr></table></figure>
</li>
<li><p>上例说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义Error子类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MyError</span>(<span class="symbol">'Something</span> happened!');</div></pre></td></tr></table></figure>
</li>
<li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在方法前，加上static关键字，该方法不会被实例继承，而是直接通过类来调用，称为“静态方法”。</p>
</li>
</ul>
<ul>
<li>ES6之前，一些模块加载方案，主要有CommonJS和AMD。前者用于服务器，后者用于浏览器。ES6在语言层面上，实现了模块功能。</li>
<li>ES6模块思想，是尽量的静态化，编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定。</li>
<li>比如，CommonJS模块就是对象，输入时必须查找对象属性：<code>var { stat, exists, readFile } = require(&#39;fs&#39;);</code>。</li>
<li>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式：<code>import { stat, exists, readFile } from &#39;fs&#39;;</code></li>
<li>Module语法是标准写法，坚持使用import取代require。</li>
<li>ES6将独立的JS文件作为模块，允许一个脚本文件调用另一个脚本文件。该文件内部的所有变量，必须使用export关键字输出。</li>
<li>export用于用户自定义模块，规定对外接口；</li>
<li><p>import用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// profile.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="comment">// 用export命令对外输出了三个变量</span></div><div class="line"></div><div class="line"><span class="comment">// 第二种export写法</span></div><div class="line"><span class="comment">// profile.js</span></div><div class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</div><div class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</div><div class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</div><div class="line"><span class="comment">// 优先考虑这种写法，这样一眼看清楚输出了哪些变量</span></div><div class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>export命令除了输出变量，还可以输出函数或类（class）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对外输出函数multiply</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>import命令：使用export命令定义了模块的对外接口后，其他JS文件通过import命令加载这个模块（文件）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>; <span class="comment">// import加载profile.js文件</span></div><div class="line"></div><div class="line"><span class="comment">// import语句中使用as关键字，为输入的变量重命名</span></div><div class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> newName &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</div><div class="line"></div><div class="line"><span class="comment">// ES6支持多重加载，即所加载的模块中又加载其他模块</span></div><div class="line"><span class="comment">// 先加载Vehicle模块</span></div><div class="line"><span class="keyword">import</span> &#123; Vehicle &#125; <span class="keyword">from</span> <span class="string">'./Vehicle'</span>;</div><div class="line"><span class="comment">// 在Vehicle基础上添加了move方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</div><div class="line">	move () &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is spinning wheels...'</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 作为一个新模块输出</span></div><div class="line"><span class="keyword">export</span> &#123; Car &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一个模块之中，先输入后输出同一个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</div></pre></td></tr></table></figure>
</li>
<li><p>两种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// circle.js文件，输出两个方法area和circumference</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;	</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js文件输入circlek.js模块</span></div><div class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'circle'</span>; <span class="comment">// 逐一指定要输入的方法</span></div><div class="line"></div><div class="line"><span class="comment">// 另一种写法是整体输入</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(circle.area());</div><div class="line"><span class="built_in">console</span>.log(circle.circumference());</div></pre></td></tr></table></figure>
</li>
<li><p>不要在模块输入中使用通配符。这样确保模块之中，有一个默认输出（export default）。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="string">'./importModule'</span>;</div><div class="line"></div><div class="line"><span class="comment">// good</span></div><div class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
</li>
<li>如果模块默认输出一个对象，对象名的首字母应该大写。</li>
</ul>
<ul>
<li><p>使用export取代module.exports。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// commonJS写法</span></div><div class="line"><span class="built_in">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"></div><div class="line"><span class="built_in">var</span> Breadcrumbs = React.createClass(&#123;</div><div class="line">	render() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span>;</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Breadcrumbs;</div><div class="line"></div><div class="line"><span class="comment">// ES6的写法</span></div><div class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Breadcrumbs = React.createClass(&#123;</div><div class="line">	render() &#123;</div><div class="line">		<span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span>;</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Breadcrumbs</div></pre></td></tr></table></figure>
</li>
<li><p>module命令可以取代import语句，达到整体输入模块。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line">module <span class="keyword">circle</span> from <span class="string">'circle'</span>; <span class="comment">// module后面跟一个变量，表示输入的模块定义在该变量上</span></div><div class="line">console.<span class="keyword">log</span>(<span class="keyword">circle</span>.area());</div><div class="line">console.<span class="keyword">log</span>(<span class="keyword">circle</span>.circumference());</div></pre></td></tr></table></figure>
</li>
<li><p>使用import需要知道要加载的变量名或函数名，export default命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="comment">// 默认输出是一个函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// import-default.js</span></div><div class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>; <span class="comment">// import命令为该匿名函数指定任意名字，这时import后面，不使用大括号</span></div><div class="line">customName(); <span class="comment">// 'foo'</span></div></pre></td></tr></table></figure>
</li>
<li><p>export default命令也可以用在非匿名函数前。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// export-default.js</span></div><div class="line"><span class="comment">// foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</div></pre></td></tr></table></figure>
</li>
<li><p>使用export default时，对应的import语句不需要使用大括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>不使用export default时，对应的import语句需要使用大括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">import</span> &#123; crc32 &#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>一个模块只能有一个默认输出，export deault命令只能用一次。所以，import后面不用加大括号。</p>
</li>
<li><p>本质上，export default就是输出一个叫做default的变量或方法，允许取任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// modules.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> x * y;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>其它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输入jQuery模块</span></div><div class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 在一条import语句中，同时输入默认方法和其他变量</span></div><div class="line"><span class="keyword">import</span> customName, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">'./export-default'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 将值跟在export default之后可输出默认的值</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</div><div class="line"></div><div class="line"><span class="comment">// export default用来输出类</span></div><div class="line"><span class="comment">// MyClass.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span></div><div class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</div><div class="line"></div><div class="line"><span class="comment">// 模块之间也可以继承。假设circleplus模块，继承了circle模块</span></div><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</div><div class="line">&#125;</div><div class="line"><span class="comment">// “export *”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。</span></div><div class="line"></div><div class="line"><span class="comment">// 将circle的属性或方法，改名后再输出</span></div><div class="line"><span class="comment">// circleplus.js</span></div><div class="line"><span class="keyword">export</span> &#123; area <span class="keyword">as</span> circleArea &#125; <span class="keyword">from</span> <span class="string">'circle'</span>; <span class="comment">// 只输出circle模块的area方法，且改名为circleArea</span></div><div class="line"></div><div class="line"><span class="comment">// 加载上面模块写法如下</span></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="built_in">module</span> math <span class="keyword">from</span> <span class="string">"circleplus"</span>;</div><div class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">"circleplus"</span>; <span class="comment">// "import exp"表示将circleplus模块的默认方法加载为exp方法</span></div><div class="line"><span class="built_in">console</span>.log(exp(math.pi));</div></pre></td></tr></table></figure>
</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by  Huangzhike </p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"> Huangzhike </a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
