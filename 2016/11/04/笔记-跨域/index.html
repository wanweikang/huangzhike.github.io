	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[笔记]-跨域 | 一切都沉淀为笔记</title>
  <meta name="author" content="Huangzhike">
  
  <meta name="description" content="出处：http://damonare.github.io/2016/10/30/前端跨域整理/
跨域：只要协议、域名、端口有任何一个不同，都是不同的域。所以要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。12345678910111213">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="[笔记]-跨域"/>
  <meta property="og:site_name" content="一切都沉淀为笔记"/>

  
  
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="//favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">一切都沉淀为笔记</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/resume" title="我的主页">
                    <i class="fa fa-github"></i>GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>[笔记]-跨域</h2>
					
					<div>
						<span class="post-time">2016-11-04 20:34</span>
					</div>	
					

					<div class="article-content">
						<p>出处：<a href="http://damonare.github.io/2016/10/30/前端跨域整理/" target="_blank" rel="external">http://damonare.github.io/2016/10/30/前端跨域整理/</a></p>
<p>跨域：只要协议、域名、端口有任何一个不同，都是不同的域。所以要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 同一域名下 允许</div><div class="line">http://www.a.com/a.js</div><div class="line">http://www.a.com/b.js </div><div class="line"></div><div class="line">// 同一域名下不同文件夹 允许</div><div class="line">http://www.a.com/lab/a.js</div><div class="line">http://www.a.com/script/b.js </div><div class="line"></div><div class="line">// 同一域名，不同端口 不允许</div><div class="line">http://www.a.com:8000/a.js</div><div class="line">http://www.a.com/b.js  </div><div class="line"></div><div class="line">// 同一域名，不同协议 不允许</div><div class="line">http://www.a.com/a.js</div><div class="line">https://www.a.com/b.js </div><div class="line"></div><div class="line">// 域名和域名对应ip 不允许</div><div class="line">http://www.a.com/a.js</div><div class="line">http://70.32.92.74/b.js </div><div class="line"></div><div class="line">// 主域相同，子域不同 不允许（cookie也不允许访问）</div><div class="line">http://www.a.com/a.js</div><div class="line">http://script.a.com/b.js </div><div class="line"></div><div class="line">// 同一域名，不同二级域名（同上） 不允许（cookie也不允许访问）</div><div class="line">http://www.a.com/a.js</div><div class="line">http://a.com/b.js </div><div class="line"></div><div class="line">// 不同域名 不允许</div><div class="line">http://www.cnblogs.com/a.js</div><div class="line">http://www.a.com/b.js</div></pre></td></tr></table></figure></p>
<p>如果是<strong>协议和端口造成的跨域</strong>“前台”是无能为力的；<br>域仅仅是通过“URL的首部”来识别而不会去判断相同的ip地址。<br>(“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。)</p>
<p><strong>通过document.domain跨域</strong>：浏览器有一个同源策略，限制之一是不能通过ajax的方法去请求不同源中的文档。第二个限制是浏览器中不同域的框架之间不能进行js的交互操作。不同的框架之间可以获取window对象，但却无法获取相应的属性和方法。比如，有一个页面地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 页面里有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 显然，这个页面与它里面的iframe框架是不同域的，所以无法通过在页面中js代码来获取iframe中的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	function test()&#123;</div><div class="line">		var iframe = document.getElementById(&apos;ifame&apos;);</div><div class="line">		var win = iframe.contentWindow; // 可以获取到iframe里的window对象，但该window对象的属性和方法几乎不可用</div><div class="line">		var name = win.name; // 这里获取不到window对象的name属性</div><div class="line">	&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，document.domain就可以派上用场了，只要把<code>http://www.damonare.cn/a.html</code>和<code>http://damonare.cn/b.html</code>两个页面的document.domain都设成相同的域名就可以了。但document.domain的设置是有限制的，只能把document.domain设置成自身或更高一级的父域，且主域必须相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 在页面http://www.damonare.cn/a.html中设置document.domain:</div><div class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	document.domain = &apos;damonare.cn&apos;;//设置成主域</div><div class="line">	function test()&#123;</div><div class="line">		alert(document.getElementById(&apos;iframe&apos;).contentWindow); // contentWindow 可取得子窗口的 window 对象</div><div class="line">	&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">// 在页面http://damonare.cn/b.html中也设置document.domain:</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	document.domain = &apos;damonare.cn&apos;; // 在iframe载入这个页面也设置document.domain，使与主页面的document.domain相同</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>修改document.domain的方法只适用于不同子域的框架间的交互。</p>
<p><strong>通过location.hash跨域</strong>：因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，一般用于浏览器锚点定位，HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash来进行双向通信。每个window通过改变其他 window的location来发送消息，并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变。这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等：</p>
<ul>
<li>假如父页面是<a href="http://baidu.com/a.html,iframe嵌入的页面为http://google.com/b.html（此处省略了域名等url属性）" target="_blank" rel="external">http://baidu.com/a.html,iframe嵌入的页面为http://google.com/b.html（此处省略了域名等url属性）</a></li>
<li>a.html传送数据到b.html</li>
<li>a.html下修改iframe的src为<a href="http://google.com/b.html#paco" target="_blank" rel="external">http://google.com/b.html#paco</a></li>
<li>b.html监听到url发生变化，触发相应操作</li>
<li>b.html传送数据到a.html</li>
<li>由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe</li>
<li>b.html下创建一个隐藏的iframe，此iframe的src是<a href="http://baidu.com域下的，并挂上要传送的hash数据，如src=&quot;页面不存在_百度搜索" target="_blank" rel="external">http://baidu.com域下的，并挂上要传送的hash数据，如src=&quot;页面不存在_百度搜索</a>“</li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
<p>b.html页面关键代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">try &#123;  </div><div class="line">	parent.location.hash = &apos;data&apos;;  </div><div class="line">&#125; catch (e) &#123;  </div><div class="line">	// ie、chrome的安全机制无法修改parent.location.hash，  </div><div class="line">	var ifrproxy = document.createElement(&apos;iframe&apos;);  </div><div class="line">	ifrproxy.style.display = &apos;none&apos;;  </div><div class="line">	ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;;  </div><div class="line">	document.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>proxy.html页面关键代码 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </div><div class="line">parent.parent.location.hash = self.location.hash.substring(1);</div></pre></td></tr></table></figure></p>
<p><strong>通过HTML5的postMessage方法跨域</strong>：高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都支持这个功能。主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如<a href="http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信：" target="_blank" rel="external">http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信：</a></p>
<p>A页面通过postMessage方法发送消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">window.onload = function() &#123;  </div><div class="line">	var ifr = document.getElementById(&apos;ifr&apos;);  </div><div class="line">	var targetOrigin = &quot;http://www.google.com&quot;;  </div><div class="line">	ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>postMessage的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">otherWindow.postMessage(message, targetOrigin);</div><div class="line"></div><div class="line">// otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</div><div class="line">// message: 要发送的消息，类型为 String、Object (IE8、9 不支持)</div><div class="line">// targetOrigin: 限定消息接收范围，也可不限制</div></pre></td></tr></table></figure></p>
<p>B页面通过message事件监听并接受消息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var onmessage = function (event) &#123;  </div><div class="line">	var data = event.data;//消息  </div><div class="line">	var origin = event.origin;//消息来源地址  </div><div class="line">	var source = event.source;//源Window对象  </div><div class="line">	if(origin==&quot;http://www.baidu.com&quot;)&#123;  </div><div class="line">	console.log(data);//hello world!  </div><div class="line">	&#125;  </div><div class="line">&#125;;  </div><div class="line">if (typeof window.addEventListener !== &apos;undefined&apos;) &#123;  </div><div class="line">	window.addEventListener(&apos;message&apos;, onmessage, false);  </div><div class="line">&#125; else if (typeof window.attachEvent !== &apos;undefined&apos;) &#123;  //for ie  </div><div class="line">	window.attachEvent(&apos;onmessage&apos;, onmessage);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
<p><strong>通过jsonp跨域</strong>：刚才说的这几种都是双向通信的，即两个iframe，页面与iframe或是页面与页面之间的，下面说几种单项跨域的（一般用来获取数据），因为通过script标签引入的js是不受同源策略的限制的。所以可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。</p>
<p>比如，有个a.html页面，需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://damonare.cn/data.php" target="_blank" rel="external">http://damonare.cn/data.php</a>, 那么a.html中的代码就可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	function dosomething(jsondata)&#123;</div><div class="line">		//处理获得的json数据</div><div class="line">	&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">// 获取数据的地址后面有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。</div><div class="line">// 当然如果获取数据的jsonp地址页面不能控制，就得按照提供数据的那一方的规定格式来操作了。</div></pre></td></tr></table></figure></p>
<p>因为是当做一个js文件来引入的，所以<a href="http://damonare.cn/data.php" target="_blank" rel="external">http://damonare.cn/data.php</a> 返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">	$callback = $_GET[&apos;callback&apos;]; // 得到回调函数名</div><div class="line">	$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;); // 要返回的数据</div><div class="line">	echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;; // 输出</div><div class="line">?&gt;</div><div class="line">// 最终输出结果为：dosomething([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]);</div></pre></td></tr></table></figure></p>
<p>如果使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	$.getJSON(&apos;http://example.com/data.php?callback=?,function(jsondata)&apos;)&#123;</div><div class="line">		//处理获得的json数据</div><div class="line">	&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">// jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上起一个临时代理函数的作用。</div><div class="line">// $.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</div></pre></td></tr></table></figure></p>
<p>JSONP的优点：</p>
<ul>
<li>不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；</li>
<li>兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>请求完毕后可以通过调用callback的方式回传结果。</li>
</ul>
<p>JSONP的缺点：</p>
<ul>
<li>只支持GET请求而不支持POST等其它类型的HTTP请求；</li>
<li>只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<p><strong>通过CORS跨域</strong>：CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>平时的ajax请求可能是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	var xhr = new XMLHttpRequest();</div><div class="line">	xhr.open(&quot;POST&quot;, &quot;/damonare&quot;,true);</div><div class="line">	xhr.send();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>以上damonare部分是相对路径，如果使用CORS，相关Ajax代码可能如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">	var xhr = new XMLHttpRequest();</div><div class="line">	xhr.open(&quot;￼GET&quot;, &quot;http://segmentfault.com/u/trigkit4/&quot;,true);</div><div class="line">	xhr.send();</div><div class="line">&lt;/script&gt;</div><div class="line">// 代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是要跨域访问的接口地址。</div></pre></td></tr></table></figure></p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<p>CORS和JSONP对比：</p>
<ul>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS。</li>
<li>CORS与JSONP相比，更为先进、方便和可靠。</li>
</ul>
<p><strong>通过window.name跨域</strong>：window对象有个name属性，该属性有个特征，即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如，在任意一个页面输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">window.name = &quot;My window&apos;s name&quot;;</div><div class="line">setTimeout(function()&#123;</div><div class="line">	window.location.href = &quot;http://damonare.cn/&quot;;</div><div class="line">&#125;,1000)</div></pre></td></tr></table></figure></p>
<p>进入<a href="http://damonare.cn页面后再检测再检测" target="_blank" rel="external">http://damonare.cn页面后再检测再检测</a> window.name :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.name; // My window&apos;s name</div></pre></td></tr></table></figure></p>
<p>可以看到，如果在一个标签里面跳转网页的话，window.name 是不会改变的。基于这个思想，可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。由于安全原因，浏览器始终会保持 window.name 是string 类型。同样这个方法也可以应用到和iframe的交互来，比如，<a href="http://damonare.cn/index.html中内嵌了一个iframe：" target="_blank" rel="external">http://damonare.cn/index.html中内嵌了一个iframe：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.google.com/iframe.html&quot;&gt;&lt;/iframe&gt;</div><div class="line">// 在 iframe.html 中设置好了 window.name 为我们要传递的字符串。</div><div class="line"></div><div class="line">// 在 index.html 中写了下面的代码：</div><div class="line">var iframe = document.getElementById(&apos;iframe&apos;);</div><div class="line">var data = &apos;&apos;;</div><div class="line"></div><div class="line">iframe.onload = function() &#123;</div><div class="line">	data = iframe.contentWindow.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>报错！因为两个页面不同源，可以这样解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var iframe = document.getElementById(&apos;iframe&apos;);</div><div class="line">var data = &apos;&apos;;</div><div class="line"></div><div class="line">iframe.onload = function() &#123;</div><div class="line">	iframe.onload = function()&#123;</div><div class="line">		data = iframe.contentWindow.name;</div><div class="line">	&#125;</div><div class="line">	iframe.src = &apos;about:blank&apos;;</div><div class="line">&#125;;</div><div class="line">// 或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</div></pre></td></tr></table></figure></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<p>其它诸如中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp）不作讨论。</p>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  Powered by <a href="https://hexo.io">Hexo</a>  | with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme
</p>
<p>
  &copy; 2016 <a href="http://huangzhike.github.io"> Huangzhike </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
