<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-跨域 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-跨域"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-跨域</h2>
				
				<div>
					<span class="post-time">2016-11-04 20:34</span>
				</div>	
				
				<div class="article-content">
				<p><strong>2016-11-26更新</strong><br>参考出处（这个不是原始出处，原始出处应该是trigkit4？反正就是抄来抄去啦）：<a href="http://damonare.github.io/2016/10/30/前端跨域整理/" target="_blank" rel="external">http://damonare.github.io/2016/10/30/前端跨域整理/</a><br><strong>2016-12-21更新</strong><br><a href="http://yincheng.site/cross-domain" target="_blank" rel="external">http://yincheng.site/cross-domain</a></p>
<p><strong>同源策略：</strong>同源指的是：协议，域名，端口相同，同源策略是一种安全协议，一段脚本只能读取同一来源的窗口和文档的属性。</p>
<p><strong>同源限制的原因：</strong>如利用Iframe把登录页面嵌到页面上，当使用账号密码登录时，页面就可以通过Javascript读取到input的内容。</p>
<p><strong>跨域：</strong>只要协议、域名、端口有任何一个不同，都是不同的域。使本域脚本能够操作其他域的页面对象（iframe之间）。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 同一域名下 允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 同一域名下不同文件夹 允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/lab/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/script/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 同一域名，不同端口 不允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com:8000/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/b.js  </span></div><div class="line"></div><div class="line"><span class="comment">// 同一域名，不同协议 不允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/a.js</span></div><div class="line"><span class="symbol">https:</span><span class="comment">//www.a.com/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 域名和域名对应ip 不允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//70.32.92.74/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 主域相同，子域不同 不允许（cookie也不允许访问）</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//script.a.com/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 同一域名，不同二级域名 不允许（cookie也不允许访问）</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//a.com/b.js </span></div><div class="line"></div><div class="line"><span class="comment">// 不同域名 不允许</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.cnblogs.com/a.js</span></div><div class="line"><span class="symbol">http:</span><span class="comment">//www.a.com/b.js</span></div></pre></td></tr></table></figure></p>
<ul>
<li>协议和端口造成的跨域“前台”无能为力；</li>
<li>域仅仅是通过“URL的首部（Domains, protocols and ports）”识别而不会判断相同的ip地址。</li>
<li>浏览器同源策略，不能ajax请求不同源的文档，不同域的框架之间不能进行js交互操作。</li>
<li>不同的框架间可以获取window对象，但无法获取相应的属性和方法。</li>
</ul>
<p><strong>document.domain跨域</strong>：上面的情况可以用document.domain，只要把<code>http://www.damonare.cn/a.html</code>和<code>http://damonare.cn/b.html</code>两个页面的<code>document.domain</code>都设成相同域名就可以了。</p>
<p>子域可以跨父域，但要显式将子域的domain改成父域的，mail.mysite.com要请求mysite.com的数据，在mail.mysite.com脚本里要执行：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.domain = <span class="string">"mysite.com"</span><span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>缺点：document.domain方法只适用于不同子域的框架间的交互，只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>
<p><strong>window.name跨域</strong>：window对象有name属性，在一个窗口window生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name持久存在一个窗口载入过的所有页面中，不会因新页面的载入而重置，如果在一个标签里面跳转网页，window.name 是不会改变的。<br>可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到刚刚设置的 window.name 了。由于安全原因，浏览器始终保持 window.name 是string 类型。同样也可应用到iframe的交互，如，<a href="http://damonare.cn/index.html中内嵌了一个iframe：" target="_blank" rel="external">http://damonare.cn/index.html中内嵌了一个iframe：</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.google.com/iframe.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></div><div class="line"><span class="comment">// 在 iframe.html 中设置了 window.name 要传递的字符串</span></div><div class="line"></div><div class="line"><span class="comment">// index.htm：</span></div><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	data = iframe.contentWindow.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>报错！因为两个页面不同源，这样解决：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line"></div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		data = iframe.contentWindow.name;</div><div class="line">	&#125;</div><div class="line">	iframe.src = <span class="string">'about:blank'</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 或将 about:blank 替换成同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</span></div></pre></td></tr></table></figure></p>
<p>与 document.domain 相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<p><strong>location.hash跨域</strong>：父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，一般用于锚定位，HTTP请求过程中不携带hash，这部分修改不会产生HTTP请求，但会产生浏览器历史记录。原理就是改变URL的hash来进行双向通信。每个window通过改变其他 window的location来发送消息，并通过监听自己的URL的变化来接收消息：</p>
<ul>
<li>假如父页面是<a href="http://baidu.com/a.html，iframe嵌入页面为http://google.com/b.html（省略了域名等）" target="_blank" rel="external">http://baidu.com/a.html，iframe嵌入页面为http://google.com/b.html（省略了域名等）</a></li>
<li>a.html传送数据到b.html：<ul>
<li>a.html下修改iframe的src为<a href="http://google.com/b.html#paco" target="_blank" rel="external">http://google.com/b.html#paco</a></li>
<li>b.html监听到url发生变化</li>
</ul>
</li>
<li>b.html传送数据到a.html：<ul>
<li>由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash，所以要借助于父窗口域名下的一个代理iframe</li>
<li>b.html下创建隐藏iframe，src是<a href="http://baidu.com域下的，并挂上要传送的hash数据，如src=&quot;页面不存在_百度搜索" target="_blank" rel="external">http://baidu.com域下的，并挂上要传送的hash数据，如src=&quot;页面不存在_百度搜索</a>“</li>
<li>proxy.html监听到url发生变化，修改a.html的url（a.html和proxy.html同域，proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化</li>
</ul>
</li>
</ul>
<p>b.html：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;  </div><div class="line">	parent.location.hash = <span class="string">'data'</span>;  </div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;  </div><div class="line">	<span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);  </div><div class="line">	ifrproxy.style.display = <span class="string">'none'</span>;  </div><div class="line">	ifrproxy.src = <span class="string">"http://www.baidu.com/proxy.html<span class="subst">#data</span>"</span>;  </div><div class="line">	<span class="built_in">document</span>.body.appendChild(ifrproxy);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>proxy.html：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">parent</span>.<span class="keyword">parent</span>.location.hash = <span class="built_in">self</span>.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>缺点：会造成不必要的历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变；数据直接暴露在了url中，数据容量和类型都有限。</p>
<p><strong>HTML5的postMessage方法跨域</strong>：IE 8+, chrome都支持，包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
<ul>
<li><p><a href="http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信：" target="_blank" rel="external">http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信：</a></p>
<ul>
<li><p>A页面postMessage方法发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">	<span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);  </div><div class="line">	ifr.contentWindow.postMessage(<span class="string">'hello world!'</span>, <span class="string">"http://www.google.com"</span>);  </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// postMessage</span></div><div class="line"><span class="comment">// otherWindow.postMessage(message, targetOrigin);</span></div><div class="line"><span class="comment">// otherWindow：目标窗口，是 window.frames 属性的成员或由 window.open 方法创建的窗口</span></div><div class="line"><span class="comment">// message：发送的消息，类型为 String、Object (IE8、9 不支持)</span></div><div class="line"><span class="comment">// targetOrigin：限定消息接收范围，也可不限制</span></div></pre></td></tr></table></figure>
</li>
<li><p>B页面监听message事件并接受消息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </div><div class="line">	<span class="keyword">var</span> data = event.data; <span class="comment">// 消息  </span></div><div class="line">	<span class="keyword">var</span> origin = event.origin; <span class="comment">// 消息来源地址  </span></div><div class="line">	<span class="keyword">var</span> source = event.source; <span class="comment">// 源Window对象  </span></div><div class="line">	<span class="keyword">if</span> (origin === <span class="string">"http://www.baidu.com"</span>) &#123;  </div><div class="line">		<span class="built_in">console</span>.log(data);<span class="comment">// hello world!  </span></div><div class="line">	&#125;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line">	<span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onmessage, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>同理，也可以B页面发送消息，然后A页面监听并接受消息。</p>
</li>
</ul>
</li>
</ul>
<p><strong>JSONP跨域</strong>：上面都是双向通信，两个iframe，页面与iframe或页面与页面，下面说单项跨域（一般用来获取数据）。<br>通过script标签引入的脚本不受同源策略的限制，script标签引入一个js或者其他后缀（如php，jsp）的文件，此文件返回一个js函数的调用。<br>原理是：动态插入<code>script</code>标签，<code>script</code>标签引入一个<code>js</code>文件，这个js文件载入成功后，把服务端的<code>json</code>数据作为参数传入，执行在url参数中的回调函数。</p>
<p>如，a.html页面，需要ajax获取不同域上的json数据，假设数据地址：<a href="http://example.cn/data.php。" target="_blank" rel="external">http://example.cn/data.php。</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// a.html</div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">writeData</span><span class="params">(jsondata)</span> </span>&#123;</div><div class="line">		<span class="comment">// 处理获得的json数据</span></div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://example.com/data.php?callback=writeData"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line">// 获取数据的地址后面有callback参数，其他名字也一样</div></pre></td></tr></table></figure></p>
<p><a href="http://example.cn/data.php" target="_blank" rel="external">http://example.cn/data.php</a> 返回的必须是能执行的脚本文件：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">	$callback = $_GET[<span class="string">'callback'</span>]; <span class="comment">// 得到回调函数名</span></div><div class="line">	$data = <span class="keyword">array</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>); <span class="comment">// 要返回的数据</span></div><div class="line">	<span class="keyword">echo</span> $callback.<span class="string">'('</span>.json_encode($data).<span class="string">')'</span>; <span class="comment">// 输出</span></div><div class="line"><span class="meta">?&gt;</span></div><div class="line"><span class="comment">// 输出：writeData(['a', 'b', 'c']);</span></div></pre></td></tr></table></figure></p>
<p>或使用jquery封装的方法进行jsonp：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.getJSON(<span class="string">'http://example.com/data.php?callback=?'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">jsondata</span>)</span>&#123;</div><div class="line">	<span class="comment">// 处理获得的json数据，其实是简写的$.ajax</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">// jquery自动生成全局函数替换callback=?的问号，之后获取到数据后又会自动销毁，起临时代理函数的作用</span></div><div class="line"><span class="comment">// $.getJSON自动判断是否跨域，不跨域，普通ajax；跨域，以异步加载js形式调用jsonp的回调</span></div></pre></td></tr></table></figure></p>
<p>JSONP的优点：</p>
<ul>
<li>不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；</li>
<li>兼容性更好，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>请求完毕后可以通过调用callback的方式回传结果。</li>
</ul>
<p>JSONP的缺点：</p>
<ul>
<li>只支持GET请求；</li>
<li>只支持跨域HTTP请求，不能解决不同域的两个页面之间进行JavaScript调用的问题。</li>
</ul>
<p><strong>CORS跨域</strong>：跨域资源共享（Cross-Origin Resource Sharing），使用自定义的HTTP头部让浏览器与服务器沟通，决定请求或响应。主流浏览器都支持，IE浏览器不能低于IE10。</p>
<p>普通ajax请求：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	var xhr = new XMLHttpRequest();</div><div class="line">	xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"/trigkit4"</span>, true); // 相对路径</div><div class="line">	xhr.send();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>CORS：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	var xhr = new XMLHttpRequest();</div><div class="line">	xhr.open(<span class="string">"<span class="keyword">GET</span>"</span>, <span class="string">"http://segmentfault.com/u/trigkit4/"</span>, true);</div><div class="line">	xhr.send();</div><div class="line">&lt;/script&gt;</div><div class="line">// 区别在于相对路径换成了其他域的绝对路径，要跨域访问的接口地址</div></pre></td></tr></table></figure></p>
<p>很多天气、IP地址查询的网站就采用了这样的方法，允许其它网站对其请求数据，例如IP location，可以在自己网站的js里面向它发一个get请求：<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">url</span> = <span class="string">"https://ipinfo.io/54.169.237.109/json?token=iplocation.net"</span>;</div><div class="line"><span class="built_in">document</span>.cookie = <span class="string">"version=1;"</span>;</div><div class="line">$.ajax(&#123; <span class="attribute">url</span>: <span class="built_in">url</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>观察response的头部，发现添加了一个字段：<code>Access-Control-Allow-Origin</code>，它的*表示允许任意网站向这个接口请求数据，也可以设置成指定的域名，如：<code>response.writeHead(200, { &quot;Access-Control-Allow-Origin&quot;: &quot;http://yoursite.com&quot;});</code></p>
<p>整个CORS过程，浏览器自动完成。CORS通信与同源的AJAX通信代码完全一样。浏览器一旦发现AJAX请求跨域，就会自动添加一些附加的头信息，实现CORS通信的关键是服务器，设置Access-Control-Allow-Origin。如果浏览器检测到相应的设置，就允许Ajax跨域。</p>
<p>CORS和JSONP对比：</p>
<ul>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，绝大多数现代浏览器都支持CORS。</li>
<li>CORS更先进、方便和可靠。</li>
</ul>
<p><strong>其它</strong>：中间件跨域，服务器代理跨域，Flash URLLoader跨域，动态创建script标签（简化版本的jsonp）。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2016 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
