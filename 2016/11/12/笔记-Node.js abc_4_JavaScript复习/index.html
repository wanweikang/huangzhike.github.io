<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
				<script>var timeStart = new Date();</script>
		
		<title>[笔记]-Node.js abc_4_JavaScript复习 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Node.js abc_4_JavaScript复习"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Node.js abc_4_JavaScript复习</h2>
				
				<div>
					<span class="post-time">2016-11-12 09:23:19</span>
				</div>	
				
				<div class="article-content">
				<p><strong>来源：</strong> Node.js开发指南的附录，主要是JavaScript的重难点，很多在我之前的笔记都有详细的解释，不过作者byvoid也是总结的很好，英雄所见略同，再复习一遍。顺带说一句，作者很年轻，书里有很多引用，有些我也看过，这个风格有点类似我:)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="comment">// 假设这三个文件的内容分别是 A、B 和 C</span></div><div class="line"><span class="keyword">var</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>, <span class="string">'c.txt'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</div><div class="line">	<span class="comment">// files[i] 作为 fs.readFile 的第一个参数在循环中就传递了，所以文件可以被定位到</span></div><div class="line">	fs.readFile(files[i], <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(files[i] + <span class="string">': '</span> + contents); <span class="comment">// fs.readFile 的回调访问到的 i 值都是循环后的</span></div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">// i 的值都是 3，超出了 files 数组下标，因此 undefined</span></div><div class="line"><span class="comment">// undefined: A</span></div><div class="line"><span class="comment">// undefined: B</span></div><div class="line"><span class="comment">// undefined: C</span></div></pre></td></tr></table></figure>
<p>回调函数引用到的 i 值是上面循环执行结束后的值，利用JavaScript函数式编程，建立闭包：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>, <span class="string">'c.txt'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</div><div class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">		fs.readFile(files[i], <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(files[i] + <span class="string">': '</span> + contents);</div><div class="line">		&#125;);</div><div class="line">	&#125;)(i); <span class="comment">// 建立了匿名函数，将循环迭代变量 i 作为函数的参数传递并调用</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于运行时闭包，匿名函数中定义的变量在它内部的函数（fs.readFile 的回调）执行完毕之前都不会释放，<br>访问到的 i 就分别是不同的闭包实例，这个实例是在循环体执行创建的，保留了不同的值。</p>
<p>用数组的 forEach 方法解决这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> files = [<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>, <span class="string">'c.txt'</span>];</div><div class="line">files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">	fs.readFile(filename, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(filename + <span class="string">': '</span> + contents);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>JavaScript 的作用域是静态作用域，又叫词法作用域，作用域的嵌套关系在语法分析时确定，而不等到运行时确定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">'global'</span>;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(scope); <span class="comment">// undefined</span></div><div class="line">	<span class="keyword">var</span> scope = <span class="string">'f'</span>;</div><div class="line">&#125;</div><div class="line">f();</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">'top'</span>;</div><div class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(scope);</div><div class="line">&#125;;</div><div class="line">f1(); <span class="comment">// top</span></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> scope = <span class="string">'f2'</span>;</div><div class="line">	f1();</div><div class="line">&#125;;</div><div class="line">f2(); <span class="comment">// top</span></div></pre></td></tr></table></figure>
<p>当函数返回内部定义的函数时，就产生了闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。<br>闭包有两个主要用途，一是实现嵌套的回调函数，二是隐藏对象的细节。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node.js 中使用 MongoDB 实现简单的增加用户</span></div><div class="line">exports.add_user = <span class="function"><span class="keyword">function</span></span>(user_info, <span class="keyword">callback</span>) &#123;</div><div class="line">	<span class="comment">// 闭包层层嵌套，每一层的嵌套都是一个回调</span></div><div class="line">	<span class="comment">// 嵌套的每一层都有对 callback 的引用，最里层还用到了外层定义的 uid 变量</span></div><div class="line">	<span class="comment">// 由于闭包，即使外层函数已经执行完，其作用域内变量也不会释放，里层的函数还有可能引用到这些变量</span></div><div class="line">	<span class="keyword">var</span> uid = parseInt(user_info[<span class="string">'uid'</span>]);</div><div class="line">	mongodb.open(<span class="function"><span class="keyword">function</span></span>(err, db) &#123;</div><div class="line">		<span class="keyword">if</span> (err) &#123;<span class="keyword">callback</span>(err); <span class="keyword">return</span>;&#125;</div><div class="line">		db.collection(<span class="string">'users'</span>, <span class="function"><span class="keyword">function</span></span>(err, collection) &#123;</div><div class="line">			<span class="keyword">if</span> (err) &#123;<span class="keyword">callback</span>(err); <span class="keyword">return</span>;&#125;</div><div class="line">			collection.ensureIndex(<span class="string">"uid"</span>, <span class="function"><span class="keyword">function</span></span>(err) &#123;</div><div class="line">				<span class="keyword">if</span> (err) &#123;<span class="keyword">callback</span>(err); <span class="keyword">return</span>;&#125;</div><div class="line">				collection.ensureIndex(<span class="string">"username"</span>, <span class="function"><span class="keyword">function</span></span>(err) &#123;</div><div class="line">					<span class="keyword">if</span> (err) &#123;<span class="keyword">callback</span>(err); <span class="keyword">return</span>;&#125;</div><div class="line">					collection.findOne(&#123;uid: <span class="type">uid</span>&#125;, <span class="function"><span class="keyword">function</span></span>(err) &#123;</div><div class="line">						<span class="keyword">if</span> (err) &#123;<span class="keyword">callback</span>(err); <span class="keyword">return</span>;&#125;</div><div class="line">						<span class="keyword">if</span> (doc) &#123;</div><div class="line">							<span class="keyword">callback</span>(<span class="string">'occupied'</span>);</div><div class="line">						&#125; <span class="keyword">else</span> &#123;</div><div class="line">							<span class="keyword">var</span> user = &#123;</div><div class="line">								uid: <span class="type">uid</span>,</div><div class="line">								user: <span class="type">user_info</span>,</div><div class="line">							&#125;;</div><div class="line">							collection.insert(user, <span class="function"><span class="keyword">function</span></span>(err) &#123;</div><div class="line">								<span class="keyword">callback</span>(err);</div><div class="line">							&#125;);</div><div class="line">						&#125;</div><div class="line">					&#125;);</div><div class="line">				&#125;);</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>JavaScript的对象没有私有属性，对象的每个属性都是曝露给外部的。<br>JavaScript约定所有私有属性前加下划线（如 _myPrivateProp ），外部对象不应该直接读写，通过闭包实现。<br>把一个对象用闭包封装起来，只返回一个“访问器”的对象，即可实现对细节隐藏：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现私有成员</span></div><div class="line"><span class="keyword">var</span> generateClosure = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">get</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">		count ++;</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">get</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> counter = generateClosure();</div><div class="line"><span class="comment">// 调用 counter() 才能访问到闭包内的 count 变量</span></div><div class="line">counter(); <span class="comment">// 1</span></div><div class="line">counter(); <span class="comment">// 2</span></div><div class="line">counter(); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>使用不同的引用来调用同一个函数时， this 指针永远是这个引用所属的对象。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> someuser = &#123;</div><div class="line">	name: <span class="string">'byvoid'</span>,</div><div class="line">	<span class="function"><span class="keyword">func</span>: <span class="title">function</span><span class="params">()</span></span> &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">	name: <span class="string">'foobar'</span></div><div class="line">&#125;;</div><div class="line">someuser.<span class="keyword">func</span>(); <span class="comment">// byvoid</span></div><div class="line"></div><div class="line">foo.<span class="keyword">func</span> = someuser.<span class="keyword">func</span>; <span class="comment">// 赋给引用</span></div><div class="line">foo.<span class="keyword">func</span>(); <span class="comment">// foobar</span></div><div class="line"></div><div class="line">name = <span class="string">'global'</span>;</div><div class="line"><span class="keyword">var</span> func1 = someuser.<span class="keyword">func</span>; <span class="comment">// 赋给引用</span></div><div class="line">func1(); <span class="comment">// global</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> func2 = someuser.<span class="keyword">func</span>.bind(foo);</div><div class="line">func2(); <span class="comment">// foobar</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> func3 = func2.bind(someuser);</div><div class="line">func3(); <span class="comment">// foobar</span></div></pre></td></tr></table></figure></p>
<p>bind 方法的简化版本（不支持绑定参数表）：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">someuser.func.<span class="keyword">bind</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> this.<span class="keyword">call</span>(self);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>func3 以 someuser 作为 func2 的 this 调用了 func2 ，而 func2 根本没有使用 this 指针，所以两次 bind 是没有效果的。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 将func2 = someuser.func.<span class="keyword">bind</span>(foo)展开：</div><div class="line">func2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> someuser.func.<span class="keyword">call</span>(foo);</div><div class="line">&#125;;</div><div class="line">// 再将func3 = func2.<span class="keyword">bind</span>(someuser)展开：</div><div class="line">func3 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> func2.<span class="keyword">call</span>(someuser);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用了原型而不是构造函数初始化对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Person.prototype.name = <span class="string">'BYVoid'</span>;</div><div class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.showName();</div></pre></td></tr></table></figure></p>
<p>构造函数内定义的属性继承方式与原型不同，子对象需要显式调用父对象才能继承构造函数内定义的属性。<br>构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。<br>构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说也是可见的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> innerVar = <span class="string">'hello'</span>;</div><div class="line">	<span class="keyword">this</span>.prop1 = <span class="string">'BYVoid'</span>;</div><div class="line">	<span class="keyword">this</span>.func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		innerVar = <span class="string">''</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">Foo.prototype.prop2 = <span class="string">'Carbo'</span>;</div><div class="line">Foo.prototype.func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.prop2);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> foo1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="keyword">var</span> foo2 = <span class="keyword">new</span> Foo();</div><div class="line">foo1.func1 === foo2.func1; <span class="comment">// false</span></div><div class="line">foo1.func2 === foo2.func2; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>JavaScript有两个特殊的对象： Object 与 Function ，都是构造函数，用于生成对象。<br>Object.prototype 是所有对象的祖先， Function.prototype 是所有函数的原型，包括构造函数。<br>对象都有一个 <strong>proto</strong> 属性，指向该对象的原型，从任何对象沿着它遍历都可以追溯到 Object.prototype 。<br>构造函数对象有 prototype 属性，指向一个原型对象，通过该构造函数创建对象时，被创建对象的 <strong>proto</strong> 属性将会指向构造函数的 prototype 属性。<br>原型对象有 constructor属性，指向它对应的构造函数。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span> <span class="comment">&#123;&#125;</span></span></div><div class="line"><span class="title">Object</span>.<span class="title">prototype</span>.<span class="title">name</span> = '<span class="title">My</span> <span class="title">Object</span>';</div><div class="line">Foo.prototype.<span class="keyword">name</span> = <span class="string">'Bar'</span>;</div><div class="line"><span class="keyword">var</span> obj = new <span class="keyword">Object</span>();</div><div class="line"><span class="keyword">var</span> foo = new Foo();</div><div class="line">obj.<span class="keyword">name</span>; <span class="comment">// My Object</span></div><div class="line">foo.<span class="keyword">name</span>; <span class="comment">// Bar</span></div><div class="line">foo.__proto__.<span class="keyword">name</span>; <span class="comment">// Bar</span></div><div class="line">foo.__proto__.__proto__.<span class="keyword">name</span>; <span class="comment">// My Object</span></div><div class="line">foo. __proto__.<span class="keyword">constructor</span>.prototype.<span class="keyword">name</span>; <span class="comment">// Bar</span></div></pre></td></tr></table></figure></p>
<p>JavaScript继承是依靠原型链（prototype chain）机制实现的。<br>属性继承的本质就是一个对象可以访问到它的原型链上任何一个原型对象的属性。<br>上例的foo对象拥有 <code>foo. __proto__</code>和 <code>foo. __proto__.__proto__</code>所有属性的浅拷贝（只复制基本数据类型，不复制对象）。<br>所以可以直接访问 foo.constructor （来自 <code>foo.__proto__</code>，即 Foo.prototype ），foo.toString （来自 <code>foo. __proto__.__proto__</code> ，即 Object.prototype ）。</p>
<p>JavaScript 和 Java 一样都没有像C语言中的指针，所有对象类型的变量都是指向对象的引用，两个变量之间赋值传递一个对象并不会复制这个对象，而只是传递引用。<br>对象浅拷贝（shallow copy）的实现，即只复制基本类型的属性，而共享对象类型的属性。<br>浅拷贝的问题是两个对象共享对象类型的属性，例如 likes 属性指向同一个数组。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Object.prototype.clone = <span class="function"><span class="keyword">function</span></span>() &#123;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = &#123;&#125;;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="built_in">this</span>) &#123;</div><div class="line">		<span class="keyword">new</span><span class="type">Obj</span>[i] = <span class="built_in">this</span>[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Obj</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">	name: <span class="type"></span>'byvoid<span class="string">',</span></div><div class="line">	likes: ['node<span class="string">']</span></div><div class="line">&#125;;</div><div class="line">var newObj = obj.clone();</div><div class="line">obj.likes.push('python<span class="string">');</span></div><div class="line">obj.likes; // [ 'node<span class="string">', '</span>python<span class="string">' ]</span></div><div class="line">newObj.likes; // [ 'node<span class="string">', '</span>python<span class="string">' ]</span></div></pre></td></tr></table></figure></p>
<p>实现完全的复制，或深拷贝（deep copy）并不容易，因为除了基本数据类型，还有多种不同的对象，对象内部还有复杂的结构，因此需要用递归来实现：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">Object.prototype.clone = <span class="function"><span class="keyword">function</span></span>() &#123;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Obj</span> = &#123;&#125;;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="built_in">this</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (typeof(<span class="built_in">this</span>[i]) == <span class="string">'object'</span> || typeof(<span class="built_in">this</span>[i]) == <span class="string">'function'</span>) &#123;</div><div class="line">			<span class="keyword">new</span><span class="type">Obj</span>[i] = <span class="built_in">this</span>[i].clone();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">new</span><span class="type">Obj</span>[i] = <span class="built_in">this</span>[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Obj</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">Array</span>.prototype.clone = <span class="function"><span class="keyword">function</span></span>() &#123;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Array</span> = [];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (typeof(<span class="built_in">this</span>[i]) == <span class="string">'object'</span> || typeof(<span class="built_in">this</span>[i]) == <span class="string">'function'</span>) &#123;</div><div class="line">			<span class="keyword">new</span><span class="type">Array</span>[i] = <span class="built_in">this</span>[i].clone();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">new</span><span class="type">Array</span>[i] = <span class="built_in">this</span>[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Array</span>;</div><div class="line">&#125;;</div><div class="line">Function.prototype.clone = <span class="function"><span class="keyword">function</span></span>() &#123;</div><div class="line">	<span class="keyword">var</span> that = <span class="built_in">this</span>;</div><div class="line">	<span class="keyword">var</span> <span class="keyword">new</span><span class="type">Func</span> = <span class="function"><span class="keyword">function</span></span>() &#123;</div><div class="line">		<span class="keyword">return</span> that.apply(<span class="built_in">this</span>, arguments);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="built_in">this</span>) &#123;</div><div class="line">		<span class="keyword">new</span><span class="type">Func</span>[i] = <span class="built_in">this</span>[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Func</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">	name: <span class="type"></span>'byvoid<span class="string">',</span></div><div class="line">	likes: ['node<span class="string">'],</span></div><div class="line">	display: function() &#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;,</div><div class="line">&#125;;</div><div class="line">var newObj = obj.clone();</div><div class="line">newObj.likes.push('python<span class="string">');</span></div><div class="line">obj.likes; // [ 'node<span class="string">' ]</span></div><div class="line">newObj.likes; // [ 'node<span class="string">', '</span>python<span class="string">' ]</span></div><div class="line">newObj.display === obj.display; // false</div></pre></td></tr></table></figure></p>
<p>这个方法在大多数情况下都很好用，但有一种情况它却无能为力：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 两个相互引用的对象</span></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">	<span class="keyword">ref</span>: <span class="literal">null</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">	<span class="keyword">ref</span>: obj1</div><div class="line">&#125;;</div><div class="line">obj1.<span class="keyword">ref</span> = obj2;</div></pre></td></tr></table></figure></p>
<p>当试图使用深拷贝来复制obj1 和 obj2 中的任何一个时，问题就出现了。<br>因为深拷贝的做法是遇到对象就进行递归复制，结果只能无限循环下去。<br>这种情况，简单的递归已经无法解决，必须设计一套图论算法，分析对象之间的依赖关系，建立一个拓扑结构图，然后分别依次复制每个顶点，并重新构建它们之间的依赖关系。（不明觉厉）</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
