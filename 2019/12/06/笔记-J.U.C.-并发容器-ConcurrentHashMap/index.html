<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-J.U.C.-并发容器-ConcurrentHashMap | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-J.U.C.-并发容器-ConcurrentHashMap">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-J.U.C.-并发容器-ConcurrentHashMap</h2>
				
				<div>
					<div class="post-time">2019-12-06</div>
				</div>
				
				<div class="article-content">
				<p>jdk1.8.0_211</p>
<p>首先先推荐<a href="https://sylvanassun.github.io/2018/03/16/2018-03-16-map_family/#扩容" target="_blank" rel="noopener">一篇文章</a>，里面有很多帮到我的地方，特别是关于位运算的部分，要不我想破脑袋也看不明白。</p>
<p>像ConcurrentHashMap这种classic，网上有很多相关的文章，多看一些资料，总会有收获，但是看源码最后还是要自己走一遍流程，思考每一步操作的原因，这样才有意义。</p>
<p>其实并发包我是半年前看的，当时就避开了ConcurrentHashMap，这次看ConcurrentHashMap，也是为了准备面试，不过看完后也是收获很多。。。不亏。。。</p>
<p>这里只关注ConcurrentHashMap的并发处理，略过HashMap的相似内容。</p>
<hr>
<p>ConcurrentHashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> ConcurrentHashMap.Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂存扩容中的新数组，扩容完成后用该数组替代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> ConcurrentHashMap.Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * volatile修饰，修改立即可见，为什么不使用Atomic类，还要Unsafe手动CAS，可能是性能更好？</span></span><br><span class="line"><span class="comment">     * 用于数组初始化和扩容的控制，低16位代表正在扩容的线程数加一</span></span><br><span class="line"><span class="comment">     * 0为初始值，表示数组未初始化</span></span><br><span class="line"><span class="comment">     * 负数的情况：</span></span><br><span class="line"><span class="comment">     * 1（低16位）表示正在初始化，只有一个线程可以执行初始化，其它Thread#yield</span></span><br><span class="line"><span class="comment">     * n（低16位）表示有n-1个线程正在扩容</span></span><br><span class="line"><span class="comment">     * 正数的情况：</span></span><br><span class="line"><span class="comment">     * 如果数组未初始化，表示数组初始化后的大小</span></span><br><span class="line"><span class="comment">     * 如果数组初始化完成，表示下次扩容的阈值，Map的元素数量超过后就会扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并发扩容时，数组已被分配的最新索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> ConcurrentHashMap.CounterCell[] counterCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ConcurrentHashMap#putVal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 键值都不允许为空</span></span><br><span class="line">    <span class="comment">// 百度了一下，对于value不允许为null，是因为如果get返回了null，那么无法判断是key不存在还是value就是null，在并发的情况下，如果再次调用containsKey判断，可能在这期间Map已经发生了改变</span></span><br><span class="line">    <span class="comment">// 对于key不允许为null，还没找到合理的解释，无法判断key为null或不存在？</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算哈希值，会保证哈希值为正</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重试直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 第一次put，初始化数组，所以数组是延迟初始化的</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">            <span class="comment">// 如果数组对应位置无节点，CAS尝试插入，成功就退出，否则下个循环继续</span></span><br><span class="line">            <span class="comment">// tabAt实际是调用的Unsafe#getObjectVolatile直接获取指定位置的数据</span></span><br><span class="line">            <span class="comment">// 因为虽然table是volatile的，但是table中的元素不是volatile的，不能保证线程每次都拿到最新元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用Unsafe#compareAndSwapObject，原子操作table[i]位置，如果为null，则插入，不需要锁</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ForwardingNode节点，是一个标记，说明有其它线程在扩容，而原本的节点被搬到了扩容后的新数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 协助扩容，直到扩容完成才能插入新数组</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="comment">// 有哈希冲突的情况</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 加锁，没有用ReentrantLock是因为JDK8下synchronized性能已经足够好，推荐哦</span></span><br><span class="line">            <span class="comment">// 这里只锁住了一条链表或树，缩小了锁的范围</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检查一次该位置加锁的节点，DCL</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 哈希值大于零，说明是链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到了key对应的节点，然后决定是否覆盖更新</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ConcurrentHashMap.Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 到了链表尾还没找到</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 追加到链表尾</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树以TreeBin形式存放，哈希值为TREEBIN，即-2</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;</span><br><span class="line">                        ConcurrentHashMap.Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 红黑树中找到节点就返回，没有找到就直接追加，这里插入新节点后红黑树重平衡还会另外加锁</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key, value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 链表过长，就转换为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 如果数组容量太小，则不转化，优先扩容，否则DCL对头节点加锁转化为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入完成后，更新Map大小，检查数组是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#initTable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap.Node&lt;K, V&gt;[] initTable() &#123;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 数组还没初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 小于0说明有别的线程在初始化或扩容数组，但还没完成，那么当前线程就让一让，避免并发修改</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// CAS将sizeCtl改为-1成功才能初始化，类似获得了锁，避免多次初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检查数组有没有初始化，类似DCL，如两个线程同时进入了while循环的代码，然后线程1在执行CAS前被挂起，线程2完成了数组初始化，然后线程1唤醒，执行CAS，需要再次判断</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 数组的初始容量，有设置就使用设置的，否则使用默认</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) ConcurrentHashMap.Node&lt;K, V&gt;[] nt = (ConcurrentHashMap.Node&lt;K, V&gt;[]) <span class="keyword">new</span> ConcurrentHashMap.Node&lt;?, ?&gt;[n];</span><br><span class="line">                    <span class="comment">// 用新的数组替换</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sc == n - (n / 2^2) == 0.75 * n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 扩容完成后将sizeCtl更新为下次扩容的阈值</span></span><br><span class="line">                <span class="comment">// 这里没有竞争，因为数组只会初始化一次，不需要CAS</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$TreeBin#putTreeVal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConcurrentHashMap.<span class="function">TreeNode&lt;K, V&gt; <span class="title">putTreeVal</span><span class="params">(<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 由根节点开始向下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.TreeNode&lt;K, V&gt; p = root; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph;</span><br><span class="line">        K pk;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 遍历比较大小</span></span><br><span class="line">        ConcurrentHashMap.TreeNode&lt;K, V&gt; xp = p;</span><br><span class="line">        <span class="comment">// 如果最终还没找到key对应节点，那就插入新的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConcurrentHashMap.TreeNode&lt;K, V&gt; x, f = first;</span><br><span class="line">            first = x = <span class="keyword">new</span> ConcurrentHashMap.TreeNode&lt;K, V&gt;(h, k, v, f, xp);</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (!xp.red)</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里要CAS修改成功才能执行重平衡，否则可能会挂起当前线程</span></span><br><span class="line">                lockRoot();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行红黑树的平衡，返回平衡后的新的根节点</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将红黑树的锁状态重置为0</span></span><br><span class="line">                    unlockRoot();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡完后还要递归检查一遍是否符合红黑树的规则</span></span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$TreeBin</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对红黑树的包装，代替根节点TreeNode，存放在数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ConcurrentHashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ConcurrentHashMap.TreeNode&lt;K, V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> ConcurrentHashMap.TreeNode&lt;K, V&gt; first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$TreeBin#lockRoot</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lockRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS将红黑树的锁状态由空闲改为写才能执行重平衡，否则说明有线程在读或写这棵红黑树，自旋重试</span></span><br><span class="line">    <span class="keyword">if</span> (!U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, <span class="number">0</span>, WRITER))</span><br><span class="line">        contendedLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$TreeBin#contendedLock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">contendedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> waiting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 自旋重试直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s; ; ) &#123;</span><br><span class="line">        <span class="comment">// 如果当前树仅处于等待状态，再次CAS尝试，失败则继续，成功则返回</span></span><br><span class="line">        <span class="keyword">if</span> (((s = lockState) &amp; ~WAITER) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试CAS修改为写状态，成功则表明获取写锁成功，否则说明状态发生了改变或者有竞争，下次自旋继续</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, WRITER)) &#123;</span><br><span class="line">                <span class="comment">// 如果上次自旋后要进入等待状态，现在已经不需要了，置空等待线程并返回</span></span><br><span class="line">                <span class="keyword">if</span> (waiting)</span><br><span class="line">                    waiter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前树不是等待状态，即没有等待线程，尝试修改为等待状态，准备把当前线程挂起</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((s &amp; WAITER) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// CAS添加等待状态成功</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, s | WAITER)) &#123;</span><br><span class="line">                <span class="comment">// 准备下个循环把线程挂起，当然也可能下次自旋CAS成功</span></span><br><span class="line">                waiting = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 将当前线程设为等待线程，其它的就CAS竞争去吧，只能有一个被park</span></span><br><span class="line">                waiter = Thread.currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂起当前写线程，等待读线程完成后将它唤醒</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (waiting)</span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#treeifyBin</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt; b;</span><br><span class="line">    <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组容量过小，则扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容，容量翻倍</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 否则，如果该位置有元素，并且是个链表节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁定该头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="comment">// DCL</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    ConcurrentHashMap.TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 遍历链表，转化为红黑树节点组成的链表</span></span><br><span class="line">                    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> ConcurrentHashMap.TreeNode&lt;K, V&gt;(e.hash, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 和HashMap不一样，插入的是TreeBin，代表了这棵红黑树，不是TreeNode，TreeBin的构造函数内包含了红黑树的转化过程</span></span><br><span class="line">                    <span class="comment">// 应该是为了方便加锁，因为红黑树重平衡后根节点可能会变的，不好直接对根节点加锁</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> ConcurrentHashMap.TreeBin&lt;K, V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#tryPresize</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算扩容后的数组大小，最小的2的幂</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 数组还没初始化，那就先初始化数组，下个循环再检测是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 新数组大小</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">// CAS尝试获取锁，尝试更新sizeCtl为-1，数组正在初始化</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// DCL，再次检查数组是否已经初始化过了</span></span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) ConcurrentHashMap.Node&lt;K, V&gt;[] nt = (ConcurrentHashMap.Node&lt;K, V&gt;[]) <span class="keyword">new</span> ConcurrentHashMap.Node&lt;?, ?&gt;[n];</span><br><span class="line">                        <span class="comment">// 更新数组</span></span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">// 扩容阈值为数组大小的0.75倍</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组还没达到扩容的阈值或者超过了数组的最大容量阈值那就跳出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 扩容前要再次检查当前要扩容的数组是否还是原本的数组，因为扩容是并发的，可能此时扩容已经完成了，大概是线程挂起再唤醒的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 数组正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ConcurrentHashMap.Node&lt;K, V&gt;[] nt;</span><br><span class="line">                <span class="comment">// 参考addCount的注释，总之就是不需要新的线程参与扩容了</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则，CAS尝试更新sizeCtl，协助扩容的线程数加1，成功才能参与扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数组还没扩容，那当前线程就是发起扩容的线程，CAS更新sizeCtl成功才能扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#addCount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.CounterCell[] as;</span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 如果counterCells不为null，说明存在并发修改 || 如果CAS更新baseCount失败，说明存在并发修改</span></span><br><span class="line">    <span class="comment">// 即是说，优先CAS尝试修改baseCount，在存在并发修改的情况下，避免集中的CAS操作，而是将修改分散地暂存在counterCells</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> || !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        ConcurrentHashMap.CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果CounterCell数组不存在 || 如果CounterCell数组长度为0 || 该线程的哈希定位到CounterCell数组的位置为空 || 该位置不为空，并且CAS更新该CounterCell失败</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">// 尝试自旋更新CounterCell，uncontended为false</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="comment">// 成功就返回，也不继续检查要不要扩容了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明是被删除方法调用，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 否则说明是被添加方法调用，需要计算元素个数，检查是否需要扩容，另外Map没有自动缩容的功能</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt;[] tab, nt;</span><br><span class="line">        <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 元素数量超出扩容阈值 &amp;&amp; 数组不为空 &amp;&amp; 数组容量小于最大限制</span></span><br><span class="line">        <span class="comment">// 那么就扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>) (sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 当前数组的长度的二进制值中开头0的数量</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 说明正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 扩容已经结束的5种情况，退出循环：</span></span><br><span class="line"><span class="comment">                 * sizeCtl无符号右移16位，即高16位不等于rs，说明扩容已经结束，sizeCtl已经被更新</span></span><br><span class="line"><span class="comment">                 * 第一个开始扩容的线程会将sizeCtl无符号左移16位再加2，即所有线程退出时sc == rs + 1</span></span><br><span class="line"><span class="comment">                 * 大概是扩容的线程数已经到了65535，不能再增加扩容的线程了，因为低16位已经溢出了</span></span><br><span class="line"><span class="comment">                 * nextTable为空说明扩容已经完成，并且新数组已经更新</span></span><br><span class="line"><span class="comment">                 * transferIndex &lt;= 0说明原本数组全部位置已经分配好线程了，不需要新的线程参与</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 否则说明扩容未完成，需要线程协助，如果CAS将sizeCtl加1成功，则帮忙进行扩容，加1是代表参与扩容的线程增加</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 帮助扩容，nextTable是扩容后的新表</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当前没有扩容，说明是第一个扩容的线程，那么CAS尝试更新sizeCtl，成功了就扩容</span></span><br><span class="line"><span class="comment">             * 这里把rs有符号左移16位，那么最高位就是符号位1，是个负数，高位剩下的15位则保存了当前数组的长度的二进制值中开头0的数量，因为数组长度是2的指数幂，所以二进制值肯定是0...010...0这样，所以只要知道开头几个0就行了</span></span><br><span class="line"><span class="comment">             * 然后加2，所以最开始扩容时是加2的，扩容完成后是减1，即sizeCtl == rs + 1</span></span><br><span class="line"><span class="comment">             * 假设当前数组容量为16，那么resizeStamp方法返回rs = 0000 0000 0000 0000 1000 0000 0001 0000</span></span><br><span class="line"><span class="comment">             * resizeStamp(16) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 == 10000000000100000000000000000010，表示有2-1=1个线程正在扩容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 发起扩容，迁移数据</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 再次统计元素个数，是否还要继续扩容，可能扩容期间有新的元素添加进来</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#fullAddCount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 说明该线程第一次进入</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先初始化该线程的ThreadLocalRandom</span></span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        <span class="comment">// 线程的随机数，可以理解为本次的哈希值</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 自旋重试</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.CounterCell[] as;</span><br><span class="line">        ConcurrentHashMap.CounterCell a;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">// 如果CounterCell数组已初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果哈希定位到的位置没有CounterCell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前的CounterCell数组不存在竞争</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建一个CounterCell</span></span><br><span class="line">                    ConcurrentHashMap.CounterCell r = <span class="keyword">new</span> ConcurrentHashMap.CounterCell(x);</span><br><span class="line">                    <span class="comment">// DCL &amp;&amp; CAS将cellsBusy由空闲修改为忙碌状态成功，类似获取锁</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            ConcurrentHashMap.CounterCell[] rs;</span><br><span class="line">                            <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">// DCL，再次检查</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp; (m = rs.length) &gt; <span class="number">0</span> &amp;&amp; rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 把创建的CounterCell加入数组</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">// 标记操作为成功</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 重置为空闲状态</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果操作成功，不再继续，否则下个循环继续尝试</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 第一次进来时，如果发生了哈希冲突，首先进来这里，然后到下面换一个哈希值尝试别的位置，而不是尝试CAS</span></span><br><span class="line"><span class="comment">             * 如果第二次循环还是有哈希冲突，才尝试CAS更新CounterCell，失败则检查是否扩容数组，不能扩容则换一个哈希下个循环继续</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 到这里说明发生了哈希冲突</span></span><br><span class="line">            <span class="comment">// contended表示竞争，双重否定就是肯定</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                <span class="comment">// 标志为无竞争，然后不会尝试CAS更新，而是会跳到最下面，换一个哈希值，重新执行循环</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 尝试CAS更新该CounterCell的值，如果成功则不需继续</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// CAS更新失败，再次检查CounterCell数组是否已经扩容或容量达到最大值，即CPU核心数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                <span class="comment">// 不能扩容数组，那么就标记冲突为false，继续匹配下个分支，不再匹配扩容分支，然后到下面换一个哈希值</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 如果冲突标记为false，那么设置为true，下面就换一个哈希，继续下一轮循环判断，只有为true才会尝试扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// CAS尝试加锁，然后才能扩容CounterCell数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查是否已被扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                        <span class="comment">// CounterCell数组扩容，翻倍</span></span><br><span class="line">                        ConcurrentHashMap.CounterCell[] rs = <span class="keyword">new</span> ConcurrentHashMap.CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="comment">// 数据迁移</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果上面的条件都不满足，那么更新当前线程的哈希值，下个循环尝试别的位置</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果CounterCell数组未初始化，尝试CAS将cellsBusy由0更新为1，成功才能初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp; U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 类似DCL的双重检查，反复出现的老套路了</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    <span class="comment">// 初始化CounterCell数组，初始容量为2</span></span><br><span class="line">                    ConcurrentHashMap.CounterCell[] rs = <span class="keyword">new</span> ConcurrentHashMap.CounterCell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 根据哈希插入CounterCell</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> ConcurrentHashMap.CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明当前CounterCell数组存在竞争初始化，那么CAS尝试更新baseCount</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$CounterCell</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪共享：缓存是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会连同其它的变量一起失效</span></span><br><span class="line"><span class="comment"> * 一般的解决办法是对变量添加一些无意义的占位Padding，使它独享一个缓存行，如<span class="doctag">@sun</span>.misc.Contended</span></span><br><span class="line"><span class="comment"> * 这个注解默认是JDK包才能用的，要在自己的代码上使用，需要添加JVM参数：“-XX:-RestrictContended”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#sumCount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.CounterCell[] as = counterCells;</span><br><span class="line">    ConcurrentHashMap.CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 可能不准确，比如一个已经遍历过的CounterCell位置又发生了变化，毕竟没有锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// baseCount叠加counterCells</span></span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#helpTransfer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConcurrentHashMap.Node&lt;K, V&gt;[] helpTransfer(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, ConcurrentHashMap.Node&lt;K, V&gt; f) &#123;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt;[] nextTab;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 数组不为空 &amp;&amp; 该位置第一个节点为ForwardingNode &amp;&amp; ForwardingNode指向的当前在扩容的新数组不为空</span></span><br><span class="line">    <span class="comment">// 说明原数组该位置的节点已经完成迁移了，并且迁移还没完成，那么就帮忙迁移别的位置</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ConcurrentHashMap.ForwardingNode) &amp;&amp; (nextTab = ((ConcurrentHashMap.ForwardingNode&lt;K, V&gt;) f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 扩容的新数组是同一个 &amp;&amp; 数组还没被替换 &amp;&amp; 当前正在扩容</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 参考addCount的注释，总之就是不需要新的线程参与扩容了</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> || sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，CAS尝试更新sizeCtl，协助扩容的线程数加1，成功才能参与扩容</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 帮忙扩容，传入的新数组不为空</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#transfer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持多线程并发复制原数组的数据到新数组</span></span><br><span class="line"><span class="comment"> * 假设原数组长度为n，每个线程每次可以负责一批任务，即步长，每完成一批任务再检测是否有其他没完成的，帮助搬运</span></span><br><span class="line"><span class="comment"> * transferIndex指向原数组后，从后往前的步长个元素分配为第一批任务，再将transferIndex指向新的位置，再往前的步长个元素属于第二批任务，依此类推</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(ConcurrentHashMap.Node&lt;K, V&gt;[] tab, ConcurrentHashMap.Node&lt;K, V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 复制的步长，最小不能小于16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE;</span><br><span class="line">    <span class="comment">// 如果扩容的新数组不存在，说明还没开始迁移，那就创建一个新数组</span></span><br><span class="line">    <span class="comment">// 上级调用方法保证第一次ConcurrentHashMap#transfer时，nextTab为null，而之后的线程调用时不为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 扩容，新数组容量翻倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) ConcurrentHashMap.Node&lt;K, V&gt;[] nt = (ConcurrentHashMap.Node&lt;K, V&gt;[]) <span class="keyword">new</span> ConcurrentHashMap.Node&lt;?, ?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// volatile更新，对后面的线程立即可见</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 扩容用的索引，从后向前的</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新数组的容量</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原数组中位置i处的节点全部搬到扩容的新数组后后，将该位置设为ForwardingNode，哈希值为MOVED，标志该位置已经处理了</span></span><br><span class="line"><span class="comment">     * 同时ForwardingNode也存放新数组，如果get的时候扩容没完成，哈希又定位到了原数组的该位置，那么从新数组查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConcurrentHashMap.ForwardingNode&lt;K, V&gt; fwd = <span class="keyword">new</span> ConcurrentHashMap.ForwardingNode&lt;K, V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 直到完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// 当一个线程完成了一个位置的搬运后，继续向前推进</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 从后向前，直到遇到本批任务的边界或者扩容已经完成，不过为什么是从后往前而不是从前往后？</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 说明原数组所有位置都分配了线程处理了，不需要继续了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// CAS尝试更新transferIndex，代表当前数组已被分配给线程的最新索引</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 本批任务的边界</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                <span class="comment">// 本批任务的开始索引，即步长范围为(bound, i)</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经全部搬运完成 || 已经搬运完成，transferIndex被别的线程CAS重置了？ || 没看懂</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 如果扩容已经全部完成</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 替换数组</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 下次扩容阈值为原数组容量的1.5倍，即新数组的0.75倍</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个线程开始帮助搬运前将sizeCtl加1，完成后要减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 第一个发起扩容的线程将sizeCtl修改为(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">// 注意下面的sc是上面CAS减1前的sizeCtl，当当前线程为唯一的扩容线程时，sc的低16位值应该为2</span></span><br><span class="line">                <span class="comment">// 下面的条件成立时说明当前还有其他线程正在扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="comment">// 扩容还没完，只是当前线程完了，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 说明所有扩容的线程都已经完成搬运</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * i重置为n，即数组的长度，下次循环时最后退出的线程就会从原数组从后往前遍历一遍检查所有的节点是否都是ForwardingNode，然后才用扩容的新数组替代原数组并退出</span></span><br><span class="line"><span class="comment">                 * 因为在if (--i &gt;= bound || finishing)这个判断后，i是肯定小于n的，不会满足if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn)这个退出条件</span></span><br><span class="line"><span class="comment">                 * mmp，Doug Lea太阴险了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                i = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果原数组的该位置为空，说明没有写入数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 直接用ForwardingNode标记已处理</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="comment">// ForwardingNode，说明该位置的节点已经被搬走了，可能是最后退出的线程在遍历检查</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该节点加锁，所以put和transfer会有竞争，因为在transfer复制的过程中发生了put增加了新节点，但是复制后的扩容数组没有，这显然是不行的</span></span><br><span class="line">            <span class="comment">// 但是get没有，因为transfer是拷贝完才更新数组，操作完成前不会被get线程看到，如果不巧get的节点刚好被搬走了，还可以在新数组里边查找</span></span><br><span class="line">            <span class="comment">// get和put的话，如果追加到链表尾，那么是对get线程立即可见的，如果加到红黑树，是有竞争的，get线程不会被阻塞，但是put线程可能会挂起</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// DCL，再次检查</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    ConcurrentHashMap.Node&lt;K, V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 说明是链表的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 0放在低位，即位置不变，否则放在高位，和HashMap一样，都是分成两条链表</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        ConcurrentHashMap.Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// 从头到尾遍历链表节点</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="comment">// 记录链表最后的runBit相同的连续节点的runBit，即分配到同一条链表的最后的连续几个节点</span></span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                <span class="comment">// 决定该分配到哪条链表</span></span><br><span class="line">                                runBit = b;</span><br><span class="line">                                <span class="comment">// 该段连续几个节点的起始节点</span></span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 该段的起始节点会被插到对应链表的尾部</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 从头到尾遍历链表节点，直到遇到上面找到的连续相同的节点的起始节点，避免了对那段的操作，因为直接把该段的起始节点插到链表尾就行了</span></span><br><span class="line">                        <span class="comment">// 这个优化真是，嗯，有点细致</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                            K pk = p.key;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                <span class="comment">// 这里链表方向反转了</span></span><br><span class="line">                                ln = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 高低位两条链表插入新数组</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 原数组该位置设为ForwardingNode，标记为已处理</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 说明是红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;</span><br><span class="line">                        ConcurrentHashMap.TreeBin&lt;K, V&gt; t = (ConcurrentHashMap.TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K, V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K, V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">// 当成链表遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            <span class="comment">// 创建新的红黑树节点</span></span><br><span class="line">                            ConcurrentHashMap.TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> ConcurrentHashMap.TreeNode&lt;K, V&gt;(h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 分割为高低两个双向链表</span></span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// ...</span></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// ...</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 红黑树链表过短就转为普通链表，否则创建新的红黑树</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != <span class="number">0</span>) ? <span class="keyword">new</span> ConcurrentHashMap.TreeBin&lt;K, V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != <span class="number">0</span>) ? <span class="keyword">new</span> ConcurrentHashMap.TreeBin&lt;K, V&gt;(hi) : t;</span><br><span class="line">                        <span class="comment">// 插入扩容后的新数组</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 原数组该位置用ForwardingNode标记</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap#resizeStamp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前数组的长度的二进制值中开头0的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Integer#numberOfLeadingZeros：计算一个Integer首部的0的数量</span></span><br><span class="line">    <span class="comment">// 0000 0000 0000 0000 1000 0000 0000 0000</span></span><br><span class="line">    <span class="comment">// 1是符号位，表示负数，用于后面的位移操作</span></span><br><span class="line">    <span class="comment">// 假设当前数组容量为16，那么方法返回 0000 0000 0000 0000 1000 0000 0001 0000</span></span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ConcurrentHashMap#size</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="comment">// Map大小是有可能超过Integer.MAX_VALUE的，但是因为方法接口的限制，最大只能返回Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 可以用ConcurrentHashMap#mappingCount替代，返回的是Long类型</span></span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> : (n &gt; (<span class="keyword">long</span>) Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>) n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>ConcurrentHashMap#get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt;[] tab;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt; e, p;</span><br><span class="line">    <span class="keyword">int</span> n, eh;</span><br><span class="line">    K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个就是</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ForwardingNode或TreeBin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 否则遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$ForwardingNode#find</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写find方法，用于在扩容后的数组中查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ConcurrentHashMap.<span class="function">Node&lt;K, V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt;[] tab = nextTable; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">// 扩容的新数组的该哈希的位置的元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> || (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> eh;</span><br><span class="line">            K ek;</span><br><span class="line">            <span class="comment">// 刚好找到就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp; ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="comment">// 说明是红黑树TreeBin或ForwardingNode</span></span><br><span class="line">            <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 扩容后又再次扩容了</span></span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConcurrentHashMap.ForwardingNode) &#123;</span><br><span class="line">                    tab = ((ConcurrentHashMap.ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                    <span class="keyword">continue</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从红黑树查找</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则向后遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConcurrentHashMap$TreeBin#find</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConcurrentHashMap.<span class="function">Node&lt;K, V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = first; e != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            K ek;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果当前树是等待或者写状态，则把树当成链表遍历查找</span></span><br><span class="line"><span class="comment">             * 因为如果有线程在写红黑树，链表的查找方式可以直接读，不用等红黑树的平衡完了才二分查找</span></span><br><span class="line"><span class="comment">             * 而如果有线程在等待写，那么也不能用二分查找，因为二分搜索时不能改变红黑树的结构，不能写</span></span><br><span class="line"><span class="comment">             * 个人觉得这个处理非常好，读完全不会被阻塞</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (((s = lockState) &amp; (WAITER | WRITER)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则CAS更新当前状态为读，成功则通过二叉树查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, LOCKSTATE, s, s + READER)) &#123;</span><br><span class="line">                ConcurrentHashMap.TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    p = ((r = root) == <span class="keyword">null</span> ? <span class="keyword">null</span> : r.findTreeNode(h, k, <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Thread w;</span><br><span class="line">                    <span class="comment">// 如果树没有别的读线程了，并且处于等待状态，并且等待线程不为空，说明还要唤醒等待的写线程</span></span><br><span class="line">                    <span class="comment">// 因为存在并发读，所以读线程读完了还要把加的值减回去，类似释放读锁</span></span><br><span class="line">                    <span class="keyword">if</span> (U.getAndAddInt(<span class="keyword">this</span>, LOCKSTATE, -READER) == (READER | WAITER) &amp;&amp; (w = waiter) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">// 查找完成则唤醒等待的写线程，可以写红黑树了</span></span><br><span class="line">                        LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>删除操作和添加操作基本类似。</p>
<p>ConcurrentHashMap#replaceNode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> || (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 所以如果要删除的元素在扩容后的新数组中，要等到扩容完成后才能在新数组查找</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = f, pred = <span class="keyword">null</span>; ; ) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                V ev = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev || (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                    oldVal = ev;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                        <span class="comment">// 删除</span></span><br><span class="line">                                        pred.next = e.next;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">// 删除的是头节点的话要重新插入数组</span></span><br><span class="line">                                        setTabAt(tab, i, e.next);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;</span><br><span class="line">                        validated = <span class="keyword">true</span>;</span><br><span class="line">                        ConcurrentHashMap.TreeBin&lt;K, V&gt; t = (ConcurrentHashMap.TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                        ConcurrentHashMap.TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                        <span class="comment">// 查找也是完全无锁的</span></span><br><span class="line">                        <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp; (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv || (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                oldVal = pv;</span><br><span class="line">                                <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                                <span class="comment">// 这里删除才会竞争红黑树的锁</span></span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                    setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                        addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>迭代操作关键代码：</p>
<p>ConcurrentHashMap$Traverser#advance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConcurrentHashMap.<span class="function">Node&lt;K, V&gt; <span class="title">advance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap.Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="comment">// HashMap的红黑树同时也是链表，所以红黑树或链表都当成链表遍历，直到链表尾</span></span><br><span class="line">    <span class="keyword">if</span> ((e = next) != <span class="keyword">null</span>)</span><br><span class="line">        e = e.next;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt;[] t;</span><br><span class="line">        <span class="keyword">int</span> i, n;</span><br><span class="line">        <span class="comment">// 有下一位直接返回就好</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> next = e;</span><br><span class="line">        <span class="comment">// 已经没了</span></span><br><span class="line">        <span class="keyword">if</span> (baseIndex &gt;= baseLimit || (t = tab) == <span class="keyword">null</span> || (n = t.length) &lt;= (i = index) || i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 数组该位置不是普通链表</span></span><br><span class="line">        <span class="keyword">if</span> ((e = tabAt(t, i)) != <span class="keyword">null</span> &amp;&amp; e.hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// ForwardingNode</span></span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConcurrentHashMap.ForwardingNode) &#123;</span><br><span class="line">                <span class="comment">// 从扩容的新数组查找</span></span><br><span class="line">                tab = ((ConcurrentHashMap.ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                e = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 入栈，保存状态，因为新数组查找完之后还要从原本的数组继续查找</span></span><br><span class="line">                pushState(t, i, n);</span><br><span class="line">                <span class="comment">// 下个循环继续</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin)</span><br><span class="line">                <span class="comment">// 红黑树当成链表用，从链表头开始</span></span><br><span class="line">                e = ((ConcurrentHashMap.TreeBin&lt;K, V&gt;) e).first;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>)</span><br><span class="line">            recoverState(n);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((index = i + baseSize) &gt;= n)</span><br><span class="line">            index = ++baseIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>总的来说，ConcurrentHashMap设计得十分精细，就是不明白为什么并发包很多无锁算法要简写地那么厉害，让阅读者看得有点累，而且省下来的那几个字可以提高性能么。。。@Doug Lea，快出来解释一下啊。</p>
<p>吭，简单说一下ConcurrentHashMap让我耳目一新的地方：</p>
<p>除了少部分地方使用了synchronized外，其它大部分地方都是用自旋+CAS+volatile+DCL模拟的轻量级锁；</p>
<p>synchronized只会锁住一个节点，缩小了锁的范围，而其它地方大量使用的CAS其实也是一个道理，各司其职，细化了范围，而不是直接加一个大锁；</p>
<p>在计算元素数量的时候，避免多个线程对baseCount的集中竞争修改，而是尝试分散到多个CounterCell中，最后计算的时候叠加起来就行了，虽然可能不准确；</p>
<p>还使用了@sun.misc.Contended注解避免伪共享，涉及操作系统底层的东西我也不了解，大概就是那个意思；</p>
<p>对于扩容，将原数组的元素划分为多批任务，分配给多个写线程并发进行，原本因为竞争而阻塞的线程还可以参与多线程扩容，这个想法，只能说，wow；</p>
<p>对于读，完全是无阻塞的，即使存在并发的修改或扩容，对于链表，因为使用了volatile修饰，修改是立即可见的，对于一棵红黑树，假如有修改的线程，那就退化为用链表的方式遍历查找，因为二叉树的搜索方式要求结构稳定，如果没有修改线程存在，那就使用更高效的红黑树查找。而假如搜索的位置刚好因为扩容被搬走了，则重定向到扩容后的新数组查找，完全无阻塞；</p>
<p>写和扩容是可能会有锁竞争的，不过范围缩小到了节点，为了避免扩容时复制遍历到新数组的过程中，删除或插入了新的节点，而扩容后的新数组中，已经删除的节点还存在，插入的节点却丢失这种情况；</p>
<p>另外写线程是可能被阻塞挂起的，不多说了，自己看代码吧。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
