<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-Netty-ServerBootstrap | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Netty-ServerBootstrap">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Netty-ServerBootstrap</h2>
				
				<div>
					<div class="post-time">2019-05-30</div>
				</div>
				
				<div class="article-content">
				<p>ServerBootstrap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * accept的客户端Channel设置的选项参数</span><br><span class="line">     */</span><br><span class="line">    private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * accept的客户端Channel设置的属性键值对</span><br><span class="line">     */</span><br><span class="line">    private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new LinkedHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * subReactor线程池，父类group为mainReactor线程池</span><br><span class="line">     */</span><br><span class="line">    private volatile EventLoopGroup childGroup;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * subReactor线程池的事件处理器，一般为ChannelInitializer初始化处理器链</span><br><span class="line">     */</span><br><span class="line">    private volatile ChannelHandler childHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractBootstrap#doBind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">    // 注册和绑定，两个异步事件，注册是指Channel注册到EventLoop，绑定是指Channel获得了本机一个TCP端口</span><br><span class="line">    final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    final Channel channel = regFuture.channel();</span><br><span class="line">    if (regFuture.cause() != null) &#123;</span><br><span class="line">        return regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    // 一般Channel异步注册完成，提交异步连接任务</span><br><span class="line">    if (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        // 绑定本地端口</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">    // 异步注册可能没完成</span><br><span class="line">    else &#123;</span><br><span class="line">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            // 注册完成时调用</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                // 注册过程中有异常则失败</span><br><span class="line">                if (cause != null) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                // 注册完成且成功</span><br><span class="line">                else &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractBootstrap#initAndRegister</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final ChannelFuture initAndRegister() &#123;</span><br><span class="line">    Channel channel = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 初始化Channel，初始化Pipeline</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        // 模板方法，子类实现</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (channel != null) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            // 还没有注册到EventLoop，使用默认线程GlobalEventExecutor</span><br><span class="line">            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将Channel注册到EventLoopGroup的某个EventLoop，注册NIO Channel到Selector</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line">    if (regFuture.cause() != null) &#123;</span><br><span class="line">        if (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerBootstrap#init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // 设置serverChannel的选项参数</span><br><span class="line">    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    synchronized (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置serverChannel的属性键值对</span><br><span class="line">    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    synchronized (attrs) &#123;</span><br><span class="line">        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : attrs.entrySet()) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;) AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    //</span><br><span class="line">    final EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    final ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    synchronized (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在启动线程中执行，initChannel方法将在Channel注册到的线程中执行</span><br><span class="line">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">            final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line"></span><br><span class="line">            // 用户添加的Handler</span><br><span class="line">            if (handler != null) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 保证ServerBootstrapAcceptor被添加到处理器链的最尾部</span><br><span class="line">            ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    pipeline.addLast(new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * ServerBootstrap的handler与childHandler:</span><br><span class="line">             * NioServerSocketChannel的pipeline中添加的是Handler与ServerBootstrapAcceptor</span><br><span class="line">             * handler在accept阶段起作用，处理客户端的连接请求</span><br><span class="line">             * 有新的客户端连接请求时，ServerBootstrapAcceptor#channelRead把childHandler添加到连接的NioSocketChannel对应的Pipeline，并将Channel注册到workerGroup的某个EventLoop</span><br><span class="line">             * childHandler在客户端连接建立以后起作用，负责客户端连接的IO</span><br><span class="line">             * */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadEventLoop#register<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, &quot;promise&quot;);</span><br><span class="line">    // 委托给AbstractUnsafe</span><br><span class="line">    promise.channel().unsafe().register(this, promise);</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#register<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注册</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">    if (eventLoop == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;eventLoop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRegistered()) &#123;</span><br><span class="line">        // 已经注册则失败</span><br><span class="line">        promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // EventLoop不兼容当前Channel</span><br><span class="line">    if (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 注册Channel到EventLoop</span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line">    // 当前线程为EventLoop线程直接执行</span><br><span class="line">    if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则提交任务给EventLoop线程执行（异步）</span><br><span class="line">    else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 由Channel绑定的EventLoop执行，这里会启动EventLoop线程</span><br><span class="line">            eventLoop.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;, AbstractChannel.this, t);</span><br><span class="line">            // 异常时关闭Channel</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#register0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        // 确保Channel没有关闭</span><br><span class="line">        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean firstRegistration = neverRegistered;</span><br><span class="line">        // JDK Channel注册到Selector，模板方法</span><br><span class="line">        // AbstractNioChannel#doRegister</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = false;</span><br><span class="line">        registered = true;</span><br><span class="line">        // 完成ChannelInitializer的回调，执行initChannel，将处理业务逻辑的用户Handler添加到ChannelPipeline</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        // 设置异步注册成功，触发回调</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        // 传播Channel注册事件，head开始</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        // 服务端ServerSocketChannel接受的客户端Channel此时已被激活</span><br><span class="line">        if (isActive()) &#123;</span><br><span class="line">            if (firstRegistration) &#123;</span><br><span class="line">                // 首次注册且激活触发Channel激活事件</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">            // 已设置autoRead</span><br><span class="line">            else if (config().isAutoRead()) &#123;</span><br><span class="line">                // 读取数据，模板方法</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // 模板方法</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioChannel#doRegister<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister() throws Exception &#123;</span><br><span class="line">    boolean selected = false;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将Channel注册到EventLoop的Selector上，0表示注册时不关心任何事件，attachment为Netty的Channel对象本身</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">            if (!selected) &#123;</span><br><span class="line">                // 选择键取消重新selectNow()，刷新因取消而缓存的选择键</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DefaultChannelPipeline#invokeHandlerAddedIfNeeded</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 两种情况（但是只执行一次）：</span><br><span class="line"> * AbstractUnsafe#register，fireChannelRegistered前被调用，异步注册完成就将所有Handler全部加入</span><br><span class="line"> * head节点的channelRegistered()方法</span><br><span class="line"> */</span><br><span class="line">final void invokeHandlerAddedIfNeeded() &#123;</span><br><span class="line">    assert channel.eventLoop().inEventLoop();</span><br><span class="line">    // 只执行一次</span><br><span class="line">    if (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = false;</span><br><span class="line">        // 可能是异步操作，不过基本不是</span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultChannelPipeline#callHandlerAddedForAllHandlers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerAddedForAllHandlers() &#123;</span><br><span class="line">    final PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // Pipeline，不是Channel</span><br><span class="line">        assert !registered;</span><br><span class="line">        // Pipeline已完成注册</span><br><span class="line">        registered = true;</span><br><span class="line">        pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;</span><br><span class="line">        // 帮助垃圾回收</span><br><span class="line">        this.pendingHandlerCallbackHead = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不在synchronized块内</span><br><span class="line">    PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">    while (task != null) &#123;</span><br><span class="line">        // 遍历链表依次执行</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractBootstrap#doBind0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void doBind0(final ChannelFuture regFuture, final Channel channel, final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    // Channel产生的IO事件始终由其注册到的线程处理，注册和绑定事件都在Channel注册到的EventLoop线程执行</span><br><span class="line">    channel.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (regFuture.isSuccess()) &#123;</span><br><span class="line">                // 绑定本地端口，出站事件</span><br><span class="line">                // AbstractChannel#bind</span><br><span class="line">                // Pipeline#bind</span><br><span class="line">                // Tail#bind</span><br><span class="line">                // AbstractChannelHandlerContext#bind</span><br><span class="line">                // --&gt; Head#bind</span><br><span class="line">                // AbstractUnsafe#bind</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractUnsafe#bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp; localAddress instanceof InetSocketAddress &amp;&amp; !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp; !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line"></span><br><span class="line">        logger.warn(&quot;A non-root user can&apos;t receive a broadcast packet if the socket &quot; + &quot;is not bound to a wildcard address; binding to a non-wildcard &quot; + &quot;address (&quot; + localAddress + &quot;) anyway as requested.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean wasActive = isActive();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 模板方法，JDK Channel绑定端口</span><br><span class="line">        // NioServerSocketChannel#doBind</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        // 当Channel不再打开时关闭Channel</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Channel绑定完成后触发Active事件</span><br><span class="line">    if (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        // 向Channel注册到的EventLoop提交一个任务</span><br><span class="line">        invokeLater(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置回调</span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelActive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    // 自动读取</span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#readIfIsAutoRead<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void readIfIsAutoRead() &#123;</span><br><span class="line">    // Channel激活后，如果配置了自动读取，则会调用channel.read()</span><br><span class="line">    // 由tail开始，调用unsafe.beginRead()设置关心底层read事件，激活后自动读取数据</span><br><span class="line">    // 当读取完一组数据后，channelReadComplete()方法中继续下一组数据的自动读取</span><br><span class="line">    if (channel.config().isAutoRead()) &#123;</span><br><span class="line">        // AbstractChannel#read</span><br><span class="line">        // Pipeline#read</span><br><span class="line">        // Tail#read</span><br><span class="line">        // AbstractChannelHandlerContext#read</span><br><span class="line">        // --&gt; Head#read</span><br><span class="line">        // AbstractUnsafe#beginRead</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#beginRead<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void beginRead() &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    if (!isActive()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // AbstractNioChannel#doBeginRead</span><br><span class="line">        // AbstractNioMessageChannel#doBeginRead</span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; catch (final Exception e) &#123;</span><br><span class="line">        invokeLater(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pipeline.fireExceptionCaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioMessageChannel#doBeginRead<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doBeginRead() throws Exception &#123;</span><br><span class="line">    if (inputShutdown) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    super.doBeginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioChannel#doBeginRead</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doBeginRead() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    final SelectionKey selectionKey = this.selectionKey;</span><br><span class="line">    if (!selectionKey.isValid()) &#123;</span><br><span class="line">        // 选择键被取消</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置底层读事件正在进行</span><br><span class="line">    readPending = true;</span><br><span class="line"></span><br><span class="line">    final int interestOps = selectionKey.interestOps();</span><br><span class="line">    if ((interestOps &amp; readInterestOp) == 0) &#123;</span><br><span class="line">        // 关心Read事件</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioMessageUnsafe#read</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void read() &#123;</span><br><span class="line">    assert eventLoop().inEventLoop();</span><br><span class="line">    final ChannelConfig config = config();</span><br><span class="line">    final ChannelPipeline pipeline = pipeline();</span><br><span class="line">    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    boolean closed = false;</span><br><span class="line">    Throwable exception = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                // 模板方法，NioServerSocketChannel#doReadMessages</span><br><span class="line">                int localRead = doReadMessages(readBuf);</span><br><span class="line">                // 没有数据可读</span><br><span class="line">                if (localRead == 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 读取出错</span><br><span class="line">                if (localRead &lt; 0) &#123;</span><br><span class="line">                    closed = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; while (allocHandle.continueReading());</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int size = readBuf.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            readPending = false;</span><br><span class="line">            // 触发ChannelRead事件</span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readBuf.clear();</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        // 触发ChannelReadComplete事件</span><br><span class="line">        // ChannelReadComplete事件中如果配置autoRead则会调用beginRead，从而不断进行读操作</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        if (exception != null) &#123;</span><br><span class="line">            // ServerChannel异常也不能关闭，应该恢复读取下一个客户端</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (closed) &#123;</span><br><span class="line">            inputShutdown = true;</span><br><span class="line">            if (isOpen()) &#123;</span><br><span class="line">                // 非serverChannel且打开则关闭</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            // 清除read事件，不再关心</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioServerSocketChannel#doReadMessages</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // 接受连接</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        if (ch != null) &#123;</span><br><span class="line">            // 一个NioSocketChannel为一条消息，此NioSocketChannel的父Channel是该NioServerSocketChannel</span><br><span class="line">            buf.add(new NioSocketChannel(this, ch));</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Failed to create a new channel from an accepted socket.&quot;, t);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (Throwable t2) &#123;</span><br><span class="line">            logger.warn(&quot;Failed to close a socket.&quot;, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelRead</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerBootstrap#ServerBootstrapAcceptor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private final EventLoopGroup childGroup;</span><br><span class="line">    private final ChannelHandler childHandler;</span><br><span class="line">    private final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;</span><br><span class="line">    private final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;</span><br><span class="line">    private final Runnable enableAutoReadTask;</span><br><span class="line"></span><br><span class="line">    ServerBootstrapAcceptor(final Channel channel, EventLoopGroup childGroup, ChannelHandler childHandler, Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">        this.childGroup = childGroup;</span><br><span class="line">        this.childHandler = childHandler;</span><br><span class="line">        this.childOptions = childOptions;</span><br><span class="line">        this.childAttrs = childAttrs;</span><br><span class="line"></span><br><span class="line">        enableAutoReadTask = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                channel.config().setAutoRead(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void forceClose(Channel child, Throwable t) &#123;</span><br><span class="line">        child.unsafe().closeForcibly();</span><br><span class="line">        logger.warn(&quot;Failed to register an accepted channel: &#123;&#125;&quot;, child, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * OP_ACCEPT事件抽象为channelRead事件</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line"></span><br><span class="line">        // 服务器接受的客户端Channel</span><br><span class="line">        final Channel child = (Channel) msg;</span><br><span class="line">        // 设置处理器链</span><br><span class="line">        child.pipeline().addLast(childHandler);</span><br><span class="line">        // 设置Channel的选项参数</span><br><span class="line">        setChannelOptions(child, childOptions, logger);</span><br><span class="line">        // 设置Channel的属性键值对</span><br><span class="line">        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;</span><br><span class="line">            child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        // 将客户端Channel注册到subReactor线程池</span><br><span class="line">        try &#123;</span><br><span class="line">            childGroup.register(child).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    if (!future.isSuccess()) &#123;</span><br><span class="line">                        forceClose(child, future.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            forceClose(child, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        final ChannelConfig config = ctx.channel().config();</span><br><span class="line">        // ServerChannel产生异常时，暂停接受客户端连接，1s后恢复</span><br><span class="line">        if (config.isAutoRead()) &#123;</span><br><span class="line">            // 停止accept客户端Channel的连接</span><br><span class="line">            config.setAutoRead(false);</span><br><span class="line">            // 1秒后重新接受客户端Channel连接</span><br><span class="line">            ctx.channel().eventLoop().schedule(enableAutoReadTask, 1, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelReadComplete<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelReadComplete(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    ctx.fireChannelReadComplete();</span><br><span class="line">    // 自动读取下一组数据</span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NioServerSocketChannel下面代码不会执行。</p>
<p>NioServerSocketChannel只支持bind、read和close。</p>
<p>这个是给NioDatagramChannel用的。</p>
<p>AbstractChannelHandlerContext#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(msg, &quot;msg&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (isNotValidPromise(promise, true)) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final AbstractChannelHandlerContext next = findContextOutbound(flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    final Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 不在EventLoop线程执行的就提交执行</span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        final AbstractWriteTask task;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line"></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</span><br><span class="line">    // AbstractUnsafe#write</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractUnsafe#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void write(Object msg, ChannelPromise promise) &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    if (outboundBuffer == null) &#123;</span><br><span class="line">        // 见close，outboundBuffer为空表示Channel正在关闭，禁止写数据</span><br><span class="line">        safeSetFailure(promise, newWriteException(initialCloseCause));</span><br><span class="line">        // 释放</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 可对消息进行过滤整理，例如把HeapBuffer转为DirectBuffer，具体实现由子类负责</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        if (size &lt; 0) &#123;</span><br><span class="line">            size = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#flush<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void flush(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    // AbstractUnsafe#flush</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#flush</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void flush() &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    // 引入了一个写缓冲区ChannelOutboundBuffer，由该缓冲区控制Channel的可写状态</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    if (outboundBuffer == null) &#123;</span><br><span class="line">        // Channel正在关闭直接返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    // 执行真正的底层写操作</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractUnsafe#flush0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">protected void flush0() &#123;</span><br><span class="line">    // 正在flush</span><br><span class="line">    if (inFlush0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    // Channel正在关闭或者已没有需要写的数据</span><br><span class="line">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFlush0 = true;</span><br><span class="line"></span><br><span class="line">    if (!isActive()) &#123;</span><br><span class="line">        // Channel已经非激活，将所有进行中的写请求标记为失败</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isOpen()) &#123;</span><br><span class="line">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            inFlush0 = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 模板方法</span><br><span class="line">        // AbstractNioByteChannel#doWrite</span><br><span class="line">        // AbstractNioMessageChannel#doWrite</span><br><span class="line">        doWrite(outboundBuffer);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (t instanceof IOException &amp;&amp; config().isAutoClose()) &#123;</span><br><span class="line"></span><br><span class="line">            initialCloseCause = t;</span><br><span class="line">            close(voidPromise(), t, newFlush0Exception(t), false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                shutdownOutput(voidPromise(), t);</span><br><span class="line">            &#125; catch (Throwable t2) &#123;</span><br><span class="line">                initialCloseCause = t;</span><br><span class="line">                close(voidPromise(), t2, newFlush0Exception(t), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        inFlush0 = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractNioMessageChannel#doWrite<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">    final SelectionKey key = selectionKey();</span><br><span class="line">    final int interestOps = key.interestOps();</span><br><span class="line"></span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // key.isWritable()</span><br><span class="line">            if ((interestOps &amp; SelectionKey.OP_WRITE) != 0) &#123;</span><br><span class="line">                // 取消关心</span><br><span class="line">                key.interestOps(interestOps &amp; ~SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean done = false;</span><br><span class="line">            for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                // ServerChannel一般是不写的，不会关心这个事件</span><br><span class="line">                if (doWriteMessage(msg, in)) &#123;</span><br><span class="line">                    done = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (done) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                if ((interestOps &amp; SelectionKey.OP_WRITE) == 0) &#123;</span><br><span class="line">                    key.interestOps(interestOps | SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (continueOnWriteError()) &#123;</span><br><span class="line">                in.remove(e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
