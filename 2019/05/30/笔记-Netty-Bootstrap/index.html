<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-Netty-Bootstrap | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Netty-Bootstrap">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Netty-Bootstrap</h2>
				
				<div>
					<div class="post-time">2019-05-30</div>
				</div>
				
				<div class="article-content">
				<p>AbstractBootstrap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程池</span><br><span class="line">     */</span><br><span class="line">    volatile EventLoopGroup group;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 一般是HandlerInitializer</span><br><span class="line">     */</span><br><span class="line">    private volatile ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bootstrap#doResolveAndConnect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;</span><br><span class="line">    // 父类方法，初始化Channel并注册到EventLoop，注册Selector，返回Future</span><br><span class="line">    final ChannelFuture regFuture = initAndRegister();</span><br><span class="line"></span><br><span class="line">    final Channel channel = regFuture.channel();</span><br><span class="line">    // 异步注册完成</span><br><span class="line">    if (regFuture.isDone()) &#123;</span><br><span class="line">        if (!regFuture.isSuccess()) &#123;</span><br><span class="line">            return regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        // 异步注册完成且成功，异步连接</span><br><span class="line">        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125;</span><br><span class="line">    // 异步注册未完成，完成时提交异步连接任务</span><br><span class="line">    else &#123;</span><br><span class="line">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                if (cause != null) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doResolveAndConnect0(channel, remoteAddress, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractBootstrap#initAndRegister</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final ChannelFuture initAndRegister() &#123;</span><br><span class="line">    Channel channel = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 初始化Channel，初始化Pipeline</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        // 模板方法，子类实现</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (channel != null) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            // 还没有注册到EventLoop，使用默认线程GlobalEventExecutor</span><br><span class="line">            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将Channel注册到EventLoopGroup的某个EventLoop，注册NIO Channel到Selector</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line">    if (regFuture.cause() != null) &#123;</span><br><span class="line">        if (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bootstrap#init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    // 设置Handler，一般是ChannelInitializer，实现了ChannelInboundHandler</span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line"></span><br><span class="line">    // 设置Channel的选项参数</span><br><span class="line">    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    synchronized (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置Channel的属性键值对</span><br><span class="line">    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    synchronized (attrs) &#123;</span><br><span class="line">        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : attrs.entrySet()) &#123;</span><br><span class="line">            channel.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleThreadEventLoop#register<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, &quot;promise&quot;);</span><br><span class="line">    // 委托给AbstractUnsafe</span><br><span class="line">    promise.channel().unsafe().register(this, promise);</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#register<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注册</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">    if (eventLoop == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;eventLoop&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRegistered()) &#123;</span><br><span class="line">        // 已经注册则失败</span><br><span class="line">        promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // EventLoop不兼容当前Channel</span><br><span class="line">    if (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 注册Channel到EventLoop</span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line">    // 当前线程为EventLoop线程直接执行，比如unregister再register</span><br><span class="line">    if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则提交任务给EventLoop线程执行（异步）</span><br><span class="line">    else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 由Channel绑定的EventLoop执行，这里会启动EventLoop线程</span><br><span class="line">            eventLoop.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;, AbstractChannel.this, t);</span><br><span class="line">            // 异常时关闭Channel</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#register0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line"></span><br><span class="line">        // 确保Channel没有关闭</span><br><span class="line">        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean firstRegistration = neverRegistered;</span><br><span class="line">        // JDK Channel注册到Selector，模板方法</span><br><span class="line">        // AbstractNioChannel#doRegister</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = false;</span><br><span class="line">        registered = true;</span><br><span class="line">        // 完成ChannelInitializer的回调，执行initChannel，将处理业务逻辑的用户Handler添加到ChannelPipeline</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        // 设置异步注册成功，触发回调</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        // 传播Channel注册事件，head开始</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        // 服务端ServerSocketChannel接受的客户端Channel此时已被激活</span><br><span class="line">        if (isActive()) &#123;</span><br><span class="line">            if (firstRegistration) &#123;</span><br><span class="line">                // 首次注册且激活触发Channel激活事件</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">            // 已设置autoRead</span><br><span class="line">            else if (config().isAutoRead()) &#123;</span><br><span class="line">                // 读取数据，模板方法</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // 模板方法</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioChannel#doRegister<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister() throws Exception &#123;</span><br><span class="line">    boolean selected = false;</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将Channel注册到EventLoop的Selector上，0表示注册时不关心任何事件，attachment为Netty的Channel对象本身</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">            if (!selected) &#123;</span><br><span class="line">                // 选择键取消重新selectNow()，刷新因取消而缓存的选择键</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DefaultChannelPipeline#invokeHandlerAddedIfNeeded</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 两种情况（但是只执行一次）：</span><br><span class="line"> * AbstractUnsafe#register，fireChannelRegistered前被调用，异步注册完成就将所有Handler全部加入</span><br><span class="line"> * head节点的channelRegistered()方法</span><br><span class="line"> */</span><br><span class="line">final void invokeHandlerAddedIfNeeded() &#123;</span><br><span class="line">    assert channel.eventLoop().inEventLoop();</span><br><span class="line">    // 只执行一次</span><br><span class="line">    if (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = false;</span><br><span class="line">        // 可能是异步操作，不过基本不是</span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultChannelPipeline#callHandlerAddedForAllHandlers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void callHandlerAddedForAllHandlers() &#123;</span><br><span class="line">    final PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        // Pipeline，不是Channel</span><br><span class="line">        assert !registered;</span><br><span class="line">        // Pipeline已完成注册</span><br><span class="line">        registered = true;</span><br><span class="line">        pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;</span><br><span class="line">        // 帮助垃圾回收</span><br><span class="line">        this.pendingHandlerCallbackHead = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 不在synchronized块内</span><br><span class="line">    PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">    while (task != null) &#123;</span><br><span class="line">        // 遍历链表依次执行</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Bootstrap#doResolveAndConnect0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 获取绑定的EventLoop</span><br><span class="line">        final EventLoop eventLoop = channel.eventLoop();</span><br><span class="line">        // 地址解析</span><br><span class="line">        final AddressResolver&lt;SocketAddress&gt; resolver = this.resolver.getResolver(eventLoop);</span><br><span class="line"></span><br><span class="line">        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;</span><br><span class="line">            // 向Channel注册的EventLoop提交异步连接任务</span><br><span class="line">            doConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Future&lt;SocketAddress&gt; resolveFuture = resolver.resolve(remoteAddress);</span><br><span class="line"></span><br><span class="line">        if (resolveFuture.isDone()) &#123;</span><br><span class="line">            final Throwable resolveFailureCause = resolveFuture.cause();</span><br><span class="line">            if (resolveFailureCause != null) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">                promise.setFailure(resolveFailureCause);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                doConnect(resolveFuture.getNow(), localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line">        // 回调</span><br><span class="line">        resolveFuture.addListener(new FutureListener&lt;SocketAddress&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(Future&lt;SocketAddress&gt; future) throws Exception &#123;</span><br><span class="line">                if (future.cause() != null) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                    promise.setFailure(future.cause());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    doConnect(future.getNow(), localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable cause) &#123;</span><br><span class="line">        promise.tryFailure(cause);</span><br><span class="line">    &#125;</span><br><span class="line">    return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bootstrap#doConnect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) &#123;</span><br><span class="line"></span><br><span class="line">    final Channel channel = connectPromise.channel();</span><br><span class="line">    // 由Channel绑定的EventLoop执行</span><br><span class="line">    channel.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (localAddress == null) &#123;</span><br><span class="line">                // AbstractChannel#connect</span><br><span class="line">                // Pipeline#connect</span><br><span class="line">                // Tail#connect(AbstractChannelHandlerContext#connect)</span><br><span class="line">                // --&gt;</span><br><span class="line">                // Head#connect(AbstractNioUnsafe#connect)</span><br><span class="line">                channel.connect(remoteAddress, connectPromise);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">            &#125;</span><br><span class="line">            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractNioUnsafe#connect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void connect(final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;</span><br><span class="line">    // Channel已被关闭</span><br><span class="line">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 已经在连接</span><br><span class="line">        if (connectPromise != null) &#123;</span><br><span class="line">            throw new ConnectionPendingException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean wasActive = isActive();</span><br><span class="line">        // 模板方法</span><br><span class="line">        // NioSocketChannel#doConnect</span><br><span class="line">        if (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">            // 连接已完成，设置异步结果为成功并触发Channel的Active事件</span><br><span class="line">            fulfillConnectPromise(promise, wasActive);</span><br><span class="line">        &#125;</span><br><span class="line">        // 连接可能未完成</span><br><span class="line">        else &#123;</span><br><span class="line">            connectPromise = promise;</span><br><span class="line">            requestedRemoteAddress = remoteAddress;</span><br><span class="line"></span><br><span class="line">            // Netty的连接超时</span><br><span class="line">            int connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">            if (connectTimeoutMillis &gt; 0) &#123;</span><br><span class="line">                // 向EventLoop提交一个调度任务，超时时间已到，则设置异步结果失败然后关闭连接</span><br><span class="line">                connectTimeoutFuture = eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;</span><br><span class="line">                        ConnectTimeoutException cause = new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);</span><br><span class="line">                        if (connectPromise != null &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                            close(voidPromise());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            promise.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    // 连接操作取消，则连接超时检测任务取消</span><br><span class="line">                    if (future.isCancelled()) &#123;</span><br><span class="line">                        if (connectTimeoutFuture != null) &#123;</span><br><span class="line">                            connectTimeoutFuture.cancel(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connectPromise = null;</span><br><span class="line">                        close(voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        promise.tryFailure(annotateConnectException(t, remoteAddress));</span><br><span class="line">        closeIfClosed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioSocketChannel#doConnect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">    if (localAddress != null) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        if (!connected) &#123;</span><br><span class="line">            // 关心OP_CONNECT事件，就绪时调用AbstractNioUnsafe#finishConnect</span><br><span class="line">            // JDK中的Channel在非阻塞模式下调用connect()方法时，会立即返回</span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = true;</span><br><span class="line">        return connected;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractNioUnsafe#finishConnect</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void finishConnect() &#123;</span><br><span class="line">    // 只由EventLoop处理就绪SelectionKey的OP_CONNECT事件时调用，完成连接，连接被取消或超时不会调用</span><br><span class="line">    assert eventLoop().inEventLoop();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        boolean wasActive = isActive();</span><br><span class="line">        // 模板方法</span><br><span class="line">        doFinishConnect();</span><br><span class="line">        // 首次Active触发Active事件</span><br><span class="line">        fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        if (connectTimeoutFuture != null) &#123;</span><br><span class="line">            // 连接完成，取消超时检测任务</span><br><span class="line">            connectTimeoutFuture.cancel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        connectPromise = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractNioUnsafe#fulfillConnectPromise</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) &#123;</span><br><span class="line">    if (promise == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean active = isActive();</span><br><span class="line"></span><br><span class="line">    // false表示取消操作</span><br><span class="line">    boolean promiseSet = promise.trySuccess();</span><br><span class="line"></span><br><span class="line">    // 调用前没激活 &amp;&amp; 现在已激活</span><br><span class="line">    if (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        // 触发Active事件</span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!promiseSet) &#123;</span><br><span class="line">        // 操作已被取消，关闭Channel</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelActive</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelActive(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    // 自动读取</span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#readIfIsAutoRead<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void readIfIsAutoRead() &#123;</span><br><span class="line">    // Channel激活后，如果配置了自动读取，则会调用channel.read()</span><br><span class="line">    // 由tail开始，调用unsafe.beginRead()设置关心底层read事件，激活后自动读取数据</span><br><span class="line">    // 当读取完一组数据后，channelReadComplete()方法中继续下一组数据的自动读取</span><br><span class="line">    if (channel.config().isAutoRead()) &#123;</span><br><span class="line">        // AbstractChannel#read</span><br><span class="line">        // Pipeline#read</span><br><span class="line">        // Tail#read</span><br><span class="line">        // AbstractChannelHandlerContext#read</span><br><span class="line">        // --&gt; Head#read</span><br><span class="line">        // AbstractUnsafe#beginRead</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#beginRead<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void beginRead() &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    if (!isActive()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // AbstractNioChannel#doBeginRead</span><br><span class="line">        // AbstractNioMessageChannel#doBeginRead</span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; catch (final Exception e) &#123;</span><br><span class="line">        invokeLater(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pipeline.fireExceptionCaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioChannel#doBeginRead</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doBeginRead() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    final SelectionKey selectionKey = this.selectionKey;</span><br><span class="line">    if (!selectionKey.isValid()) &#123;</span><br><span class="line">        // 选择键被取消</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置底层读事件正在进行</span><br><span class="line">    readPending = true;</span><br><span class="line"></span><br><span class="line">    final int interestOps = selectionKey.interestOps();</span><br><span class="line">    if ((interestOps &amp; readInterestOp) == 0) &#123;</span><br><span class="line">        // 关心Read事件</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NioByteUnsafe#read</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void read() &#123;</span><br><span class="line">    final ChannelConfig config = config();</span><br><span class="line">    if (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    final ChannelPipeline pipeline = pipeline();</span><br><span class="line">    final ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = null;</span><br><span class="line">    boolean close = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 创建一个ByteBuf</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            // 模板方法</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            // 没有数据可读</span><br><span class="line">            if (allocHandle.lastBytesRead() &lt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = null;</span><br><span class="line">                // 读取数据量为负，对端已关闭</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; 0;</span><br><span class="line">                if (close) &#123;</span><br><span class="line">                    readPending = false;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(1);</span><br><span class="line">            readPending = false;</span><br><span class="line">            // 触发ChannelRead事件，用户处理</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = null;</span><br><span class="line">        &#125; while (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        // ReadComplete结束时，如果开启autoRead则会调用beginRead，继续read</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        if (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">        // 读事件没在进行 &amp;&amp; 没有配置autoRead</span><br><span class="line">        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            // 移除</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelRead</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#channelReadComplete<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void channelReadComplete(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    ctx.fireChannelReadComplete();</span><br><span class="line">    // 自动读取下一组数据</span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractChannelHandlerContext#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(msg, &quot;msg&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (isNotValidPromise(promise, true)) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final AbstractChannelHandlerContext next = findContextOutbound(flush ? (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);</span><br><span class="line">    final Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    if (executor.inEventLoop()) &#123;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 不在EventLoop线程执行的就提交执行</span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        final AbstractWriteTask task;</span><br><span class="line">        if (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!safeExecute(executor, task, promise, m)) &#123;</span><br><span class="line"></span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</span><br><span class="line">    // AbstractUnsafe#write</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractUnsafe#write</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void write(Object msg, ChannelPromise promise) &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    if (outboundBuffer == null) &#123;</span><br><span class="line">        // 见close，outboundBuffer为空表示Channel正在关闭，禁止写数据</span><br><span class="line">        safeSetFailure(promise, newWriteException(initialCloseCause));</span><br><span class="line">        // 释放</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int size;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 可对消息进行过滤整理，例如把HeapBuffer转为DirectBuffer，具体实现由子类负责</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        if (size &lt; 0) &#123;</span><br><span class="line">            size = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeadContext#flush<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void flush(ChannelHandlerContext ctx) &#123;</span><br><span class="line">    // AbstractUnsafe#flush</span><br><span class="line">    unsafe.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractUnsafe#flush</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void flush() &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line">    // 引入了一个写缓冲区ChannelOutboundBuffer，由该缓冲区控制Channel的可写状态</span><br><span class="line">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    if (outboundBuffer == null) &#123;</span><br><span class="line">        // Channel正在关闭直接返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    outboundBuffer.addFlush();</span><br><span class="line">    // 执行真正的底层写操作</span><br><span class="line">    flush0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractUnsafe#flush0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">protected void flush0() &#123;</span><br><span class="line">    // 正在flush</span><br><span class="line">    if (inFlush0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</span><br><span class="line">    // Channel正在关闭或者已没有需要写的数据</span><br><span class="line">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inFlush0 = true;</span><br><span class="line"></span><br><span class="line">    if (!isActive()) &#123;</span><br><span class="line">        // Channel已经非激活，将所有进行中的写请求标记为失败</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isOpen()) &#123;</span><br><span class="line">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            inFlush0 = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        // 模板方法</span><br><span class="line">        // AbstractNioByteChannel#doWrite</span><br><span class="line">        // AbstractNioMessageChannel#doWrite</span><br><span class="line">        doWrite(outboundBuffer);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        if (t instanceof IOException &amp;&amp; config().isAutoClose()) &#123;</span><br><span class="line"></span><br><span class="line">            initialCloseCause = t;</span><br><span class="line">            close(voidPromise(), t, newFlush0Exception(t), false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                shutdownOutput(voidPromise(), t);</span><br><span class="line">            &#125; catch (Throwable t2) &#123;</span><br><span class="line">                initialCloseCause = t;</span><br><span class="line">                close(voidPromise(), t2, newFlush0Exception(t), false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        inFlush0 = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractNioByteChannel#doWrite<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</span><br><span class="line">    int writeSpinCount = config().getWriteSpinCount();</span><br><span class="line">    do &#123;</span><br><span class="line">        Object msg = in.current();</span><br><span class="line">        // 数据已全部写完</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // 清除OP_WRITE事件</span><br><span class="line">            clearOpWrite();</span><br><span class="line"></span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writeSpinCount -= doWriteInternal(in, msg);</span><br><span class="line">    &#125; while (writeSpinCount &gt; 0);</span><br><span class="line">    // 将ByteBuf的数据写入Channel，NIO写操作返回已写入的数据量，非阻塞模式下可能为0，此时调用incompleteWrite()方法</span><br><span class="line">    incompleteWrite(writeSpinCount &lt; 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioByteChannel#doWriteInternal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private int doWriteInternal(ChannelOutboundBuffer in, Object msg) throws Exception &#123;</span><br><span class="line">    if (msg instanceof ByteBuf) &#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        // ByteBuf不可读，此时数据已写完</span><br><span class="line">        if (!buf.isReadable()) &#123;</span><br><span class="line">            // 完成时，清理缓冲区</span><br><span class="line">            in.remove();</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 模板方法</span><br><span class="line">        final int localFlushedAmount = doWriteBytes(buf);</span><br><span class="line">        // 返回已写入的数据量，NIO在非阻塞模式下写操作可能返回0表示未写入数据</span><br><span class="line">        if (localFlushedAmount &gt; 0) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            if (!buf.isReadable()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // FileRegion是Netty对NIO底层的FileChannel的封装，负责将File中的数据写入到WritableChannel中</span><br><span class="line">    else if (msg instanceof FileRegion) &#123;</span><br><span class="line">        FileRegion region = (FileRegion) msg;</span><br><span class="line">        if (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">            in.remove();</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long localFlushedAmount = doWriteFileRegion(region);</span><br><span class="line">        if (localFlushedAmount &gt; 0) &#123;</span><br><span class="line">            in.progress(localFlushedAmount);</span><br><span class="line">            if (region.transferred() &gt;= region.count()) &#123;</span><br><span class="line">                in.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 其他类型不支持</span><br><span class="line">        throw new Error();</span><br><span class="line">    &#125;</span><br><span class="line">    return WRITE_STATUS_SNDBUF_FULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AbstractNioByteChannel#incompleteWrite<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final void incompleteWrite(boolean setOpWrite) &#123;</span><br><span class="line">    // 未写入数据：设置SelectionKey继续关心OP_WRITE事件，继续进行写操作</span><br><span class="line">    if (setOpWrite) &#123;</span><br><span class="line">        // 设置继续关心OP_WRITE事件</span><br><span class="line">        setOpWrite();</span><br><span class="line">    &#125;</span><br><span class="line">    // 写操作次数达到writeSpinCount但没写完</span><br><span class="line">    else &#123;</span><br><span class="line">        // 清除</span><br><span class="line">        clearOpWrite();</span><br><span class="line">        // 向EventLoop提交一个新的flush任务，此时可以响应其他请求，不会占用全部资源使其他请求得不到响应</span><br><span class="line">        eventLoop().execute(flushTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
