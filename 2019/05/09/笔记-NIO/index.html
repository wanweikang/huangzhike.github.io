<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <script>
            var timeStart = new Date();
        </script>
        
        <title>[笔记]-NIO | 🌑🌒🌓🌔🌕🌖🌗🌘</title>
        
        <meta name="author" content="huangzhike">
        
        
        <meta name="description" content="参考1参考2
06-25补充
IO

基于流(Stream oriented)，面向字节流或字符流，顺序地从一个流中读取一个或多个字节，不能随意改变位置，同一个流仅支持读或写；

阻塞，比如读取一个文件的内容，线程会被阻塞直到操作完成。


NIO

基于缓冲区(Buffer oriented)，从">
        
        
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        
        <meta property="og:title" content="[笔记]-NIO"/>
        
        <meta property="og:site_name" content="🌑🌒🌓🌔🌕🌖🌗🌘"/>
        
        
        <!-- favicon -->
        <link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
        <meta name="msapplication-TileColor" content="#009688">
        <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
        <meta name="theme-color" content="#009688">
        <!-- favicon end -->
        <!-- <link href="//ok.ico" rel="icon"> -->
        
        <!-- toc -->
        <!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
        <!-- material design -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
        <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
        
        <!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
        <!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
    <meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" title="下一句是：客有可人期不来。小时候，喜欢靠在阳台上，一边吹风，一边看书，喜欢读书吗，骚年？" href="/">书当快意读易尽</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-NIO</h2>
				
				<div>
					<div class="post-time">2019-05-09</div>
				</div>
				
				<div class="article-content">
				<p><a href="https://www.cnblogs.com/fwnboke/p/8529604.html" target="_blank" rel="noopener">参考1</a><br><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">参考2</a></p>
<p><strong>06-25补充</strong></p>
<p>IO</p>
<ul>
<li><p>基于流(Stream oriented)，面向字节流或字符流，顺序地从一个流中读取一个或多个字节，不能随意改变位置，同一个流仅支持读或写；</p>
</li>
<li><p>阻塞，比如读取一个文件的内容，线程会被阻塞直到操作完成。</p>
</li>
</ul>
<p>NIO</p>
<ul>
<li><p>基于缓冲区(Buffer oriented)，从Channel中读取数据到Buffer中，或将数据从Buffer中写入到Channel，可以读写任意位置的数据；</p>
</li>
<li><p>非阻塞，比如从网络中读取数据，在非阻塞模式中，如果此时有数据，则读取并返回，如果此时没有数据，则直接返回，不阻塞当前线程（支持非阻塞读写）；</p>
</li>
<li><p>引入Selector，一个线程可以监听多个Channel的IO事件，当向一个Selector中注册了Channel后，Selector自动select注册的Channel是否有已就绪的IO事件(可读，可写，网络连接完成等)。</p>
</li>
</ul>
<ul>
<li><p>如果要管理同时打开的多个连接，这些连接每次只发送少量数据，如IM服务器，NIO比较合适。</p>
</li>
<li><p>如果要维持多个打开的连接到其他主机，如P2P网络，使用单线程管理所有出站连接，可能比较好。</p>
</li>
</ul>
<p>核心：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<hr>
<ul>
<li><p>同步：如果有多个任务或事件要发生，串行执行；</p>
</li>
<li><p>异步：如果有多个任务或事件要发生，并行执行，一个事件或任务的执行不会导致整个流程等待。</p>
</li>
<li><p>阻塞：某个事件或任务在执行过程中，发出一个请求，如果该请求需要的条件不满足，就一直等待至条件满足；</p>
</li>
<li><p>非阻塞：某个事件或任务在执行过程中，发出一个请求，如果该请求需要的条件不满足，立即返回一个标志信息告知条件不满足。</p>
</li>
</ul>
<p>通常IO操作包括：对硬盘的读写、对Socket的读写以及外设的读写。</p>
<p>当用户线程发起一个IO请求操作，内核先查看要读取的数据是否就绪。</p>
<p>对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；</p>
<p>对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。</p>
<p>数据就绪之后，将数据拷贝到用户线程，一个完整的IO读请求操作完成。</p>
<p>一个完整的IO读请求操作包括两个阶段：</p>
<ul>
<li><p>查看数据是否就绪；</p>
</li>
<li><p>进行数据拷贝（内核将数据拷贝到用户线程）。</p>
</li>
</ul>
<p>阻塞（Blocking IO）和非阻塞（Non-Blocking IO）的区别在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p>
<p>Java中传统的IO都是阻塞IO，比如通过Socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞，直到有数据才返回；如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直等待。</p>
<ul>
<li><p>同步IO：用户线程请求IO操作，如果数据没有就绪，用户线程或者内核不断轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程，在IO操作完成之前，该线程会被阻塞；</p>
</li>
<li><p>异步IO：用户线程请求IO操作，IO操作的两个阶段都由内核完成，然后发送通知告知用户线程IO操作已经完成，不会导致请求线程被阻塞。</p>
</li>
</ul>
<p>同步IO和异步IO的关键在数据拷贝阶段是由用户线程完成还是内核完成，所以说异步IO必须要操作系统支持。</p>
<p>阻塞IO和非阻塞IO反映在当用户请求IO操作时，如果数据没有就绪，用户线程是一直等待数据就绪，还是收到一个标志信息。即反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。</p>
<hr>
<p>五种IO模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO、异步IO。</p>
<ul>
<li>阻塞IO模型</li>
</ul>
<p>用户线程发出IO请求后，内核查看数据是否就绪，如果没有就绪就等待数据就绪，而用户线程会处于阻塞状态。当就绪之后，内核将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除阻塞。</p>
<pre><code>data = socket.read();</code></pre><ul>
<li>非阻塞IO模型</li>
</ul>
<p>用户线程发出IO请求后，马上就得到一个结果标志。如果数据还没有准备好，它可以再次发出IO请求。一旦内核中的数据准备好了，并且再次收到了用户线程的请求，那就将数据拷贝到用户线程，然后返回。用户线程需要不断轮询内核数据是否就绪，也就是会一直占用CPU。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    data <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token operator">!=</span> error<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 处理数据</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>多路复用IO模型</li>
</ul>
<p>Java NIO实际上是多路复用IO。<br>有一个线程不断去轮询多个Socket的状态，只有当Socket真正有读写事件时，才真正调用实际的IO读写操作。只需要一个线程就可以管理多个Socket，并且只有在真正有Socket读写事件进行时，才会使用IO资源。Java NIO中，通过Selector#select查询每个通道是否有事件，如果没有则阻塞。在非阻塞IO中，轮询Socket状态是用户线程进行的，在多路复用IO中，是内核进行，效率要高的多。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//  事先调用epoll_ctl注册感兴趣的事件到epollfd</span>
<span class="token keyword">while</span> <span class="token boolean">true</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 返回触发注册事件的流</span>
    active_stream<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epollfd<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 无须遍历所有的流</span>
    <span class="token keyword">for</span> i in active_stream<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
        read or write till
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>信号驱动IO模型</li>
</ul>
<p>用户线程发起IO请求，会给对应的Socket注册一个信号函数，然后用户线程继续执行，内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作进行实际的IO操作。</p>
<ul>
<li>异步IO模型</li>
</ul>
<p>用户线程发起IO请求后，立刻可以继续其它的事。内核收到异步请求后，立刻返回，不会阻塞用户线程。内核等待数据准备完成，然后将数据拷贝到用户线程，一切完成后，内核给用户线程发送一个信号，通知操作完成。用户线程不需要关心整个IO操作，只要先发起一个请求，当接收内核返回的成功信号就可以直接使用数据。在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，都是由内核自动完成，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要用户线程操作。异步IO需要操作系统的底层支持，Java 7提供了Asynchronous IO。前面四种IO模型都属于同步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第二个阶段（内核进行数据拷贝）都会引起用户线程阻塞。</p>
<hr>
<ul>
<li><p>Reactor模式：先对每个Client注册感兴趣的事件，然后有一个线程专门去轮询每个Client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便继续下一轮轮询。多路复用IO就是采用Reactor模式。为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。</p>
</li>
<li><p>Proactor模式：当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成。异步IO模型采用的就是Proactor模式。</p>
</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>
    <!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
    <!-- material design -->
    <!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
    <!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
    <!-- toc -->
    <!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
    <!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
    <!-- <script src="/js/main.js"></script> -->
    <script src="/js/prism.js"></script>
</body>
</html>
