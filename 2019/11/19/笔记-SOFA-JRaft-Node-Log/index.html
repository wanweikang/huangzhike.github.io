<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-SOFA-JRaft-Node-Log | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-SOFA-JRaft-Node-Log">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-SOFA-JRaft-Node-Log</h2>
				
				<div>
					<div class="post-time">2019-11-19</div>
				</div>
				
				<div class="article-content">
				<p>Snapshot和Configuration部分暂时没有关注。</p>
<hr>
<p>以Counter为例，略过CounterClient和CounterServer的实现</p>
<p>Leader收到写请求</p>
<p>IncrementAndGetRequestProcessor#handleRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> BizContext bizCtx, <span class="keyword">final</span> AsyncContext asyncCtx, <span class="keyword">final</span> IncrementAndGetRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前Server不是Leader</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.counterServer.getFsm().isLeader()) &#123;</span><br><span class="line">        <span class="comment">// 返回重定向响应，包含了Leader的PeerId</span></span><br><span class="line">        asyncCtx.sendResponse(<span class="keyword">this</span>.counterServer.redirect());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前Server是Leader，处理写请求</span></span><br><span class="line">    <span class="keyword">final</span> ValueResponse response = <span class="keyword">new</span> ValueResponse();</span><br><span class="line">    <span class="comment">// 创建回调</span></span><br><span class="line">    <span class="keyword">final</span> IncrementAndAddClosure closure = <span class="keyword">new</span> IncrementAndAddClosure(counterServer, request, response, status -&gt; &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            response.setErrorMsg(status.getErrorMsg());</span><br><span class="line">            response.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 应用到状态机成功，返回应答</span></span><br><span class="line"><span class="comment">         * 这里有个问题，如果Leader在应用日志后崩溃，响应客户端失败，然后Client重试新的Leader，则会导致重复日志和执行</span></span><br><span class="line"><span class="comment">         * 为了实现幂等，请求应该携带一个唯一标识，Server执行前先校验</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        asyncCtx.sendResponse(response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建任务</span></span><br><span class="line">        <span class="keyword">final</span> Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        <span class="comment">// 设置回调</span></span><br><span class="line">        task.setDone(closure);</span><br><span class="line">        <span class="comment">// 填充请求数据</span></span><br><span class="line">        task.setData(ByteBuffer.wrap(SerializerManager.getSerializer(SerializerManager.Hessian2).serialize(request)));</span><br><span class="line">        <span class="comment">// 尝试发布日志，等待应用</span></span><br><span class="line">        counterServer.getNode().apply(task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CodecException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NodeImpl#apply</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Task task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点正在关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 提交给回调线程池，执行失败回调</span></span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.ENODESHUTDOWN, <span class="string">"Node is shutting down."</span>));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Node is shutting down"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Requires.requireNonNull(task, <span class="string">"Null task"</span>);</span><br><span class="line">    <span class="comment">// 创建一个Log条目</span></span><br><span class="line">    <span class="keyword">final</span> LogEntry entry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">    entry.setData(task.getData());</span><br><span class="line">    <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;LogEntryAndClosure&gt; translator = (event, sequence) -&gt; &#123;</span><br><span class="line">            event.reset();</span><br><span class="line">            event.done = task.getDone();</span><br><span class="line">            event.entry = entry;</span><br><span class="line">            event.expectedTerm = task.getExpectedTerm();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 重试发布事件</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 发布到RingBuffer成功</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applyQueue.tryPublishEvent(translator)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="comment">// 超出重试次数</span></span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; MAX_APPLY_RETRY_TIMES) &#123;</span><br><span class="line">                    <span class="comment">// 提交给回调线程池，执行失败回调</span></span><br><span class="line">                    Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.EBUSY, <span class="string">"Node is busy, has too many tasks."</span>));</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Thread#yield</span></span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        <span class="comment">// 提交给回调线程池，执行失败回调</span></span><br><span class="line">        Utils.runClosureInThread(task.getDone(), <span class="keyword">new</span> Status(RaftError.EPERM, <span class="string">"Node is down."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leader处理日志事件</p>
<p>NodeImpl$LogEntryAndClosureHandler#onEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> LogEntryAndClosure event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在关闭</span></span><br><span class="line">    <span class="keyword">if</span> (event.shutdownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 事件列表不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.tasks.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 批量执行任务</span></span><br><span class="line">            executeApplyingTasks(<span class="keyword">this</span>.tasks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num = GLOBAL_NUM_NODES.decrementAndGet();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        event.shutdownLatch.countDown();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常情况，先将事件加入任务列表</span></span><br><span class="line">    <span class="keyword">this</span>.tasks.add(event);</span><br><span class="line">    <span class="comment">// 如果事件数量大于批量执行的数量，默认32 || 有批量结束的标记</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.tasks.size() &gt;= NodeImpl.<span class="keyword">this</span>.raftOptions.getApplyBatch() || endOfBatch) &#123;</span><br><span class="line">        <span class="comment">// 批量执行任务</span></span><br><span class="line">        executeApplyingTasks(<span class="keyword">this</span>.tasks);</span><br><span class="line">        <span class="comment">// 执行完就清空任务</span></span><br><span class="line">        <span class="keyword">this</span>.tasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NodeImpl#executeApplyingTasks</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeApplyingTasks</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntryAndClosure&gt; tasks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实Disruptor这里是MPSC的，即单线程消费，所以理论上这里不会有并发写的问题</span></span><br><span class="line">    <span class="comment">// 猜测这里加写锁是为了处理可见性的问题，避免没写完成就被读到</span></span><br><span class="line">    <span class="comment">// 如果数据不是很大并且实时要求不高的话，也可以使用CopyOnWrite，读的时候是无锁的</span></span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = tasks.size();</span><br><span class="line">        <span class="comment">// Leader才能执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_LEADER) &#123;</span><br><span class="line">            <span class="comment">// 回调，略</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">        <span class="comment">// 遍历事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> LogEntryAndClosure task = tasks.get(i);</span><br><span class="line">            <span class="comment">// 如果Leader发布事件时的任期和现在的当前任期不一致</span></span><br><span class="line">            <span class="keyword">if</span> (task.expectedTerm != -<span class="number">1</span> &amp;&amp; task.expectedTerm != <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">                <span class="comment">// 回调，略</span></span><br><span class="line">                <span class="comment">// 跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将任务追加到投票箱的队列，Leader收到大多数Follower的日志响应后会调用BallotBox#commitAt取出任务提交并执行状态机</span></span><br><span class="line">            <span class="comment">// 如果失败</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.ballotBox.appendPendingTask(<span class="keyword">this</span>.conf.getConf(), <span class="keyword">this</span>.conf.isStable() ? <span class="keyword">null</span> : <span class="keyword">this</span>.conf.getOldConf(), task.done)) &#123;</span><br><span class="line">                <span class="comment">// 提交给回调线程池，执行对应的失败回调</span></span><br><span class="line">                Utils.runClosureInThread(task.done, <span class="keyword">new</span> Status(RaftError.EINTERNAL, <span class="string">"Fail to append task."</span>));</span><br><span class="line">                <span class="comment">// 跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task.entry.getId().setTerm(<span class="keyword">this</span>.currTerm);</span><br><span class="line">            task.entry.setType(EnumOutter.EntryType.ENTRY_TYPE_DATA);</span><br><span class="line">            <span class="comment">// 暂存日志事件</span></span><br><span class="line">            entries.add(task.entry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将日志加入LogManager，包含了回调LeaderStableClosure</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, <span class="keyword">new</span> LeaderStableClosure(entries));</span><br><span class="line">        <span class="comment">// update conf.first</span></span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="keyword">this</span>.logManager.checkAndSetConfiguration(<span class="keyword">this</span>.conf);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogManagerImpl#appendEntries追加日志持久化见后面，这里略</p>
<hr>
<p>Leader发送空白条目，HeartBeat或Probe</p>
<p>Replicator#sendEmptyEntries</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendEmptyEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat, <span class="keyword">final</span> RpcResponseClosure&lt;AppendEntriesResponse&gt; heartBeatClosure)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="comment">// Leader为每个Follower维护了一个NextIndex，表示下一个需要发送的Log的Index，Leader上台后初始化为本地日志LastLogIndex+1</span></span><br><span class="line">    <span class="comment">// 先尝试填充常用的字段：Term，GroupId，ServerId，PeerId，PrevLogIndex，PrevLogTerm，CommittedIndex</span></span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, <span class="keyword">this</span>.nextIndex - <span class="number">1</span>, isHeartbeat)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">        <span class="comment">// 创建空的添加条目请求</span></span><br><span class="line">        <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line">        <span class="comment">// 如果是心跳</span></span><br><span class="line">        <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">            <span class="comment">// 心跳计数</span></span><br><span class="line">            <span class="keyword">this</span>.heartbeatCounter++;</span><br><span class="line">            <span class="comment">// 心跳应答的回调</span></span><br><span class="line">            RpcResponseClosure&lt;AppendEntriesResponse&gt; heartbeatDone;</span><br><span class="line">            <span class="keyword">if</span> (heartBeatClosure != <span class="keyword">null</span>) &#123;</span><br><span class="line">                heartbeatDone = heartBeatClosure;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                heartbeatDone = <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 心跳响应回调</span></span><br><span class="line">                        onHeartbeatReturned(Replicator.<span class="keyword">this</span>.id, status, request, getResponse(), monotonicSendTimeMs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// RPC发送心跳，返回Future</span></span><br><span class="line">            <span class="keyword">this</span>.heartbeatInFly = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(), request, <span class="keyword">this</span>.options.getElectionTimeoutMs() / <span class="number">2</span>, heartbeatDone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是Probe请求，因为Leader需要知道Follower当前的Log位置，方便同步</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 日志输出用</span></span><br><span class="line">            <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.firstLogIndex = <span class="keyword">this</span>.nextIndex;</span><br><span class="line">            <span class="keyword">this</span>.statInfo.lastLogIndex = <span class="keyword">this</span>.nextIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.appendEntriesCounter++;</span><br><span class="line">            <span class="keyword">this</span>.state = State.Probe;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stateVersion = <span class="keyword">this</span>.version;</span><br><span class="line">            <span class="comment">// 先返回全局序列号，再自增</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();</span><br><span class="line">            <span class="comment">// RPC发送Probe，返回Future</span></span><br><span class="line">            <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(), request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// Probe响应回调</span></span><br><span class="line">                    onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request, getResponse(), seq, stateVersion, monotonicSendTimeMs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 发送后添加一个Inflight入队列</span></span><br><span class="line">            addInflight(RequestType.AppendEntries, <span class="keyword">this</span>.nextIndex, <span class="number">0</span>, <span class="number">0</span>, seq, rpcFuture);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放Replicator的锁</span></span><br><span class="line">        <span class="keyword">this</span>.id.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Replicator#fillCommonFields</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fillCommonFields</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest.Builder rb, <span class="keyword">long</span> prevLogIndex, <span class="keyword">final</span> <span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取该Index的Log对应的Term</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> prevLogTerm = <span class="keyword">this</span>.options.getLogManager().getTerm(prevLogIndex);</span><br><span class="line">    <span class="keyword">if</span> (prevLogTerm == <span class="number">0</span> &amp;&amp; prevLogIndex != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    rb.setTerm(<span class="keyword">this</span>.options.getTerm()); <span class="comment">// Leader的任期</span></span><br><span class="line">    rb.setGroupId(<span class="keyword">this</span>.options.getGroupId()); <span class="comment">// 集群名称</span></span><br><span class="line">    rb.setServerId(<span class="keyword">this</span>.options.getServerId().toString()); <span class="comment">// Leader的ServerId</span></span><br><span class="line">    rb.setPeerId(<span class="keyword">this</span>.options.getPeerId().toString()); <span class="comment">// 对端Follower的PeerId</span></span><br><span class="line">    rb.setPrevLogIndex(prevLogIndex); <span class="comment">// 上次发送的Log的Index</span></span><br><span class="line">    rb.setPrevLogTerm(prevLogTerm); <span class="comment">// 上次发送的Log的Term</span></span><br><span class="line">    rb.setCommittedIndex(<span class="keyword">this</span>.options.getBallotBox().getLastCommittedIndex()); <span class="comment">// Leader的Log的提交位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Follower收到Heartbeat或Probe或追加日志请求</p>
<p>NodeImpl#handleAppendEntriesRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">handleAppendEntriesRequest</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> RpcRequestClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesCount = request.getEntriesCount();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 节点未激活，响应异常</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isActive()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> PeerId serverId = <span class="keyword">new</span> PeerId();</span><br><span class="line">        <span class="comment">// 解析对端ServerId异常，响应异常</span></span><br><span class="line">        <span class="keyword">if</span> (!serverId.parse(request.getServerId())) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对端的任期比自己当前的任期小，不接受日志</span></span><br><span class="line">        <span class="keyword">if</span> (request.getTerm() &lt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">// 通知对方Leader下台</span></span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时对端Leader的任期肯定是大于等于自身任期的，判断是否需要更新任期</span></span><br><span class="line">        checkStepDown(request.getTerm(), serverId);</span><br><span class="line">        <span class="comment">// 对端Leader不是当前节点的Leader</span></span><br><span class="line">        <span class="keyword">if</span> (!serverId.equals(<span class="keyword">this</span>.leaderId)) &#123;</span><br><span class="line">            <span class="comment">// 提升本地任期，当前Leader下次心跳后就会下台，减少分脑的影响</span></span><br><span class="line">            stepDown(request.getTerm() + <span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">new</span> Status(RaftError.ELEADERCONFLICT, <span class="string">"More than one leader in the same term."</span>));</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(request.getTerm() + <span class="number">1</span>) <span class="comment">// 让对端Leader也下台，重新选举</span></span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一切正常，更新Leader通信时间戳</span></span><br><span class="line">        updateLastLeaderTimestamp(Utils.monotonicMs());</span><br><span class="line">        <span class="comment">// 节点安装Snapshot的时候不接受日志</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.snapshotExecutor.isInstallingSnapshot()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Leader上次同步的Log的Index</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogIndex = request.getPrevLogIndex();</span><br><span class="line">        <span class="comment">// Leader上次同步的Log的Term</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prevLogTerm = request.getPrevLogTerm();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> localPrevLogTerm = <span class="keyword">this</span>.logManager.getTerm(prevLogIndex);</span><br><span class="line">        <span class="comment">// 一致性检查，同一个Index的Log，但Term不一致，不接受日志</span></span><br><span class="line">        <span class="keyword">if</span> (localPrevLogTerm != prevLogTerm) &#123;</span><br><span class="line">            <span class="comment">// 本地的最后一条Log的索引</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastLogIndex = <span class="keyword">this</span>.logManager.getLastLogIndex();</span><br><span class="line">            <span class="keyword">return</span> AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">false</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">// 自己当前的任期</span></span><br><span class="line">                    .setLastLogIndex(lastLogIndex) <span class="comment">// 通知对方Leader发送Log的起点</span></span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 空的说明是Heartbeat或Probe</span></span><br><span class="line">        <span class="keyword">if</span> (entriesCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 心跳响应包含自己的任期，方便对方检查</span></span><br><span class="line">            <span class="keyword">final</span> AppendEntriesResponse.Builder respBuilder = AppendEntriesResponse.newBuilder() <span class="comment">//</span></span><br><span class="line">                    .setSuccess(<span class="keyword">true</span>) <span class="comment">//</span></span><br><span class="line">                    .setTerm(<span class="keyword">this</span>.currTerm) <span class="comment">// 自己当前的任期</span></span><br><span class="line">                    .setLastLogIndex(<span class="keyword">this</span>.logManager.getLastLogIndex()); <span class="comment">// Follower自己本地最后一条Log的Index</span></span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">            <span class="comment">// 同步Leader的Log提交位置，同时也会提交任务，应用到自己的状态机，所以Follower的状态机至少比Leader落后一个心跳</span></span><br><span class="line">            <span class="comment">// 取最小的一个，因为Follower日志可能落后</span></span><br><span class="line">            <span class="keyword">this</span>.ballotBox.setLastCommittedIndex(Math.min(request.getCommittedIndex(), prevLogIndex));</span><br><span class="line">            <span class="comment">// 返回心跳响应</span></span><br><span class="line">            <span class="keyword">return</span> respBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非空白的Log条目，追加日志</span></span><br><span class="line">        <span class="keyword">long</span> index = prevLogIndex;</span><br><span class="line">        <span class="comment">// 暂存要添加到本地的LogEntry列表</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;LogEntry&gt; entries = <span class="keyword">new</span> ArrayList&lt;&gt;(entriesCount);</span><br><span class="line">        ByteBuffer allData = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request.hasData()) &#123;</span><br><span class="line">            allData = request.getData().asReadOnlyByteBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;RaftOutter.EntryMeta&gt; entriesList = request.getEntriesList();</span><br><span class="line">        <span class="comment">// 遍历发送过来的日志条目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entriesCount; i++) &#123;</span><br><span class="line">            <span class="comment">// Log数据</span></span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta entry = entriesList.get(i);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (entry.getType() != EnumOutter.EntryType.ENTRY_TYPE_UNKNOWN) &#123;</span><br><span class="line">                <span class="comment">// 创建LogEntry</span></span><br><span class="line">                <span class="keyword">final</span> LogEntry logEntry = <span class="keyword">new</span> LogEntry();</span><br><span class="line">                <span class="comment">// LogIndex LogTerm</span></span><br><span class="line">                logEntry.setId(<span class="keyword">new</span> LogId(index, entry.getTerm()));</span><br><span class="line">                logEntry.setType(entry.getType());</span><br><span class="line">                <span class="keyword">if</span> (entry.hasChecksum()) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> dataLen = entry.getDataLen();</span><br><span class="line">                <span class="keyword">if</span> (dataLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果LogEntry包含了Peer数据</span></span><br><span class="line">                <span class="keyword">if</span> (entry.getPeersCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.getType() == EnumOutter.EntryType.ENTRY_TYPE_CONFIGURATION) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Validate checksum</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum() &amp;&amp; logEntry.isCorrupted()) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 添加LogEntry</span></span><br><span class="line">                entries.add(logEntry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> FollowerStableClosure closure = <span class="keyword">new</span> FollowerStableClosure(request, AppendEntriesResponse.newBuilder().setTerm(<span class="keyword">this</span>.currTerm), <span class="keyword">this</span>, done, <span class="keyword">this</span>.currTerm);</span><br><span class="line">        <span class="comment">// 将来自Leader的数据写入日志，传入了回调FollowerStableClosure</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.appendEntries(entries, closure);</span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="keyword">this</span>.logManager.checkAndSetConfiguration(<span class="keyword">this</span>.conf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower检查任期</p>
<p>NodeImpl#checkStepDown</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStepDown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> requestTerm, <span class="keyword">final</span> PeerId serverId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Status status = <span class="keyword">new</span> Status();</span><br><span class="line">    <span class="comment">// 正常情况下任期应该是一致的，大于的话就要更新任期，Leader的话还要转为Follower</span></span><br><span class="line">    <span class="keyword">if</span> (requestTerm &gt; <span class="keyword">this</span>.currTerm) &#123;</span><br><span class="line">        status.setError(RaftError.ENEWLEADER, <span class="string">"Raft node receives message from new leader with higher term."</span>);</span><br><span class="line">        stepDown(requestTerm, <span class="keyword">false</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任期一致，但是当前节点是Candidate，那么得转为Follower</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.state != State.STATE_FOLLOWER) &#123;</span><br><span class="line">        status.setError(RaftError.ENEWLEADER, <span class="string">"Candidate receives message from new leader with the same term."</span>);</span><br><span class="line">        stepDown(requestTerm, <span class="keyword">false</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Follower收到了一个任期一致的新Leader</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.leaderId.isEmpty()) &#123;</span><br><span class="line">        status.setError(RaftError.ENEWLEADER, <span class="string">"Follower receives message from new leader with the same term."</span>);</span><br><span class="line">        stepDown(requestTerm, <span class="keyword">false</span>, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存当前Leader</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.leaderId == <span class="keyword">null</span> || <span class="keyword">this</span>.leaderId.isEmpty()) &#123;</span><br><span class="line">        resetLeaderId(serverId, status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower设置日志提交位置</p>
<p>BallotBox#setLastCommittedIndex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setLastCommittedIndex</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> lastCommittedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> stamp = <span class="keyword">this</span>.stampedLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始状态下PendingIndex==0，PendingMetaQueue为空，否则说明节点变成了Leader</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pendingIndex != <span class="number">0</span> || !<span class="keyword">this</span>.pendingMetaQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不需要提交</span></span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &lt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedIndex &gt; <span class="keyword">this</span>.lastCommittedIndex) &#123;</span><br><span class="line">            <span class="comment">// 更新位置</span></span><br><span class="line">            <span class="keyword">this</span>.lastCommittedIndex = lastCommittedIndex;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 提交到状态机</span></span><br><span class="line">            <span class="keyword">this</span>.waiter.onCommitted(lastCommittedIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FSMCallerImpl#onCommitted</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCommitted</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> committedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成Committed事件，发布到状态机的RingBuffer</span></span><br><span class="line">    <span class="keyword">return</span> enqueueTask((task, sequence) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 任务类型为COMMITTED</span></span><br><span class="line">        task.type = TaskType.COMMITTED;</span><br><span class="line">        <span class="comment">// 提交的位置</span></span><br><span class="line">        task.committedIndex = committedIndex;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FSMCallerImpl#runApplyTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">runApplyTask</span><span class="params">(<span class="keyword">final</span> ApplyTask task, <span class="keyword">long</span> maxCommittedIndex, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">    CountDownLatch shutdown = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 提交日志</span></span><br><span class="line">    <span class="keyword">if</span> (task.type == TaskType.COMMITTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.committedIndex &gt; maxCommittedIndex) &#123;</span><br><span class="line">            maxCommittedIndex = task.committedIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (endOfBatch &amp;&amp; maxCommittedIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.currTask = TaskType.COMMITTED;</span><br><span class="line">            <span class="comment">// 执行提交</span></span><br><span class="line">            doCommitted(maxCommittedIndex);</span><br><span class="line">            maxCommittedIndex = -<span class="number">1L</span>; <span class="comment">// reset maxCommittedIndex</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.currTask = TaskType.IDLE;</span><br><span class="line">        <span class="keyword">return</span> maxCommittedIndex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FSMCallerImpl#doCommitted</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommitted</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> committedIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.error.getStatus().isOk()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> lastAppliedIndex = <span class="keyword">this</span>.lastAppliedIndex.get();</span><br><span class="line">    <span class="comment">// 忽略乱序</span></span><br><span class="line">    <span class="keyword">if</span> (lastAppliedIndex &gt;= committedIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startMs = Utils.monotonicMs();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Closure&gt; closures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> List&lt;TaskClosure&gt; taskClosures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// Closure由Leader收到Client消息后创建并加入队列，在这里批量取出并填充到TaskClosure列表和Closure列表，返回第一个日志回调的索引</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> firstClosureIndex = <span class="keyword">this</span>.closureQueue.popClosureUntil(committedIndex, closures, taskClosures);</span><br><span class="line">        <span class="comment">// 遍历TaskClosure列表，调用TaskClosure#onCommitted方法，具体实现由客户自定义，这里默认啥也没干</span></span><br><span class="line">        onTaskCommitted(taskClosures);</span><br><span class="line">        Requires.requireTrue(firstClosureIndex &gt;= <span class="number">0</span>, <span class="string">"Invalid firstClosureIndex"</span>);</span><br><span class="line">        <span class="comment">// 迭代器</span></span><br><span class="line">        <span class="keyword">final</span> IteratorImpl iterImpl = <span class="keyword">new</span> IteratorImpl(<span class="keyword">this</span>.fsm, <span class="keyword">this</span>.logManager, closures, firstClosureIndex, lastAppliedIndex, committedIndex, <span class="keyword">this</span>.applyingIndex);</span><br><span class="line">        <span class="comment">// 直到应用完</span></span><br><span class="line">        <span class="keyword">while</span> (iterImpl.isGood()) &#123;</span><br><span class="line">            <span class="keyword">final</span> LogEntry logEntry = iterImpl.entry();</span><br><span class="line">            <span class="comment">// 非数据型的条目</span></span><br><span class="line">            <span class="keyword">if</span> (logEntry.getType() != EnumOutter.EntryType.ENTRY_TYPE_DATA) &#123;</span><br><span class="line">                <span class="comment">// 配置相关，略</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行任务，应用到状态机</span></span><br><span class="line">            doApplyTasks(iterImpl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iterImpl.hasError()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里状态机已应用完成</span></span><br><span class="line">        <span class="comment">// 本批最后一个应用的条目的上一个位置，暂时不知道为什么两个AppliedId不一样</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastIndex = iterImpl.getIndex() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> lastTerm = <span class="keyword">this</span>.logManager.getTerm(lastIndex);</span><br><span class="line">        <span class="keyword">final</span> LogId lastAppliedId = <span class="keyword">new</span> LogId(lastIndex, lastTerm);</span><br><span class="line">        <span class="comment">// 更新状态机的LastAppliedIndex</span></span><br><span class="line">        <span class="keyword">this</span>.lastAppliedIndex.set(committedIndex);</span><br><span class="line">        <span class="keyword">this</span>.lastAppliedTerm = lastTerm;</span><br><span class="line">        <span class="comment">// 更新LogManager的AppliedId，是一个LogId</span></span><br><span class="line">        <span class="keyword">this</span>.logManager.setAppliedId(lastAppliedId);</span><br><span class="line">        <span class="comment">// 回调通知</span></span><br><span class="line">        notifyLastAppliedIndexUpdated(committedIndex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IteratorImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IteratorImpl</span><span class="params">(<span class="keyword">final</span> StateMachine fsm, <span class="keyword">final</span> LogManager logManager, <span class="keyword">final</span> List&lt;Closure&gt; closures, <span class="keyword">final</span> <span class="keyword">long</span> firstClosureIndex, <span class="keyword">final</span> <span class="keyword">long</span> lastAppliedIndex, <span class="keyword">final</span> <span class="keyword">long</span> committedIndex, <span class="keyword">final</span> AtomicLong applyingIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.fsm = fsm;</span><br><span class="line">    <span class="keyword">this</span>.logManager = logManager;</span><br><span class="line">    <span class="keyword">this</span>.closures = closures;</span><br><span class="line">    <span class="keyword">this</span>.firstClosureIndex = firstClosureIndex;</span><br><span class="line">    <span class="keyword">this</span>.currentIndex = lastAppliedIndex;</span><br><span class="line">    <span class="keyword">this</span>.committedIndex = committedIndex;</span><br><span class="line">    <span class="keyword">this</span>.applyingIndex = applyingIndex;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IteratorImpl#next</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先释放当前条目</span></span><br><span class="line">    <span class="keyword">this</span>.currEntry = <span class="keyword">null</span>; <span class="comment">//release current entry</span></span><br><span class="line">    <span class="comment">// CurrentIndex初始为上批应用到的索引LastAppliedIndex，CommittedIndex为本批要应用到的日志索引</span></span><br><span class="line">    <span class="comment">// 如果离目标应用索引还有距离</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentIndex &lt;= <span class="keyword">this</span>.committedIndex) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.currentIndex;</span><br><span class="line">        <span class="comment">// 好吧</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentIndex &lt;= <span class="keyword">this</span>.committedIndex) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前要应用的条目</span></span><br><span class="line">                <span class="keyword">this</span>.currEntry = <span class="keyword">this</span>.logManager.getEntry(<span class="keyword">this</span>.currentIndex);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.currEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> LogEntryCorruptedException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前要应用的条目的索引</span></span><br><span class="line">            <span class="keyword">this</span>.applyingIndex.set(<span class="keyword">this</span>.currentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FSMCallerImpl#doApplyTasks</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doApplyTasks</span><span class="params">(<span class="keyword">final</span> IteratorImpl iterImpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IteratorWrapper iter = <span class="keyword">new</span> IteratorWrapper(iterImpl);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用状态机的实现</span></span><br><span class="line">        <span class="keyword">this</span>.fsm.onApply(iter);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般上面状态机应该已经应用完，不应该还有条目剩下</span></span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果本批日志还没应用完，后移指针到下一个条目，避免下次应用时条目被重复应用</span></span><br><span class="line">    <span class="comment">// 上面是原注释的翻译，不过这个Iterator是局部变量，线程返回后就没了，所以这个倒霉玩意估计是给LogManager设置AppliedId的</span></span><br><span class="line">    iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以Counter的状态机实现为例</p>
<p>CounterStateMachine#onApply</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApply</span><span class="params">(<span class="keyword">final</span> Iterator iter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历日志</span></span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">long</span> delta = <span class="number">0</span>;</span><br><span class="line">        IncrementAndAddClosure closure = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 说明当前是Leader，因为Closure的回调不会被复制到Follower</span></span><br><span class="line">        <span class="keyword">if</span> (iter.done() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前是Leader，可以直接从IncrementAndAddClosure中获取delta，避免反序列化</span></span><br><span class="line">            closure = (IncrementAndAddClosure) iter.done();</span><br><span class="line">            delta = closure.getRequest().getDelta();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其它节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 需要反序列化</span></span><br><span class="line">            <span class="keyword">final</span> ByteBuffer data = iter.getData();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> IncrementAndGetRequest request = SerializerManager.getSerializer(SerializerManager.Hessian2).deserialize(data.array(), IncrementAndGetRequest.class.getName());</span><br><span class="line">                delta = request.getDelta();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> CodecException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> prev = <span class="keyword">this</span>.value.get();</span><br><span class="line">        <span class="comment">// 更新状态机的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> updated = value.addAndGet(delta);</span><br><span class="line">        <span class="comment">// 更新后，返回响应</span></span><br><span class="line">        <span class="keyword">if</span> (closure != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closure.getResponse().setValue(updated);</span><br><span class="line">            closure.getResponse().setSuccess(<span class="keyword">true</span>);</span><br><span class="line">            closure.run(Status.OK());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一个</span></span><br><span class="line">        iter.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower添加日志</p>
<p>LogManagerImpl#appendEntries</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendEntries</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, <span class="keyword">final</span> StableClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果LogManager发生了错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasError) &#123;</span><br><span class="line">        <span class="comment">// 清空LogEntry</span></span><br><span class="line">        entries.clear();</span><br><span class="line">        <span class="comment">// 提交给回调线程池，执行对应回调</span></span><br><span class="line">        Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EIO, <span class="string">"Corrupted LogStorage"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// LogEntry列表不为空 &amp;&amp; 检查和解决冲突失败</span></span><br><span class="line">        <span class="keyword">if</span> (!entries.isEmpty() &amp;&amp; !checkAndResolveConflict(entries, done)) &#123;</span><br><span class="line">            <span class="comment">// 清空LogEntry</span></span><br><span class="line">            entries.clear();</span><br><span class="line">            <span class="comment">// 提交给回调线程池，执行对应回调</span></span><br><span class="line">            Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EINTERNAL, <span class="string">"Fail to checkAndResolveConflict."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历LogEntry</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> LogEntry entry = entries.get(i);</span><br><span class="line">            <span class="comment">// Set checksum after checkAndResolveConflict</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.raftOptions.isEnableLogEntryChecksum()) &#123;</span><br><span class="line">                entry.setChecksum(entry.checksum());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是配置型的条目</span></span><br><span class="line">            <span class="keyword">if</span> (entry.getType() == EntryType.ENTRY_TYPE_CONFIGURATION) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 更新配置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!entries.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 设置回调，本批日志的第一个日志的Index</span></span><br><span class="line">            done.setFirstLogIndex(entries.get(<span class="number">0</span>).getId().getIndex());</span><br><span class="line">            <span class="comment">// 先添加到缓存</span></span><br><span class="line">            <span class="keyword">this</span>.logsInMemory.addAll(entries);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置回调，日志列表</span></span><br><span class="line">        done.setEntries(entries);</span><br><span class="line">        <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 包装</span></span><br><span class="line">        <span class="keyword">final</span> EventTranslator&lt;StableClosureEvent&gt; translator = (event, sequence) -&gt; &#123;</span><br><span class="line">            event.reset();</span><br><span class="line">            event.type = EventType.OTHER;</span><br><span class="line">            event.done = done;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 重试发布</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 发布到LogManager的RingBuffer成功</span></span><br><span class="line">            <span class="keyword">if</span> (tryOfferEvent(done, translator)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retryTimes++;</span><br><span class="line">                <span class="comment">// 超过重试次数</span></span><br><span class="line">                <span class="keyword">if</span> (retryTimes &gt; APPEND_LOG_RETRY_TIMES) &#123;</span><br><span class="line">                    <span class="comment">// 发布到状态机的RingBuffer，调用状态机的onError方法</span></span><br><span class="line">                    reportError(RaftError.EBUSY.getNumber(), <span class="string">"LogManager is busy, disk queue overload."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Thread#yield</span></span><br><span class="line">                ThreadHelper.onSpinWait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doUnlock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 添加了新日志，这里是异步的，Leader的Log可能没有持久化成功，就开始向Follower发送Log了</span></span><br><span class="line"><span class="comment">         * 对于Leader来说，需要通知Follower，假如Leader在Replicator#sendEntries发送日志时没有新的日志，就会加入一个期待位置，新日志到达时回调，继续发送日志</span></span><br><span class="line"><span class="comment">         * 对于Follower来说，啥也不用干</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!wakeupAllWaiter(<span class="keyword">this</span>.writeLock)) &#123;</span><br><span class="line">            <span class="comment">// 监听器发布通知，默认没有监听器，需要自定义</span></span><br><span class="line">            notifyLastLogIndexListeners();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower解决日志冲突</p>
<p>LogManagerImpl#checkAndResolveConflict</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"NonAtomicOperationOnVolatileField"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndResolveConflict</span><span class="params">(<span class="keyword">final</span> List&lt;LogEntry&gt; entries, <span class="keyword">final</span> StableClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取LogEntry列表的第一个LogEntry</span></span><br><span class="line">    <span class="keyword">final</span> LogEntry firstLogEntry = ArrayDeque.peekFirst(entries);</span><br><span class="line">    <span class="comment">// 节点当前是Leader，并且日志来自用户，不知道Log应该分配的Index</span></span><br><span class="line">    <span class="keyword">if</span> (firstLogEntry.getId().getIndex() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entries.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 分配正确的LogIndex，由Follower本地的最后一个日志Index开始，先加再用</span></span><br><span class="line">            entries.get(i).getId().setIndex(++<span class="keyword">this</span>.lastLogIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点当前是Follower，并且日志来自Leader，需要检查和本地的日志冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要添加的第一个日志的Index和本地最后一条日志的Index相差1以上，说明存在日志空洞，拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (firstLogEntry.getId().getIndex() &gt; <span class="keyword">this</span>.lastLogIndex + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 提交到回调线程执行对应回调</span></span><br><span class="line">            Utils.runClosureInThread(done, <span class="keyword">new</span> Status(RaftError.EINVAL, <span class="string">"There's gap between first_index=%d and last_log_index=%d"</span>, firstLogEntry.getId().getIndex(), <span class="keyword">this</span>.lastLogIndex));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 应用到状态机的日志索引</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> appliedIndex = <span class="keyword">this</span>.appliedId.getIndex();</span><br><span class="line">        <span class="comment">// 要添加的最后一条日志</span></span><br><span class="line">        <span class="keyword">final</span> LogEntry lastLogEntry = ArrayDeque.peekLast(entries);</span><br><span class="line">        <span class="comment">// 要添加的最后一条日志的Index比已应用到状态机的Index还小，拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (lastLogEntry.getId().getIndex() &lt;= appliedIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要添加的第一条日志刚好接上了本地日志</span></span><br><span class="line">        <span class="keyword">if</span> (firstLogEntry.getId().getIndex() == <span class="keyword">this</span>.lastLogIndex + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// fast path</span></span><br><span class="line">            <span class="keyword">this</span>.lastLogIndex = lastLogEntry.getId().getIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在偏差，需要解决冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> conflictingIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 遍历LogEntry列表</span></span><br><span class="line">            <span class="keyword">for</span> (; conflictingIndex &lt; entries.size(); conflictingIndex++) &#123;</span><br><span class="line">                <span class="comment">// 先尝试从缓存中获取，不行再从持久化文件获取</span></span><br><span class="line">                <span class="comment">// 如果该Index对应的Log，Follower本地的Term和Leader的Term不一致</span></span><br><span class="line">                <span class="keyword">if</span> (unsafeGetTerm(entries.get(conflictingIndex).getId().getIndex()) != entries.get(conflictingIndex).getId().getTerm()) &#123;</span><br><span class="line">                    <span class="comment">// 不用检测后面的了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明Follower本地的Log和Leader的Log有冲突</span></span><br><span class="line">            <span class="keyword">if</span> (conflictingIndex != entries.size()) &#123;</span><br><span class="line">                <span class="comment">// 冲突的日志在列表的起始位置</span></span><br><span class="line">                <span class="comment">// 冲突的起始日志的Index比本地最后一条日志小或等于</span></span><br><span class="line">                <span class="keyword">if</span> (entries.get(conflictingIndex).getId().getIndex() &lt;= <span class="keyword">this</span>.lastLogIndex) &#123;</span><br><span class="line">                    <span class="comment">// 删除本地之后的日志，以Leader的为准，这里是先更新LastLogIndex，再发布到LogManager的RingBuffer，异步删除</span></span><br><span class="line">                    unsafeTruncateSuffix(entries.get(conflictingIndex).getId().getIndex() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.lastLogIndex = lastLogEntry.getId().getIndex();</span><br><span class="line">            &#125; <span class="comment">// else this is a duplicated AppendEntriesRequest, we have nothing to do besides releasing all the entries</span></span><br><span class="line">            <span class="comment">// 删除没有冲突的重复Log条目，不需要重复添加</span></span><br><span class="line">            <span class="keyword">if</span> (conflictingIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Remove duplication</span></span><br><span class="line">                entries.subList(<span class="number">0</span>, conflictingIndex).clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower从RingBuffer中消费事件，日志持久化刷盘</p>
<p>LogManagerImpl$StableClosureEventHandler#onEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> StableClosureEvent event, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> endOfBatch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果LogManager要关闭</span></span><br><span class="line">    <span class="keyword">if</span> (event.type == EventType.SHUTDOWN) &#123;</span><br><span class="line">        <span class="comment">// 先刷盘</span></span><br><span class="line">        <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush();</span><br><span class="line">        setDiskId(<span class="keyword">this</span>.lastId);</span><br><span class="line">        LogManagerImpl.<span class="keyword">this</span>.shutDownLatch.countDown();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> StableClosure done = event.done;</span><br><span class="line">    <span class="comment">// 回调包含Log条目</span></span><br><span class="line">    <span class="keyword">if</span> (done.getEntries() != <span class="keyword">null</span> &amp;&amp; !done.getEntries().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 批量写入Log，在刷盘后会执行对应的回调</span></span><br><span class="line">        <span class="keyword">this</span>.ab.append(done);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush();</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> LAST_LOG_ID:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRUNCATE_PREFIX:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRUNCATE_SUFFIX:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESET:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            reportError(RaftError.EIO.getNumber(), <span class="string">"Failed operation in LogStorage"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            done.run(Status.OK());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endOfBatch) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lastId = <span class="keyword">this</span>.ab.flush();</span><br><span class="line">        setDiskId(<span class="keyword">this</span>.lastId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogManagerImpl$AppendBatcher#append</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> StableClosure done)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.cap || <span class="keyword">this</span>.bufferSize &gt;= LogManagerImpl.<span class="keyword">this</span>.raftOptions.getMaxAppendBufferSize()) &#123;</span><br><span class="line">        <span class="comment">// 先把原来的Log刷盘，执行回调</span></span><br><span class="line">        flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再把本次任务的加入缓存</span></span><br><span class="line">    <span class="keyword">this</span>.storage.add(done);</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">this</span>.toAppend.addAll(done.getEntries());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> LogEntry entry : done.getEntries()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize += entry.getData() != <span class="keyword">null</span> ? entry.getData().remaining() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogManagerImpl$AppendBatcher#flush</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LogId <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把Log列表持久化</span></span><br><span class="line">        <span class="keyword">this</span>.lastId = appendToStorage(<span class="keyword">this</span>.toAppend);</span><br><span class="line">        <span class="comment">// 遍历每批的Log列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.size; i++) &#123;</span><br><span class="line">            <span class="comment">// 清掉</span></span><br><span class="line">            <span class="keyword">this</span>.storage.get(i).getEntries().clear();</span><br><span class="line">            <span class="comment">// 有异常就执行异常对应的回调</span></span><br><span class="line">            <span class="keyword">if</span> (LogManagerImpl.<span class="keyword">this</span>.hasError) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 执行刷盘回调</span></span><br><span class="line">                <span class="comment">// 对于Follower，是FollowerStableClosure，提交Leader同步过来的CommittedIndex，并响应Leader</span></span><br><span class="line">                <span class="comment">// 对于Leader，是LeaderStableClosure，尝试提交CommitIndex，其实执行的方法和收到Follower响应时是一样的，只有收到大多数节点响应时才会真正提交</span></span><br><span class="line">                <span class="comment">// 至于为什么Leader这里持久化日志后也会尝试提交，因为Leader也是节点，即自己响应自己，和投票是同一个道理</span></span><br><span class="line">                <span class="keyword">this</span>.storage.get(i).run(Status.OK());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置</span></span><br><span class="line">        <span class="keyword">this</span>.toAppend.clear();</span><br><span class="line">        <span class="keyword">this</span>.storage.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.bufferSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Follower日志持久化后执行回调，更新日志提交位置</p>
<p>NodeImpl$FollowerStableClosure</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FollowerStableClosure</span><span class="params">(<span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> AppendEntriesResponse.Builder responseBuilder, <span class="keyword">final</span> NodeImpl node, <span class="keyword">final</span> RpcRequestClosure done, <span class="keyword">final</span> <span class="keyword">long</span> term)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.committedIndex = Math.min(</span><br><span class="line">            <span class="comment">// committed index is likely less than the lastLogIndex</span></span><br><span class="line">            request.getCommittedIndex(),</span><br><span class="line">            <span class="comment">// The logs after the appended entries can not be trust, so we can't commit them even if their indexes are less than request's committed index.</span></span><br><span class="line">            request.getPrevLogIndex() + request.getEntriesCount());</span><br><span class="line">    <span class="keyword">this</span>.responseBuilder = responseBuilder;</span><br><span class="line">    <span class="keyword">this</span>.node = node;</span><br><span class="line">    <span class="keyword">this</span>.done = done;</span><br><span class="line">    <span class="keyword">this</span>.term = term;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NodeImpl$FollowerStableClosure#run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.done.run(status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.node.readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 接收日志时的任期和当前的任期不一致，说明持久化过程中任期发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.term != <span class="keyword">this</span>.node.currTerm) &#123;</span><br><span class="line">            <span class="comment">// 不能响应旧的Leader成功，因为不确定这些日志是否会被新Leader的日志覆盖</span></span><br><span class="line">            <span class="keyword">this</span>.responseBuilder.setSuccess(<span class="keyword">false</span>).setTerm(<span class="keyword">this</span>.node.currTerm);</span><br><span class="line">            <span class="keyword">this</span>.done.sendResponse(<span class="keyword">this</span>.responseBuilder.build());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.node.readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.responseBuilder.setSuccess(<span class="keyword">true</span>).setTerm(<span class="keyword">this</span>.term);</span><br><span class="line">    <span class="comment">// 更新日志提交位置</span></span><br><span class="line">    <span class="keyword">this</span>.node.ballotBox.setLastCommittedIndex(<span class="keyword">this</span>.committedIndex);</span><br><span class="line">    <span class="keyword">this</span>.done.sendResponse(<span class="keyword">this</span>.responseBuilder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>Leader收到响应，两种情况</p>
<p>处理心跳响应</p>
<p>Replicator#onHeartbeatReturned</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onHeartbeatReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Status status, <span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// replicator already was destroyed.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 心跳发送不成功</span></span><br><span class="line">        <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            r.state = State.Probe;</span><br><span class="line">            <span class="comment">// 回调通知</span></span><br><span class="line">            notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 下一次心跳超时</span></span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 心跳发送成功</span></span><br><span class="line">        r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果对方的任期比当前Leader，即比自己的任期还大，说明可能发生了网络分区</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            <span class="comment">// 通知回调，Follower已追上</span></span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 销毁当前Replicator</span></span><br><span class="line">            r.destroy();</span><br><span class="line">            <span class="comment">// Leader退位为Follower，并更新任期，重新启动选举计时</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE, <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对端响应异常 &amp;&amp; 对端返回的响应包含LastLogIndex</span></span><br><span class="line">        <span class="keyword">if</span> (!response.getSuccess() &amp;&amp; response.hasLastLogIndex()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            doUnlock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 再次发送一次Probe请求，探查对端Log的位置</span></span><br><span class="line">            r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 下一次心跳超时</span></span><br><span class="line">            r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 一切正常</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            <span class="comment">// 更新通讯时间戳</span></span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一次心跳超时</span></span><br><span class="line">        r.startHeartbeatTimer(startTimeMs);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理Probe和追加日志请求的响应</p>
<p>Replicator#onRpcReturned</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onRpcReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> RequestType reqType, <span class="keyword">final</span> Status status, <span class="keyword">final</span> Message request, <span class="keyword">final</span> Message response, <span class="keyword">final</span> <span class="keyword">int</span> seq, <span class="keyword">final</span> <span class="keyword">int</span> stateVersion, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs = Utils.nowMs();</span><br><span class="line">    Replicator r;</span><br><span class="line">    <span class="keyword">if</span> ((r = (Replicator) id.lock()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stateVersion != r.version) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AppendEntries响应的优先队列，根据发送时的序号排列</span></span><br><span class="line">    <span class="keyword">final</span> PriorityQueue&lt;RpcResponse&gt; holdingQueue = r.pendingResponses;</span><br><span class="line">    <span class="comment">// 先将响应结果添加到优先队列</span></span><br><span class="line">    holdingQueue.add(<span class="keyword">new</span> RpcResponse(reqType, seq, status, request, response, rpcSendTime));</span><br><span class="line">    <span class="comment">// 响应队列堆积超过256</span></span><br><span class="line">    <span class="keyword">if</span> (holdingQueue.size() &gt; r.raftOptions.getMaxReplicatorInflightMsgs()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 重置旧的响应数据</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// 重新发送Probe请求</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理队列中堆积的响应结果</span></span><br><span class="line">        <span class="keyword">while</span> (!holdingQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取队列头的响应结果，这里是从小到大排列，对应最早的请求的响应</span></span><br><span class="line">            <span class="keyword">final</span> RpcResponse queuedPipelinedResponse = holdingQueue.peek();</span><br><span class="line">            <span class="comment">// 初始都为0，相等</span></span><br><span class="line">            <span class="keyword">if</span> (queuedPipelinedResponse.seq != r.requiredNextSeq) &#123;</span><br><span class="line">                <span class="comment">// 处理中出现了异常，跳过后面的</span></span><br><span class="line">                <span class="keyword">if</span> (processed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还没有处理的话，不再处理</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                    id.unlock();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 先移除响应结果</span></span><br><span class="line">            holdingQueue.remove();</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">// 发送请求后会添加一个Inflight入队列尾，处理时从队列头取出，FIFO</span></span><br><span class="line">            <span class="keyword">final</span> Inflight inflight = r.pollInflight();</span><br><span class="line">            <span class="keyword">if</span> (inflight == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 请求的序列号和取出的响应的序列号不一致</span></span><br><span class="line">            <span class="keyword">if</span> (inflight.seq != queuedPipelinedResponse.seq) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 重置请求的Inflight队列和请求的响应队列</span></span><br><span class="line">                r.resetInflights();</span><br><span class="line">                r.state = State.Probe;</span><br><span class="line">                continueSendEntries = <span class="keyword">false</span>;</span><br><span class="line">                r.block(Utils.nowMs(), RaftError.EREQUEST.getNumber());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (queuedPipelinedResponse.requestType) &#123;</span><br><span class="line">                    <span class="keyword">case</span> AppendEntries:</span><br><span class="line">                        <span class="comment">// 处理响应</span></span><br><span class="line">                        continueSendEntries = onAppendEntriesReturned(id, inflight, queuedPipelinedResponse.status, (AppendEntriesRequest) queuedPipelinedResponse.request, (AppendEntriesResponse) queuedPipelinedResponse.response, rpcSendTime, startTimeMs, r);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Snapshot:</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">                    <span class="comment">// 成功，增加requiredNextSeq</span></span><br><span class="line">                    r.getAndIncrementRequiredNextSeq();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 响应队列处理结束</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 继续发送日志</span></span><br><span class="line">        <span class="keyword">if</span> (continueSendEntries) &#123;</span><br><span class="line">            r.sendEntries();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leader处理响应</p>
<p>Replicator#onAppendEntriesReturned</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onAppendEntriesReturned</span><span class="params">(<span class="keyword">final</span> ThreadId id, <span class="keyword">final</span> Inflight inflight, <span class="keyword">final</span> Status status, <span class="keyword">final</span> AppendEntriesRequest request, <span class="keyword">final</span> AppendEntriesResponse response, <span class="keyword">final</span> <span class="keyword">long</span> rpcSendTime, <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs, <span class="keyword">final</span> Replicator r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一般不会发生</span></span><br><span class="line">    <span class="keyword">if</span> (inflight.startIndex != request.getPrevLogIndex() + <span class="number">1</span>) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock id in sendEmptyEntries</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些统计</span></span><br><span class="line">    <span class="keyword">if</span> (request.getEntriesCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Follower宕机，RPC失败的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!status.isOk()) &#123;</span><br><span class="line">        notifyReplicatorStatusListener(r, ReplicatorEvent.ERROR, status);</span><br><span class="line">        <span class="comment">//重置请求的Inflight队列和请求的响应队列</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        <span class="comment">// unlock in in block</span></span><br><span class="line">        r.block(startTimeMs, status.getCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.consecutiveErrorTimes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Follower拒绝的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!response.getSuccess()) &#123;</span><br><span class="line">        <span class="comment">// 如果Follower的任期大于Leader自己的任期</span></span><br><span class="line">        <span class="keyword">if</span> (response.getTerm() &gt; r.options.getTerm()) &#123;</span><br><span class="line">            <span class="keyword">final</span> NodeImpl node = r.options.getNode();</span><br><span class="line">            <span class="comment">// 通知回调，Follower已追上</span></span><br><span class="line">            r.notifyOnCaughtUp(RaftError.EPERM.getNumber(), <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 销毁该Replicator</span></span><br><span class="line">            r.destroy();</span><br><span class="line">            <span class="comment">// Leader退位为Follower，并更新任期，重新启动选举计时</span></span><br><span class="line">            node.increaseTermTo(response.getTerm(), <span class="keyword">new</span> Status(RaftError.EHIGHERTERMRESPONSE, <span class="string">"Leader receives higher term heartbeat_response from peer:%s"</span>, r.options.getPeerId()));</span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Follower的任期没有大于Leader自己的任期，更新通讯时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">            r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置请求的Inflight队列和请求的响应队列</span></span><br><span class="line">        r.resetInflights();</span><br><span class="line">        <span class="comment">// 理想情况下，对端Follower最后的日志Index加一应该就是下一个要发送的日志的Index，如果小了，说明Follower日志进度落后</span></span><br><span class="line">        <span class="keyword">if</span> (response.getLastLogIndex() + <span class="number">1</span> &lt; r.nextIndex) &#123;</span><br><span class="line">            <span class="comment">// 更新下次发送Log的位置</span></span><br><span class="line">            r.nextIndex = response.getLastLogIndex() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Follower日志位置比Leader下个发送的日志位置大或一样，说明可能需要Follower删除日志</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.nextIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 位置减减，Follower收到后检查一致性，一直向前</span></span><br><span class="line">                r.nextIndex--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续发送Probe请求</span></span><br><span class="line">        r.sendEmptyEntries(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log同步成功，Follower在同步前会同步Leader的任期，如果不一致，说明Leader的任期在发出请求后上升了，不再处理</span></span><br><span class="line">    <span class="keyword">if</span> (response.getTerm() != r.options.getTerm()) &#123;</span><br><span class="line">        r.resetInflights();</span><br><span class="line">        r.state = State.Probe;</span><br><span class="line">        id.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常情况，更新通讯时间戳</span></span><br><span class="line">    <span class="keyword">if</span> (rpcSendTime &gt; r.lastRpcSendTimestamp) &#123;</span><br><span class="line">        r.lastRpcSendTimestamp = rpcSendTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> entriesSize = request.getEntriesCount();</span><br><span class="line">    <span class="comment">// 是个复制日志请求</span></span><br><span class="line">    <span class="keyword">if</span> (entriesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 大多数Follower响应同步成功后Leader才能提交日志</span></span><br><span class="line">        r.options.getBallotBox().commitAt(r.nextIndex, r.nextIndex + entriesSize - <span class="number">1</span>, r.options.getPeerId());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是个Probe请求</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Probe完后切换到复制状态</span></span><br><span class="line">        r.state = State.Replicate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下次Log复制的索引</span></span><br><span class="line">    r.nextIndex += entriesSize;</span><br><span class="line">    r.hasSucceeded = <span class="keyword">true</span>;</span><br><span class="line">    r.notifyOnCaughtUp(RaftError.SUCCESS.getNumber(), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// dummy_id is unlock in _send_entries</span></span><br><span class="line">    <span class="keyword">if</span> (r.timeoutNowIndex &gt; <span class="number">0</span> &amp;&amp; r.timeoutNowIndex &lt; r.nextIndex) &#123;</span><br><span class="line">        r.sendTimeoutNow(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leader发送日志</p>
<p>Replicator#sendEntries</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> doUnlock = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> prevSendIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 尽可能多地发送Log</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex = getNextSendIndex();</span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &gt; prevSendIndex) &#123;</span><br><span class="line">                <span class="comment">// 发送</span></span><br><span class="line">                <span class="keyword">if</span> (sendEntries(nextSendingIndex)) &#123;</span><br><span class="line">                    prevSendIndex = nextSendingIndex;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    doUnlock = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doUnlock) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Replicator#getNextSendIndex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getNextSendIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送一个AppendEntriesRequest添加一个Inflight，代表Pipeline发送，处理响应后移除</span></span><br><span class="line">    <span class="comment">// 说明没有堆积，nextIndex在收到响应时才会更新</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inflights.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.nextIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 堆积太多，不再发送</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.inflights.size() &gt; <span class="keyword">this</span>.raftOptions.getMaxReplicatorInflightMsgs()) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pipeline情况下，发送下一个请求时不一定已经收到上一个请求的响应</span></span><br><span class="line">    <span class="comment">// 如果上一个发送的是添加日志请求，不是Probe请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rpcInFly != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.rpcInFly.isSendingLogEntries()) &#123;</span><br><span class="line">        <span class="comment">// 接着发送</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rpcInFly.startIndex + <span class="keyword">this</span>.rpcInFly.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Replicator#sendEntries</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sendEntries</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> nextSendingIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest.Builder rb = AppendEntriesRequest.newBuilder();</span><br><span class="line">    <span class="comment">// 先尝试填充常用的字段：Term，GroupId，ServerId，PeerId，PrevLogIndex，PrevLogTerm，CommittedIndex</span></span><br><span class="line">    <span class="comment">// NextSendingIndex是本次Log复制的起始Index，PrevLogIndex就是上次复制的Index</span></span><br><span class="line">    <span class="keyword">if</span> (!fillCommonFields(rb, nextSendingIndex - <span class="number">1</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ByteBufferCollector dataBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Log条目数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxEntriesSize = <span class="keyword">this</span>.raftOptions.getMaxEntriesSize();</span><br><span class="line">    <span class="keyword">final</span> RecyclableByteBufferList byteBufList = RecyclableByteBufferList.newInstance();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取日志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxEntriesSize; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> RaftOutter.EntryMeta.Builder emb = RaftOutter.EntryMeta.newBuilder();</span><br><span class="line">            <span class="comment">// 准备该条Log</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareEntry(nextSendingIndex, i, emb, byteBufList)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加</span></span><br><span class="line">            rb.addEntries(emb.build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 暂时没获取到新的Log</span></span><br><span class="line">        <span class="keyword">if</span> (rb.getEntriesCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextSendingIndex &lt; <span class="keyword">this</span>.options.getLogManager().getFirstLogIndex()) &#123;</span><br><span class="line">                installSnapshot();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加下次期待的日志位置到缓存，Leader添加新日志后回调</span></span><br><span class="line">            waitMoreEntries(nextSendingIndex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (byteBufList.getCapacity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dataBuf = ByteBufferCollector.allocateByRecyclers(byteBufList.getCapacity());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ByteBuffer b : byteBufList) &#123;</span><br><span class="line">                dataBuf.put(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer buf = dataBuf.getBuffer();</span><br><span class="line">            buf.flip();</span><br><span class="line">            <span class="comment">// 添加日志的缓冲数据</span></span><br><span class="line">            rb.setData(ZeroByteStringHelper.wrap(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RecycleUtil.recycle(byteBufList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建请求</span></span><br><span class="line">    <span class="keyword">final</span> AppendEntriesRequest request = rb.build();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.statInfo.runningState = RunningState.APPENDING_ENTRIES;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.firstLogIndex = rb.getPrevLogIndex() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.statInfo.lastLogIndex = rb.getPrevLogIndex() + rb.getEntriesCount();</span><br><span class="line">    <span class="keyword">final</span> Recyclable recyclable = dataBuf;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="keyword">this</span>.version;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> monotonicSendTimeMs = Utils.monotonicMs();</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> seq = getAndIncrementReqSeq();</span><br><span class="line">    <span class="comment">// RPC发送</span></span><br><span class="line">    <span class="keyword">final</span> Future&lt;Message&gt; rpcFuture = <span class="keyword">this</span>.rpcService.appendEntries(<span class="keyword">this</span>.options.getPeerId().getEndpoint(), request, -<span class="number">1</span>, <span class="keyword">new</span> RpcResponseClosureAdapter&lt;AppendEntriesResponse&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Status status)</span> </span>&#123;</span><br><span class="line">            RecycleUtil.recycle(recyclable);</span><br><span class="line">            <span class="comment">// 响应回调</span></span><br><span class="line">            onRpcReturned(Replicator.<span class="keyword">this</span>.id, RequestType.AppendEntries, status, request, getResponse(), seq, v, monotonicSendTimeMs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    addInflight(RequestType.AppendEntries, nextSendingIndex, request.getEntriesCount(), request.getData().size(), seq, rpcFuture);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>附带Counter的读例子</p>
<p>GetValueRequestProcessor#handleRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> BizContext bizCtx, <span class="keyword">final</span> GetValueRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前Server不是Leader</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.counterServer.getFsm().isLeader()) &#123;</span><br><span class="line">        <span class="comment">// 重定向到Leader，包含了Leader的PeerId</span></span><br><span class="line">        <span class="comment">// 其实Follower也能处理读请求，一致性读的情况下不会发生脏读</span></span><br><span class="line">        <span class="comment">// 但是节点间的复制是异步的，在日志落后太多的情况下，响应时间会比较长，所以都交给Leader</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.counterServer.redirect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前Server是Leader，处理读请求</span></span><br><span class="line">    <span class="keyword">final</span> ValueResponse response = <span class="keyword">new</span> ValueResponse();</span><br><span class="line">    response.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Leader直接从状态机获取值，这里应该没有一致性读的处理？</span></span><br><span class="line">    response.setValue(<span class="keyword">this</span>.counterServer.getFsm().getValue());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
