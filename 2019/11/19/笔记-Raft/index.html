<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-Raft | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Raft">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Raft</h2>
				
				<div>
					<div class="post-time">2019-11-19</div>
				</div>
				
				<div class="article-content">
				<p>这段时间各种事情和折腾，就是不想学习，而且最近干啥都没动力，游戏玩到一半就不想玩了，折腾几个月搞了台ITX，结果装完机后索然无味。</p>
<p>现在感觉越来越难投入了，只想做条咸鱼，果然咸鱼本咸么。</p>
<p>接下来是调整一下状态，也安排一下学习计划，因为之前看的很多东西都忘了，面试问起来感觉会非常尴尬😬，所以基本都是面试向的东西，其它暂时放一放，其实我对腾讯开源的TubeMQ和Disruptor都挺感兴趣的，不过还是暂时放一下吧。</p>
<p>明年呢，主要是换工作，个人的学习安排则是补一下基础，C/C++，操作系统，编译原理这些，虽然我野鸡，但也不随便哈，另外Nginx的源码我也挺感兴趣的。</p>
<p>大概就是这样。</p>
<hr>
<p>哦，对了，今天是我25岁生日，感觉自己是真的老了（镜子：欧吉桑你谁啊），心也老了，看到零零后，感觉自己就像个大叔，九零后的时代已经过去了吗？小时候是期待快点长大，现在则是害怕老去，大概这就是所谓的不服老吧。</p>
<p>发个牢骚，不要在意。</p>
<hr>
<p>一些有价值的参考：</p>
<ul>
<li><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft动画演示，简单的英文</a></p>
</li>
<li><p><a href="https://raft.github.io/" target="_blank" rel="noopener">Raft的一些语言实现列表</a></p>
</li>
<li><p><a href="https://www.jdon.com/artichect/paxos.html" target="_blank" rel="noopener">Paxos动画演示，可以看看</a></p>
</li>
<li><p><a href="https://www.jdon.com/artichect/raft.html/" target="_blank" rel="noopener">Raft图解</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">浅显易懂地解释了Raft协议，推荐</a></p>
</li>
<li><p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="noopener">Raft论文翻译，推荐</a></p>
</li>
<li><p><a href="https://www.sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/" target="_blank" rel="noopener">SOFA-JRaft文档</a></p>
</li>
<li><p><a href="https://www.sofastack.tech/tags/sofajraft/" target="_blank" rel="noopener">SOFAStack发布的一些文章</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/hzmark/p/raft_3.html" target="_blank" rel="noopener">Raft的安全性</a></p>
</li>
</ul>
<hr>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>一个分布式系统不可能同时满足一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance），最多只能同时满足其中的两个。</p>
<ul>
<li><p>一致性：数据在多个副本之间能保持一致，读操作总是能读取到之前完成的写操作结果。</p>
</li>
<li><p>可用性：系统提供的服务一直处于可用的状态。</p>
</li>
<li><p>分区容错性：遇到网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p>
</li>
</ul>
<p>分区：在分布式系统中，不同的节点分布在不同的子网络中，子节点之间可能网络不通，但内部子网络是正常的，导致了系统被切分成若干个孤立的区域。</p>
<p>如果不出现分区，那么就能够同时满足CAP。</p>
<p>如果出现了分区，可以不必使用强一致性，先将数据暂存，稍后再更新，实现最终一致性。</p>
<h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>Basically Available（基本可用），Soft State（软状态），Eventually Consistent（最终一致性）。</p>
<p>核心：无法做到强一致性（Strong Consistency），但可以达到最终一致性（Eventual Consistency）。</p>
<ul>
<li><p>基本可用：系统出现了故障，但还是能用，可能是响应时间变长，或者服务降级。</p>
</li>
<li><p>软状态：允许系统中的数据存在中间状态（不一致），允许不同节点的数据副本存在数据延时。</p>
</li>
<li><p>最终一致性：软状态有个期限，期限过后，所有副本保持数据一致性。</p>
</li>
</ul>
<hr>
<p>参考这篇文章：<a href="http://dockone.io/article/78" target="_blank" rel="noopener">为什么不应该使用ZooKeeper做服务发现</a>。</p>
<p>ZooKeeper用于解决大规模分布式应用场景下，服务协调同步（Coordinate Service）的问题，可以提供：统一命名服务、配置管理、分布式锁服务、集群管理等功能，但不是一个良好的服务发现解决方案。</p>
<p>ZooKeeper是CP的，请求能得到一致的结果，同时系统对网络分割具备容错性，但不保证请求的可用性。</p>
<p>如果一个网络分区的节点数达不到选取Leader的法定人数时（小的网络分区），就会被移除，即便节点本身正常。</p>
<p>对服务发现来说，宁可返回之前的可用信息，也不能因为网络故障找不到可用的服务器，而不返回任何结果。</p>
<p>Eureka由两个组件组成：Eureka服务器和Eureka客户端。</p>
<p>Eureka服务器用作服务注册服务器，Eureka客户端与服务器交互、作为轮询负载均衡器，并支持服务的故障切换。</p>
<p>如果某台服务器宕机，不会有类似ZooKeeper的Leader选举，客户端请求会自动切换到新的Eureka节点。</p>
<p>当网络分区时，每个Eureka节点继续对外提供服务，接收新的服务注册同时将它们提供给下游的服务发现请求。</p>
<p>正常配置下，Eureka内置了心跳服务，如果在Eureka中注册的服务的心跳出现异常，Eureka会将其剔除。</p>
<p>也可以配置，因为网络问题而被剔除出去的服务器本身可能是健康的，只是因为网络分割故障把Eureka集群分割成了独立的子网而不能互访而已。</p>
<p>Eureka客户端还有缓存功能，即便Eureka集群中所有节点都失效，或者发生网络分区导致客户端不能访问任何一台Eureka服务器，仍然可以通过Eureka客户端缓存获取服务注册信息。</p>
<hr>
<h4 id="Raft节点的三个状态"><a href="#Raft节点的三个状态" class="headerlink" title="Raft节点的三个状态"></a>Raft节点的三个状态</h4><ul>
<li><p>Follower</p>
<ul>
<li><p>每个节点启动后的初始状态，被动，只响应而不发送请求；</p>
</li>
<li><p>Follower超时未收到Leader心跳，触发转为Candidate；</p>
</li>
</ul>
</li>
<li><p>Candidate</p>
<ul>
<li>发起投票，如果获得了大多数节点的允许，变成Leader，否则如果收到了Leader的消息，则变回Follower；</li>
</ul>
</li>
<li><p>Leader</p>
<ul>
<li><p>Leader只能有一个，处理来自Client的请求，复制Log到所有Follower；</p>
</li>
<li><p>如果Client与Follower直接通信，Follower会把Client重定向到Leader；</p>
</li>
</ul>
</li>
</ul>
<h4 id="选举的简单流程"><a href="#选举的简单流程" class="headerlink" title="选举的简单流程"></a>选举的简单流程</h4><ul>
<li><p>所有Server节点启动时，都是Follower；</p>
</li>
<li><p>集群没有Leader，Follower节点超时（ET）未收到Leader的心跳（认为没有Leader），向其他节点发起预投票（PreVote）请求，要求投给自己一票，收到的节点根据任期等决定是否同意该预投票；</p>
</li>
<li><p>获得绝大部分节点同意的Follower才能成为Candidate，发起正式投票，同理，获得大部分节点同意的Candidate才能成为Leader；</p>
</li>
<li><p>成为Leader的节点，定时向其他Follower节点发送心跳（维护Leadership），包含了Log，收到Leader心跳的Candidate，自动转回为Follower；</p>
</li>
<li><p>如果一轮投票后还是没有选举出Leader，则继续进行下一期的选举，重复这个过程；</p>
</li>
</ul>
<h4 id="关于任期"><a href="#关于任期" class="headerlink" title="关于任期"></a>关于任期</h4><p>机器的物理时间是不可靠的，需要一个逻辑时间，称为任期（Term）。</p>
<p>任期单调递增，每个任期的开始都是Leader选举，选举成功之后，Leader在任期内管理整个集群。</p>
<p>一个任期内，最多只能有一个Leader，也可能没有Leader（Spilt Vote）。</p>
<p>节点每次通信，都会交换当前任期号，节点可以通过任期判断过期的Leader或Log：</p>
<ul>
<li><p>如果一个节点的当前任期号比其他的小，则更新自己的任期；</p>
</li>
<li><p>如果一个Candidate或Leader发现自己的任期号过期了，立刻将自己变回Follower；</p>
</li>
<li><p>如果一个节点收到一个过期的任期号的请求，直接拒绝；</p>
</li>
</ul>
<p>每个节点保存当前任期，正常情况下，系统中所有的节点的任期是一致的。</p>
<ul>
<li><p>正式发起选举时，Follower节点先增加自己的任期并转为Candidate，然后要求其他节点给自己投票。</p>
</li>
<li><p>节点收到请求后，会拒绝任期比自己小的Candidate，认为它的日志不完整，不能成为Leader。</p>
</li>
<li><p>节点同意该任期的投票请求后不会再同意同任期下其它节点的请求，同时更新自己的任期。</p>
</li>
<li><p>所以每个节点在一个任期下只会投一张票（FCFS）。</p>
</li>
<li><p>当某个Candidate获得了同一个任期下的大多数选票，就自动成为Leader。</p>
</li>
<li><p>如果该Candidate当选了Leader，会广播心跳，同步全局任期，并将别的Candidate转化为Follower。</p>
</li>
<li><p>如果没有节点当选Leader（超时），Candidate节点则自增自己的任期（保证系统一致），继续发起下一轮投票（该任期没有Leader）。</p>
</li>
</ul>
<p>为了避免所有Candidate节点同时发起投票请求，然后瓜分选票，导致僵持，增加了一个随机超时，错开请求时间。</p>
<h4 id="选举的时间要求"><a href="#选举的时间要求" class="headerlink" title="选举的时间要求"></a>选举的时间要求</h4><p>BroadcastTime &lt;&lt; ElectionTimeout &lt;&lt; MTBF</p>
<ul>
<li><p>广播时间（BroadcastTime）：节点并行的发送RPC给其他节点并收到响应的平均时间。</p>
</li>
<li><p>选举超时（ElectionTimeout，ET）：Follower节点未收到Leader消息和上次收到Leader消息的间隔时间。</p>
</li>
<li><p>平均故障间隔时间（MeanTimeBetweenFailure，MTBF）：单个服务器发生故障的平均时间间隔。</p>
</li>
</ul>
<p>BroadcastTime要比ElectionTimeout小一个数量级，这样Leader才能发送稳定的心跳来阻止Follower转为Candidate。</p>
<p>ElectionTimeout要比MTBF小几个数量级，这样系统才能正常运行。</p>
<p>Leader崩溃后，系统的不可用时间，大约相当于ElectionTimeout。</p>
<ul>
<li><p>网络延时（RoundTripTime，RTT）。</p>
</li>
<li><p>心跳间隔（HeartbeatTimeout）：Leader需要持续发送心跳来阻止Follower触发选举，所以应该要比ElectionTimeout小一个数量级。</p>
</li>
</ul>
<p>RTT &lt; BroadcastTime &lt;&lt; HeartbeatTimeout &lt; ElectionTimeout &lt;&lt; MTBF</p>
<p>随机选主触发时间：Random(ET, 2ET)。</p>
<h4 id="关于日志"><a href="#关于日志" class="headerlink" title="关于日志"></a>关于日志</h4><p>日志只从Leader发送到其他节点。</p>
<p>日志复制有连续性，不允许出现空洞。</p>
<p>只要将写操作转化为WriteAheadLog（WAL），所有副本对WAL一致，对于每个状态机，只要按顺序执行WAL，就能保证最终状态是一致的。</p>
<ul>
<li><p>Client向Leader发送请求（如果发送给了Follower，则会被重定向到Leader）；</p>
</li>
<li><p>Leader将请求转为Log并持久化；</p>
</li>
<li><p>Leader通过多个Replicator，并发地将Log通过RPC发送给Follower节点，当收到大多数节点的成功响应时，说明Log成功复制；</p>
</li>
<li><p>Leader提交Log的CommitIndex，再由状态机执行，再响应Client的请求；</p>
</li>
<li><p>在下一个心跳中，Follower根据Leader发来的当前CommitIndex，提交自己的日志索引。</p>
</li>
</ul>
<p>￼CommitIndex就是已达成多数，可以应用到状态机的最新的日志位置。</p>
<p>AppendEntriesRPC的参数：</p>
<ul>
<li><p>CurrentTerm；</p>
</li>
<li><p>LogEntries[]：日志信息，通常为多条；</p>
</li>
<li><p>PrevTerm：前一条日志的任期，检查日志有效性；</p>
</li>
<li><p>PrevLogIndex：前一条日志的索引，检查日志有效性；</p>
</li>
<li><p>CommitTerm；</p>
</li>
<li><p>CommitLogIndex：Leader最新的提交日志位点；</p>
</li>
</ul>
<p>日志结构：</p>
<ul>
<li><p>索引（LogIndex），日志条目在日志中位置；</p>
</li>
<li><p>创建日志时的任期号（TermId），用来检查日志是否一致；</p>
</li>
<li><p>状态机需要执行的指令（LogValue）；</p>
</li>
</ul>
<p>TermId和LogIndex确定唯一一条日志。</p>
<hr>
<p>Raft是共识算法，让多个参与者针对某一件事达成完全一致，对已达成一致的结论，不可推翻。</p>
<ul>
<li><p>Strong Leader：集群中最多只能有一个Leader，日志只能从Leader复制到Follower上；</p>
</li>
<li><p>Leader Election：采用随机选举超时触发选举来避免选票被瓜分；</p>
</li>
<li><p>Membership Changes：通过两阶段的方式应对集群内成员的加入或者退出情况，在此期间并不影响集群对外的服务；</p>
</li>
</ul>
<h4 id="几个原则"><a href="#几个原则" class="headerlink" title="几个原则"></a>几个原则</h4><ul>
<li><p>选举安全原则（Election Safety）：一个任期内最多允许有一个Leader。</p>
</li>
<li><p>只增加日志原则（Leader Append Only）：Leader只会增加日志条目，永远不会覆盖或删除自己的日志。</p>
</li>
<li><p>日志匹配原则（Log Matching）：如果两个日志条目在相同的的索引位置上并且任期号相同，那么可以认为这个日志从头到这个索引位置之间的条目完全相同。</p>
</li>
<li><p>领导人完整性原则（Leader Completeness）：如果一个日志条目在一个指定任期内被提交，那么这个条目一定会出现所有任期号更大的Leader中。</p>
</li>
<li><p>状态机安全原则（State Machine Safety）：如果一个服务器已经将指定索引位置上的日志条目应用到状态机，那么所有其他服务器不可能在该索引位置应用不同的日志条目（由领导人完整性可得）。</p>
</li>
</ul>
<h5 id="日志匹配原则的证明"><a href="#日志匹配原则的证明" class="headerlink" title="日志匹配原则的证明"></a>日志匹配原则的证明</h5><p>不同Node的Log副本，如果两个Log条目的Index和Term都一致，那么这两个Log条目是相同的，并且它们之前的所有Log条目都是相同的。</p>
<p>证明：</p>
<p>Leader在一个任期内创建的日志索引是单调递增的，并且一个任期只有一个Leader（一般情况下）。</p>
<p>Leader为每个Follower维护一个NextIndex，表示下一个需要发送给该Follower的日志条目的索引。</p>
<p>Leader刚上台时，将自己的NextIndex设为最后一条日志的索引的下一个位置，每次发送发给Follower时，包含PrevTerm和PrevIndex，PrevIndex=NextIndex-1，代表上一条日志。</p>
<p>如果Follower检查不匹配，则拒绝接收，称为一致性检查。</p>
<p>Leader收到拒绝的响应后就把NextIndex递减进行重试，直到匹配到一致的日志。</p>
<p>匹配成功之后，Follower把后面冲突的日志全部删除，Follower和Leader的日志就达成一致（以Leader日志为准）。</p>
<p>由高中的数学归纳法可知日志匹配原则成立。</p>
<h5 id="领导人完整性原则的证明"><a href="#领导人完整性原则的证明" class="headerlink" title="领导人完整性原则的证明"></a>领导人完整性原则的证明</h5><p>当选Leader获取过半节点的选票：先比较Term，再比较Log。</p>
<p>Leader只能在自己当前任期的Log被过半节点持久化时，才能提交。</p>
<p>当上一位Leader成功提交最后一条Log，后面的Candidate必须获取过半节点的选票，才能成为新Leader。</p>
<hr>
<p>新上任的Leader不能直接提交上一个任期的日志，只能以提交自己任期的日志的方式间接提交：</p>
<ul>
<li><p>假设集群有5个节点，节点1是Leader，将LogIndex=2，LogTerm=2的日志复制到节点2后宕机了，然后进行了选举；</p>
</li>
<li><p>假设节点5成为了Leader（获得了节点3，4，5的同意），然后节点5接受了Client的一条消息，LogIndex=2，LogTerm=3，日志本地持久化成功，但是在向Follower同步前宕机，然后进行了选举；</p>
</li>
<li><p>假设节点1成为了Leader（获得了节点1，2，3，4的同意），然后将原本LogIndex=2，LogTerm=2的日志复制到节点3（这时已经复制到节点1，2，3），但是在提交前宕机了，然后进行了选举；</p>
</li>
<li><p>假设节点5成为了Leader（获得了节点2，3，4，5的同意），然后用LogIndex=2，LogTerm=3这条日志将其它节点的LogIndex=2，LogTerm=2的日志覆盖了</p>
</li>
</ul>
<p>所以这里是将大多数节点的日志覆盖了，虽然没有提交，状态机和日志也没有不一致，但是这是不对的（我猜应该是？）。</p>
<p>但是假如在上面的第三步时，节点1成为了Leader后提交了一条自己任期的日志，这样节点5就不能成为Leader（大多数节点的日志都比它大），日志也不会被覆盖。</p>
<hr>
<p>配置变更，即集群成员变更，动态增减服务器。</p>
<p>假设原本有三台服务器，现在要在不停机的条件下，增加两台，并应用新的配置到旧的三台服务器上。</p>
<p>因为新的配置不可能同时生效，所以在集群中，有一个时刻会同时存在新旧两种配置，假设此时发生选举，系统就可能会出现两个Leader。</p>
<p>Raft使用两阶段提交的方案。</p>
<p>第一阶段：</p>
<p>发送新配置到旧集群的Leader，Leader不直接存储新配置，而存储共同配置（旧配置和新配置），并将共同配置通过日志复制到其它Follower节点。</p>
<p>新旧配置的节点都可以成为Leader，并且达成一致需要在两个配置上获得半数以上支持。</p>
<p>第二阶段：</p>
<p>当共同配置被成功提交（成功同步到新旧集群的大部分Follower），Leader会同步新配置到Follower，完成配置变更，之后就根据新配置做决定。</p>
<p>假如在新配置已复制到过半节点时，Leader宕机：</p>
<p>集群重新开始选举，此时未同步新配置的节点不会赢得选举，因为要根据共同配置做决定，但是无法获得同步了新配置的节点的选票（根据LogIndex），只有复制了新配置的节点才能成为Leader，之后继续复制新配置日志，流程恢复。</p>
<p>假如在新配置没复制到过半节点时，Leader宕机：</p>
<p>所有节点都可以成为Leader，无论谁成为Leader，流程继续。</p>
<p>新节点没有日志数据，日志是不能有空洞的，也就是必须等待复制完成，这段时间内新的日志无法追加，也就不能响应Leader，假如新节点数量过半，那Leader就无法Commit，也不能响应Client。</p>
<p>这段时间的可用性保证：貌似没看到JRaft的相关处理，也可能是我看漏了，或许是Snapshot的方式？</p>
<hr>
<p>JRaft整个链路几乎都是Batch的，依靠Disruptor的MPSC模型批量消费：</p>
<ul>
<li><p>批量提交Task；</p>
</li>
<li><p>批量网络发送，Pipeline复制Log；</p>
</li>
<li><p>本地IO批量写入；</p>
</li>
<li><p>批量应用到状态机；</p>
</li>
<li><p>Leader持久化Log和向Follower发送Log是并行的，向所有Follower发送Log也是并行的；</p>
</li>
<li><p>整个链路基于回调，完全不阻塞；</p>
</li>
</ul>
<p>官方文档说，JRaft虽然是Batch，但不会累积请求，我看代码，猜测应该是Disruptor的处理？不然那就是累积了。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
