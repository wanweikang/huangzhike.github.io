<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-RocketMQ-Consumer-PullMessage | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-RocketMQ-Consumer-PullMessage">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-RocketMQ-Consumer-PullMessage</h2>
				
				<div>
					<div class="post-time">2019-10-21</div>
				</div>
				
				<div class="article-content">
				<p>PullMessageService#run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从阻塞队列取出PullRequest对象，在RebalanceImpl中创建加入，没有就阻塞</span></span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">// 执行消息拉取</span></span><br><span class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PullMessageService#pullMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从MQClientInstance中根据ConsumerGroup获取一个Consumer</span></span><br><span class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">// 通过该Consumer执行消息拉取消费</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultMQPushConsumerImpl#pullMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取处理队列</span></span><br><span class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">    <span class="comment">// 如果ProcessQueue被标记为废弃</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 确保消费者处于运行状态</span></span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果消费者被暂停</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">    <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 如果Consumer本地堆积未处理的消息过多，超过消息拉取阈值，则需要执行流量控制</span></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Consumer本地堆积消息过大，超过消息拉取队列大小，则需要执行流量控制</span></span><br><span class="line">    <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要顺序消费消息</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123;</span><br><span class="line">        <span class="comment">// 消息偏移跨度过大，则需要执行流量控制</span></span><br><span class="line">        <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">            <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要顺序消费消息</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 已经向Broker获取了该MessageQueue的分布式锁</span></span><br><span class="line">        <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">            <span class="comment">// PullRequest对象是重复使用的，第一次拉取时没标记锁定</span></span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.isLockedFirst()) &#123;</span><br><span class="line">                <span class="comment">// 向Broker发送QUERY_CONSUMER_OFFSET请求，获取MessageQueue的消费进度</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</span><br><span class="line">                <span class="comment">// 标记锁定</span></span><br><span class="line">                pullRequest.setLockedFirst(<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// 设置拉取偏移</span></span><br><span class="line">                pullRequest.setNextOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有获取锁</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查订阅关系，可能延时后，Topic或Consumer的配置发生了变化</span></span><br><span class="line">    <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="comment">// 没找到该Topic的订阅数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 创建拉取回调</span></span><br><span class="line">    PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理拉取结果，客户端根据Tag的字符串再次过滤</span></span><br><span class="line">                <span class="comment">// 百度了一下，RocketMQ之所以设计为Broker根据哈希过滤而不是直接使用字符串，是因为ConsumeQueue为了性能设计为定长单元，显然不能使用字符串</span></span><br><span class="line">                pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData);</span><br><span class="line">                <span class="comment">// 拉取状态</span></span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="comment">// 找到了消息</span></span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                        <span class="comment">// 根据Broker返回的下次拉取的开始偏移更新PullRequest</span></span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="comment">// RoundTime</span></span><br><span class="line">                        <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                        <span class="comment">// 统计</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line">                        <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                        <span class="comment">// 如果没有消息，可能是在上面被Consumer过滤了Tag</span></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                            <span class="comment">// 直接提交PullRequest到队列，执行下一次拉取</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 有消息</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line">                            <span class="comment">// 统计</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">                            <span class="comment">// 把消息放入ProcessQueue，返回是否分发给消费者消费</span></span><br><span class="line">                            <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                            <span class="comment">// 创建ConsumeRequest对象，提交到线程池，调用MessageListener消费消息，处理完成会通知ProcessQueue</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 延迟间隔时间后再次提交PullRequest到队列</span></span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// PushConsumer</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 直接提交PullRequest到队列，执行下一次拉取</span></span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 没有找到新的消息</span></span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        <span class="comment">// 使用Broker校准的偏移</span></span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line">                        <span class="comment">// 直接提交PullRequest到队列，执行下一次拉取</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 偏移非法</span></span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                        <span class="comment">// 使用Broker校准的偏移</span></span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="comment">// 将该ProcessQueue标记为丢弃</span></span><br><span class="line">                        pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 更新Consumer本地该MessageQueue的消费进度缓存</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line">                                    <span class="comment">// 持久化当前消息队列的消费进度，集群模式下是向Broker发送UPDATE_CONSUMER_OFFSET的单向请求</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line">                                    <span class="comment">// 移除当前MessageQueue的ProcessQueue，等待下次执行负载均衡</span></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                    <span class="comment">// ...</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="number">10000</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;; <span class="comment">// 回调代码结束</span></span><br><span class="line">    <span class="comment">// 是否同步消费进度到Broker，除了定时任务向Broker同步消费进度，拉取消息时也可能会顺便同步</span></span><br><span class="line">    <span class="keyword">boolean</span> commitOffsetEnable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffsetValue = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 如果是集群消费模式</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="comment">// 从本地缓存获取该MessageQueue的消费进度</span></span><br><span class="line">        commitOffsetValue = <span class="keyword">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            commitOffsetEnable = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String subExpression = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> classFilter = <span class="keyword">false</span>;</span><br><span class="line">    SubscriptionData sd = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 系统标记</span></span><br><span class="line">    <span class="keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">            <span class="keyword">true</span>, <span class="comment">// suspend</span></span><br><span class="line">            subExpression != <span class="keyword">null</span>, <span class="comment">// subscription</span></span><br><span class="line">            classFilter <span class="comment">// class filter</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行拉取</span></span><br><span class="line">        <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(pullRequest.getMessageQueue(), <span class="comment">//</span></span><br><span class="line">                subExpression, <span class="comment">//</span></span><br><span class="line">                subscriptionData.getExpressionType(), <span class="comment">//</span></span><br><span class="line">                subscriptionData.getSubVersion(), <span class="comment">//</span></span><br><span class="line">                pullRequest.getNextOffset(), <span class="comment">//</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class="comment">// 批量拉取大小</span></span><br><span class="line">                sysFlag, <span class="comment">//</span></span><br><span class="line">                commitOffsetValue, <span class="comment">//</span></span><br><span class="line">                BROKER_SUSPEND_MAX_TIME_MILLIS, <span class="comment">//</span></span><br><span class="line">                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, <span class="comment">//</span></span><br><span class="line">                CommunicationMode.ASYNC, <span class="comment">// 异步</span></span><br><span class="line">                pullCallback);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 提交延时任务，将PullRequest放回队列，延时拉取</span></span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PullAPIWrapper#pullKernelImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PullResult <span class="title">pullKernelImpl</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> String subExpression, <span class="keyword">final</span> String expressionType, <span class="keyword">final</span> <span class="keyword">long</span> subVersion, <span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> maxNums, <span class="keyword">final</span> <span class="keyword">int</span> sysFlag, <span class="keyword">final</span> <span class="keyword">long</span> commitOffset, <span class="keyword">final</span> <span class="keyword">long</span> brokerSuspendMaxTimeMillis, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis, <span class="keyword">final</span> CommunicationMode communicationMode, <span class="keyword">final</span> PullCallback pullCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MessageQueue的BrokerName及上次从Broker拉取返回的建议BrokerId，决定Broker的地址</span></span><br><span class="line">    FindBrokerResult findBrokerResult = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), <span class="keyword">this</span>.recalculatePullFromWhichNode(mq), <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 没有就从NameServer更新后再获取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == findBrokerResult) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (findBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查版本...</span></span><br><span class="line">        <span class="keyword">int</span> sysFlagInner = sysFlag;</span><br><span class="line">        <span class="comment">// 如果是向Slave拉取消息</span></span><br><span class="line">        <span class="keyword">if</span> (findBrokerResult.isSlave()) &#123;</span><br><span class="line">            <span class="comment">// 清除同步消费偏移的标记</span></span><br><span class="line">            sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner);</span><br><span class="line">        &#125;</span><br><span class="line">        PullMessageRequestHeader requestHeader = <span class="keyword">new</span> PullMessageRequestHeader();</span><br><span class="line">        <span class="comment">// ConsumerGroup</span></span><br><span class="line">        requestHeader.setConsumerGroup(<span class="keyword">this</span>.consumerGroup);</span><br><span class="line">        <span class="comment">// 拉取的Topic</span></span><br><span class="line">        requestHeader.setTopic(mq.getTopic());</span><br><span class="line">        <span class="comment">// 拉取的MessageQueueId</span></span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">        <span class="comment">// 本次拉取的起始偏移</span></span><br><span class="line">        requestHeader.setQueueOffset(offset);</span><br><span class="line">        <span class="comment">// 一次拉取的最大消息数量</span></span><br><span class="line">        requestHeader.setMaxMsgNums(maxNums);</span><br><span class="line">        requestHeader.setSysFlag(sysFlagInner);</span><br><span class="line">        <span class="comment">// 向Broker同步Consumer对该MessageQueue的消费进度</span></span><br><span class="line">        requestHeader.setCommitOffset(commitOffset);</span><br><span class="line">        requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis);</span><br><span class="line">        requestHeader.setSubscription(subExpression);</span><br><span class="line">        requestHeader.setSubVersion(subVersion);</span><br><span class="line">        requestHeader.setExpressionType(expressionType);</span><br><span class="line">        String brokerAddr = findBrokerResult.getBrokerAddr();</span><br><span class="line">        <span class="comment">// 有过滤标记</span></span><br><span class="line">        <span class="keyword">if</span> (PullSysFlag.hasClassFilterFlag(sysFlagInner)) &#123;</span><br><span class="line">            <span class="comment">// 随机选择一个FilterServer的地址，之后就从FilterServer拉取消息</span></span><br><span class="line">            brokerAddr = computPullFromWhichFilterServer(mq.getTopic(), brokerAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送PULL_MESSAGE请求，从Broker拉取消息</span></span><br><span class="line">        PullResult pullResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().pullMessage(brokerAddr, requestHeader, timeoutMillis, communicationMode, pullCallback);</span><br><span class="line">        <span class="keyword">return</span> pullResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MQClientAPIImpl#pullMessageAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessageAsync</span><span class="params">(<span class="keyword">final</span> String addr, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis, <span class="keyword">final</span> PullCallback pullCallback)</span> <span class="keyword">throws</span> RemotingException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remotingClient.invokeAsync(addr, request, timeoutMillis, <span class="keyword">new</span> InvokeCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ResponseFuture responseFuture)</span> </span>&#123;</span><br><span class="line">            RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PullResult pullResult = MQClientAPIImpl.<span class="keyword">this</span>.processPullResponse(response);</span><br><span class="line">                    <span class="keyword">assert</span> pullResult != <span class="keyword">null</span>;</span><br><span class="line">                    pullCallback.onSuccess(pullResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    pullCallback.onException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PullAPIWrapper#processPullResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PullResult <span class="title">processPullResult</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> PullResult pullResult, <span class="keyword">final</span> SubscriptionData subscriptionData)</span> </span>&#123;</span><br><span class="line">    PullResultExt pullResultExt = (PullResultExt) pullResult;</span><br><span class="line">    <span class="comment">// 根据Broker的返回建议，更新下次建议拉取的Broker</span></span><br><span class="line">    <span class="keyword">this</span>.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId());</span><br><span class="line">    <span class="comment">// 拉取到了消息</span></span><br><span class="line">    <span class="keyword">if</span> (PullStatus.FOUND == pullResult.getPullStatus()) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary());</span><br><span class="line">        <span class="comment">// 解码拉取的消息列表</span></span><br><span class="line">        List&lt;MessageExt&gt; msgList = MessageDecoder.decodes(byteBuffer);</span><br><span class="line">        List&lt;MessageExt&gt; msgListFilterAgain = msgList;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptionData.getTagsSet().isEmpty() &amp;&amp; !subscriptionData.isClassFilterMode()) &#123;</span><br><span class="line">            msgListFilterAgain = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(msgList.size());</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg.getTags() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Broker只是根据Tag的哈希值过滤，因为可能存在哈希冲突，Consumer需要根据字符串再次过滤</span></span><br><span class="line">                    <span class="keyword">if</span> (subscriptionData.getTagsSet().contains(msg.getTags())) &#123;</span><br><span class="line">                        msgListFilterAgain.add(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行钩子函数，用于过滤消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasHook()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (MessageExt msg : msgListFilterAgain) &#123;</span><br><span class="line">            <span class="comment">// 一些属性处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        pullResultExt.setMsgFoundList(msgListFilterAgain);</span><br><span class="line">    &#125;</span><br><span class="line">    pullResultExt.setMessageBinary(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> pullResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessQueue#putMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否分发给消费者消费</span></span><br><span class="line">    <span class="keyword">boolean</span> dispatchToConsume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">this</span>.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> validMsgCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                <span class="comment">// 将消息加入TreeMap，等待被消费</span></span><br><span class="line">                <span class="comment">// 注意这里TreeMap会自动排序，键为消息在队列的偏移（索引）</span></span><br><span class="line">                MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line">                <span class="comment">// 消息未重复</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">                    validMsgCnt++;</span><br><span class="line">                    <span class="comment">// 更新队列最大偏移</span></span><br><span class="line">                    <span class="keyword">this</span>.queueOffsetMax = msg.getQueueOffset();</span><br><span class="line">                    msgSize.addAndGet(msg.getBody().length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msgCount.addAndGet(validMsgCnt);</span><br><span class="line">            <span class="comment">// Map有消息被消费 &amp;&amp; 当前此ProcessQueue没被消费</span></span><br><span class="line">            <span class="keyword">if</span> (!msgTreeMap.isEmpty() &amp;&amp; !<span class="keyword">this</span>.consuming) &#123;</span><br><span class="line">                <span class="comment">// 分发给消费者消费</span></span><br><span class="line">                dispatchToConsume = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 标记为正在被消费</span></span><br><span class="line">                <span class="keyword">this</span>.consuming = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockTreeMap.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dispatchToConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>顺序消费</p>
<p>ConsumeMessageOrderlyService#submitConsumeRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs, <span class="keyword">final</span> ProcessQueue processQueue, <span class="keyword">final</span> MessageQueue messageQueue, <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="comment">// 提交消费请求</span></span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsumeMessageOrderlyService$ConsumeRequest#run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// ProcessQueue被标记为废弃就不再消费</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 获取该MessageQueue的锁对象</span></span><br><span class="line">     <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">     <span class="comment">// 获取同步锁</span></span><br><span class="line">     <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">         <span class="comment">// 广播模式 || 集群消费模式，ProcessQueue被锁定并且没失效</span></span><br><span class="line">         <span class="keyword">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel()) || (<span class="keyword">this</span>.processQueue.isLocked() &amp;&amp; !<span class="keyword">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">             <span class="comment">//</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>; continueConsume; ) &#123;</span><br><span class="line">                 <span class="comment">// 每次消费前检查，ProcessQueue被标记为废弃就不再消费</span></span><br><span class="line">                 <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 集群消费模式 &amp;&amp; ProcessQueue没被锁定</span></span><br><span class="line">                 <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel()) &amp;&amp; !<span class="keyword">this</span>.processQueue.isLocked()) &#123;</span><br><span class="line">                     <span class="comment">// 稍后向Broker发送LOCK_BATCH_MQ请求，获取该MessageQueue的分布式锁，然后重新提交ConsumeRequest请求</span></span><br><span class="line">                     ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 集群消费模式 &amp;&amp; ProcessQueue锁失效</span></span><br><span class="line">                 <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel()) &amp;&amp; <span class="keyword">this</span>.processQueue.isLockExpired()) &#123;</span><br><span class="line">                     <span class="comment">// 稍后向Broker发送LOCK_BATCH_MQ请求，获取该MessageQueue的分布式锁，然后重新提交ConsumeRequest请求</span></span><br><span class="line">                     ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">10</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 提交分布式锁请求耗时</span></span><br><span class="line">                 <span class="keyword">long</span> interval = System.currentTimeMillis() - beginTime;</span><br><span class="line">                 <span class="comment">// 时间过长，超过60秒</span></span><br><span class="line">                 <span class="keyword">if</span> (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) &#123;</span><br><span class="line">                     <span class="comment">// 重新提交ConsumeRequest请求</span></span><br><span class="line">                     ConsumeMessageOrderlyService.<span class="keyword">this</span>.submitConsumeRequestLater(processQueue, messageQueue, <span class="number">10</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// 本次消费的消息数量</span></span><br><span class="line">                 <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">                 <span class="comment">// 从处理队列拿出消息，顺序消费会把待消费的消息取出，并放入临时的TreeMap中，按队列偏移排序，所以是有序消费</span></span><br><span class="line">                 <span class="comment">// 另外，takeMessags拼写错误</span></span><br><span class="line">                 List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">                 defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                 <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                     <span class="keyword">final</span> ConsumeOrderlyContext context = <span class="keyword">new</span> ConsumeOrderlyContext(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">                     ConsumeOrderlyStatus status = <span class="keyword">null</span>;</span><br><span class="line">                     ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="comment">// 执行前置Hook</span></span><br><span class="line">                     <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">                     ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                     <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="comment">// 先获取ProcessQueue锁</span></span><br><span class="line">                         <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">                         <span class="comment">// 再次检查</span></span><br><span class="line">                         <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="comment">// 再使用监听器消费消息，返回消费状态，注意消费都是批量的</span></span><br><span class="line">                         status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                         <span class="comment">// 最后释放ProcessQueue锁</span></span><br><span class="line">                         <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// ...</span></span><br><span class="line">                     <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 消费成功</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeOrderlyStatus.SUCCESS == status) &#123;</span><br><span class="line">                         returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// ...</span></span><br><span class="line">                     <span class="comment">// 执行后置Hook</span></span><br><span class="line">                     <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                         <span class="comment">// ...</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     ConsumeMessageOrderlyService.<span class="keyword">this</span>.getConsumerStatsManager().incConsumeRT(ConsumeMessageOrderlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line">                     <span class="comment">// 根据消费结果决定是否继续消费</span></span><br><span class="line">                     continueConsume = ConsumeMessageOrderlyService.<span class="keyword">this</span>.processConsumeResult(msgs, status, context, <span class="keyword">this</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 集群消费模式，队列没被锁定或者锁失效</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 稍后向Broker发送LOCK_BATCH_MQ请求，获取该MessageQueue的分布式锁，然后重新提交ConsumeRequest请求</span></span><br><span class="line">             <span class="comment">// 集群模式下，队列必须被锁定才能被消费</span></span><br><span class="line">             ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">100</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ConsumeMessageOrderlyService#processConsumeResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs, <span class="keyword">final</span> ConsumeOrderlyStatus status, <span class="keyword">final</span> ConsumeOrderlyContext context, <span class="keyword">final</span> ConsumeRequest consumeRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffset = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// 默认，自动提交消费进度</span></span><br><span class="line">    <span class="keyword">if</span> (context.isAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="comment">// 返回本批消息的队列消费偏移</span></span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="comment">// 统计</span></span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="comment">// 消息未超过最大重消费次数，或者超出了并且把消息发回Broker的死信队列失败</span></span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    <span class="comment">// 设置可重新消费，将本批消息放回ProcessQueue</span></span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="comment">// 提交延迟消费请求，延迟消费该队列</span></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue(), context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    <span class="comment">// 不能继续消费，顺序消息，不能跳过</span></span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 消息超过最大重消费次数，并且发送回死信队列成功</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回本批消息的队列消费偏移</span></span><br><span class="line">                    commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列的消费偏移 &gt;= 0 &amp;&amp; ProcessQueue未被标志为废弃</span></span><br><span class="line">    <span class="keyword">if</span> (commitOffset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="comment">// 更新本地缓存中的该MessageQueue的消费进度</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> continueConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessQueue#commit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">this</span>.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从本批消费的消息中获取最大消息队列偏移</span></span><br><span class="line">            Long offset = <span class="keyword">this</span>.consumingMsgOrderlyTreeMap.lastKey();</span><br><span class="line">            msgCount.addAndGet(<span class="number">0</span> - <span class="keyword">this</span>.consumingMsgOrderlyTreeMap.size());</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : <span class="keyword">this</span>.consumingMsgOrderlyTreeMap.values()) &#123;</span><br><span class="line">                msgSize.addAndGet(<span class="number">0</span> - msg.getBody().length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 消费完就清除</span></span><br><span class="line">            <span class="keyword">this</span>.consumingMsgOrderlyTreeMap.clear();</span><br><span class="line">            <span class="keyword">if</span> (offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 返回消费进度</span></span><br><span class="line">                <span class="keyword">return</span> offset + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockTreeMap.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>并发消费</p>
<p>ConsumeMessageConcurrentlyService#submitConsumeRequest</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs, <span class="keyword">final</span> ProcessQueue processQueue, <span class="keyword">final</span> MessageQueue messageQueue, <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">    <span class="comment">// 提交消费的数量小于等于批量消费的数量</span></span><br><span class="line">    <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 提交给线程池，所以是多线程并发消费</span></span><br><span class="line">            <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// 被拒绝就稍后再提交</span></span><br><span class="line">            <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大于</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 两层循环拆分消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">            List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                    msgThis.add(msgs.get(total));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 拆分后分批提交</span></span><br><span class="line">                <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                    msgThis.add(msgs.get(total));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsumeMessageConcurrentlyService$ConsumeRequest#run</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 执行前置Hook</span></span><br><span class="line">    <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 消费消息，返回消费状态</span></span><br><span class="line">        status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些状态判断，略</span></span><br><span class="line">    <span class="comment">// 执行后置钩子</span></span><br><span class="line">    <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">        <span class="comment">// 处理消费结果</span></span><br><span class="line">        ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConsumeMessageConcurrentlyService#processConsumeResult</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(<span class="keyword">final</span> ConsumeConcurrentlyStatus status, <span class="keyword">final</span> ConsumeConcurrentlyContext context, <span class="keyword">final</span> ConsumeRequest consumeRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始值为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line">    <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 消费状态</span></span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">            <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                <span class="comment">// 本批消息中最后一个消息的索引</span></span><br><span class="line">                ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本批消息成功消费的数量</span></span><br><span class="line">            <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 稍后再消费</span></span><br><span class="line">        <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">            <span class="comment">// 这批消息都要发回Broker</span></span><br><span class="line">            ackIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费模式</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="comment">// 广播模式</span></span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="comment">// 从最后一个消费成功的消息后的消息开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="comment">// 消费失败，忽略并丢弃</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 集群模式</span></span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="comment">// 遍历消费失败的消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="comment">// 直接将消息发回Broker，期待重新发送，这里也会导致乱序</span></span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                <span class="comment">// 发回失败</span></span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                    msgBackFailed.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 移除消费失败的消息</span></span><br><span class="line">                consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                <span class="comment">// 发回Broker失败，则再次提交消费请求，所以跳过了消费失败的消息，不是有序的</span></span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费完毕，将消费成功的消息从ProcessQueue移除，返回下条待消费的消息的偏移</span></span><br><span class="line">    <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="comment">// 更新消费偏移</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProcessQueue#removeMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">this</span>.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">this</span>.lastConsumeTimestamp = now;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 消息的最大偏移 + 1</span></span><br><span class="line">                result = <span class="keyword">this</span>.queueOffsetMax + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> removedCnt = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 遍历消息</span></span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="comment">// 删除消费成功的消息</span></span><br><span class="line">                    MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        removedCnt--;</span><br><span class="line">                        msgSize.addAndGet(<span class="number">0</span> - msg.getBody().length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msgCount.addAndGet(removedCnt);</span><br><span class="line">                <span class="comment">// 删除后还有消息，说明剩下消费失败的消息</span></span><br><span class="line">                <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// TreeMap，按偏移升序，第一个是最小的偏移，这里就是消费失败的第一条消息的队列偏移</span></span><br><span class="line">                    <span class="comment">// 假设多线程并发消费队列里的消息1，2，3，4，5，可能消费的顺序是1，4，2，5，3</span></span><br><span class="line">                    <span class="comment">// 返回最小偏移可以避免消费未被消费，但是可能会导致重复消费</span></span><br><span class="line">                    result = msgTreeMap.firstKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockTreeMap.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>关于顺序消息</p>
<p>Producer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>;</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTestjjj"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(</span><br><span class="line">                    msg,</span><br><span class="line">                    <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                            Integer id = (Integer) arg;</span><br><span class="line">                            <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                            <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// Producer单线程同步顺序发送消息，且发送到同一个队列，也是同一个Broker，因为顺序存储，所以是有序的</span></span><br><span class="line">                    <span class="comment">// 以OrderId指定队列发送，所以相同的OrderId发到同一个队列</span></span><br><span class="line">                    orderId);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Broker：不需要做任何处理。</p>
<p>Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">    consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">        AtomicLong consumeTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">            context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">this</span>.consumeTimes.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.ROLLBACK;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.COMMIT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.consumeTimes.get() % <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                context.setSuspendCurrentQueueTimeMillis(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序消费下，一个Queue同时只允许一个Consumer消费，Consumer只有先向Broker获取到Queue的锁才能消费消息，同时消息消费失败时会重试，直到超过最大次数，则将消息发回Broker的死信队列，不会再次消费。</p>
<p>并发消费下，Consumer拉取到消息后回被放入ProcessQueue，有多个线程同时处理队列中的消息，同时消息消费失败时会跳过该消息，并将消息发回Broker，下次继续消费。</p>
<p>另外，顺序消费需要注意消息堆积的问题。</p>
<p>顺序消息也不是绝对的，两条顺序消息MsgA和MsgB，MsgA发到BrokerA的QueueA，之后BrokerA关闭，MsgB发到BrokerB的QueueB，这样就不能保证顺序消费了。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
