<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-J.U.C-ThreadPoolExecutor | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-J.U.C-ThreadPoolExecutor">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-J.U.C-ThreadPoolExecutor</h2>
				
				<div>
					<div class="post-time">2019-04-20</div>
				</div>
				
				<div class="article-content">
				<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    // 记录线程池中的任务数量和线程池状态 高低位</span><br><span class="line">    // workerCount：当前有效的线程数</span><br><span class="line">    // runState：线程池的五种状态，Running、Shutdown、Stop、Tidying、Terminate</span><br><span class="line">    // int一共有32位，runState至少需要3位，故workCount有29位，所以线程池的有效线程数最多为...</span><br><span class="line">    // 初始化为RUNNING状态，并且任务数量初始化为0</span><br><span class="line">    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final int COUNT_BITS = Integer.SIZE - 3; // 32-3=29，线程数量所占位数</span><br><span class="line"></span><br><span class="line">    // 00000000 00000000 00000001 --&gt; 001 0000 00000000 00000000 00000000</span><br><span class="line">    // 000 11111 11111111 11111111 11111111</span><br><span class="line">    private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // 低29位表示最大线程数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // int型变量高3位（含符号位）</span><br><span class="line">    private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 初始化状态，能够接收新任务，处理已添加的任务</span><br><span class="line">    private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // shutdown，不接收新任务，但能处理已添加的任务</span><br><span class="line">    private static final int STOP = 1 &lt;&lt; COUNT_BITS; // shutdownNow，不接收新任务，不处理已添加的任务，中断正在处理的任务</span><br><span class="line"></span><br><span class="line">    // 变为TIDYING状态时，会执行钩子函数terminated()</span><br><span class="line">    private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 所有的任务已终止，ctl记录的任务数量为0，线程池会变为TIDYING状态</span><br><span class="line">    private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 线程池彻底终止 TIDYING状态时，执行完terminated()之后</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 阻塞队列</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">// 互斥锁</span><br><span class="line">private final ReentrantLock mainLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">// 线程集合 一个Worker对应一个线程</span><br><span class="line">private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">// 终止条件</span><br><span class="line">private final Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">// 线程池中线程数量曾经达到过的最大值</span><br><span class="line">private int largestPoolSize;</span><br><span class="line"></span><br><span class="line">// ThreadFactory对象，用于创建线程</span><br><span class="line">private volatile ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">// 拒绝策略</span><br><span class="line">private volatile RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">// 线程存活时间</span><br><span class="line">private volatile long keepAliveTime;</span><br><span class="line"></span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">// 已完成任务数量</span><br><span class="line">private long completedTaskCount;</span><br><span class="line"></span><br><span class="line">// 核心池大小</span><br><span class="line">private volatile int corePoolSize;</span><br><span class="line"></span><br><span class="line">// 最大池大小</span><br><span class="line">private volatile int maximumPoolSize;</span><br><span class="line"></span><br><span class="line">// 默认拒绝策略</span><br><span class="line">private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();</span><br><span class="line"></span><br><span class="line">private static final RuntimePermission shutdownPerm = new RuntimePermission(&quot;modifyThread&quot;);</span><br><span class="line"></span><br><span class="line">private final AccessControlContext acc;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 继承了AQS，实现了Runnable</span><br><span class="line">private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final Thread thread;</span><br><span class="line"></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    volatile long completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        // 设置AQS的同步状态为-1，防止执行shutDown，禁止中断，直到调用runWorker，设为0</span><br><span class="line">        // shutDownNow同样也判断了state必须大于等于0才能interrupt</span><br><span class="line">        setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">        this.firstTask = firstTask;</span><br><span class="line">        // 通过线程工厂来创建线程，将自身传递</span><br><span class="line">        this.thread = getThreadFactory().newThread(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        runWorker(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 向线程池提交任务的时候，线程池会创建一个FutureTask返回</span><br><span class="line">public mmp.Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 执行</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null) throw new NullPointerException();</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 1 线程数量小于核心线程数，则创建线程</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 添加成功则直接返回</span><br><span class="line">        if (addWorker(command, true)) return;</span><br><span class="line">        // 否则再次获取活动线程数量</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 2 核心线程数已满</span><br><span class="line">    // 线程池正在运行 &amp;&amp; 任务队列未满，添加进队列成功</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        // 再次检查线程池状态， 因为上面addWorker过了并且失败了</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 如果状态不是运行状态，且从队列删除该任务成功并尝试停止线程池，拒绝任务</span><br><span class="line">        if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command);</span><br><span class="line">            // 如果当前工作线程数量为0（线程池已关闭），则添加一个空任务到队列中</span><br><span class="line">        else if (workerCountOf(recheck) == 0) addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3 核心池已满，队列已满，添加队列失败，则创建一个任务线程，如果失败，则拒绝</span><br><span class="line">    else if (!addWorker(command, false)) reject(command);</span><br><span class="line"></span><br><span class="line">    // 1 和 3 新建线程时需要获取全局锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 创建线程</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">        // 再次检查线程池是否处于运行状态</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())) return false;</span><br><span class="line"></span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            // 线程池中线程的数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 判断线程数量是否溢出</span><br><span class="line">            if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false;</span><br><span class="line">            // CAS将正在运行的线程数+1，成功则退出循环</span><br><span class="line">            if (compareAndIncrementWorkerCount(c)) break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            // 检查线程池运行状态，如果与之前的状态不同，则从retry重新开始</span><br><span class="line">            if (runStateOf(c) != rs) continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 正在运行的线程数自增成功后则将线程封装成工作线程Worker</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    ThreadPoolExecutor.Worker w = null;</span><br><span class="line">    // 添加任务到线程池，并启动任务所在的线程</span><br><span class="line">    try &#123;</span><br><span class="line">        // 新建Worker，并且指定firstTask为Worker的第一个任务</span><br><span class="line">        w = new ThreadPoolExecutor.Worker(firstTask);</span><br><span class="line">        // 获取Worker对应的线程</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            // 获取锁</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 再次确认线程池运行状态</span><br><span class="line">                if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    if (t.isAlive()) throw new IllegalThreadStateException();</span><br><span class="line">                    // 将Worker对象添加到线程池的Worker集合中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    // 更新largestPoolSize</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize) largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 释放锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果成功将任务添加到线程池中，则启动任务所在的线程</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 在启动工作线程失败后，将工作线程从集合中移除</span><br><span class="line">        if (!workerStarted) addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回任务是否启动</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 核心</span><br><span class="line">final void runWorker(ThreadPoolExecutor.Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 不断从队列里边拿任务执行</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.</span><br><span class="line">            // This requires a recheck in second case to deal with shutdownNow race while clearing interrupt</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 切面</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 首先执行firstTask的run方法，然后循环获取阻塞队列中的任务，并run</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x;</span><br><span class="line">                    throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 如果线程池中的任务异常，就抛出异常并停止运行线程池</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池的作用：</p>
<ul>
<li><p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用</p>
</li>
<li><p>调整线程池中工作线程的数量，限流作用</p>
</li>
</ul>
<p>建议：</p>
<ul>
<li><p>CPU密集型：避免线程争抢资源，无用的切换线程上下文，配置尽量少的线程，比如CPU个数；</p>
</li>
<li><p>IO密集型：需要长时间等待，可以配置多一些线程，比如CPU数的两倍。</p>
</li>
</ul>
<p>获取 CPU 核心数：<code>Runtime.getRuntime().availableProcessors()</code>。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
