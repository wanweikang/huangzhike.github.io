<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-J.U.C-AbstractQueuedSynchronizer | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-J.U.C-AbstractQueuedSynchronizer">
		
		<meta property="og:site_name" content="一个放笔记的地方而已">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-J.U.C-AbstractQueuedSynchronizer</h2>
				
				<div>
					<div class="post-time">2019-04-20</div>
				</div>
				
				<div class="article-content">
				<p>结合Lock和Condition的使用看比较好。</p>
<p>内部类，链表节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// AQS队列的节点，双向链表</span><br><span class="line">static final class Node &#123;</span><br><span class="line">    // 共享模式</span><br><span class="line">    static final Node SHARED = new Node();</span><br><span class="line">    // 独占模式</span><br><span class="line">    static final Node EXCLUSIVE = null;</span><br><span class="line">    // 因为超时或中断，线程已被取消，等待被踢出队列</span><br><span class="line">    static final int CANCELLED = 1;</span><br><span class="line">    // 当前节点的的后继节点将要或已被阻塞，在当前节点释放的时要unpark后继节点</span><br><span class="line">    static final int SIGNAL = -1;</span><br><span class="line">    // 线程在Condition队列等待唤醒</span><br><span class="line">    static final int CONDITION = -2;</span><br><span class="line">    // releaseShared需要被传播给后续节点，后续的acquireShared可以执行</span><br><span class="line">    // 共享模式头Node，锁的下一次获取可以无条件传播</span><br><span class="line">    static final int PROPAGATE = -3;</span><br><span class="line"></span><br><span class="line">    // 节点的状态 CANCELLED, SIGNAL, CONDITION, PROPAGATE, 0(节点在队列中等待获取锁)</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    // AQS队列前驱节点</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    // AQS队列后继节点</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    // 节点对应的线程</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    // Condition队列中的后继节点，并区别独占锁还是共享锁</span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">    // AQS队列的队首 头结点不存储Thread，仅保存next结点的引用</span><br><span class="line">    private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">    // AQS队列的队尾</span><br><span class="line">    private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">    // 锁的状态</span><br><span class="line">    // 对于独占锁，state=0表示锁是可获取状态(锁没有被任何线程锁持有)</span><br><span class="line">    // 由于锁可重入，state的值可以&gt;1</span><br><span class="line">    private volatile int state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取独占锁，如果获取不到，加入等待队列等待被唤醒，如果被中断则中止</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    // 首先通过tryAcquire()尝试获取锁，获取成功直接返回</span><br><span class="line">    // 失败，addWaiter()将当前线程加入到AQS队列末尾</span><br><span class="line">    // 然后调用acquireQueued()，在AQS队列中等待获取锁，在此过程中，线程阻塞，直到获取锁了才返回</span><br><span class="line">    // 如果在等待过程中被中断过，则selfInterrupt()自己产生一个中断（之前的被清除了）</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 将当前线程添加到AQS队尾，等待获取锁</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    // 将线程构造成节点</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    // 队列不为空，尝试直接挂到AQS同步队列队尾</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果此时有多个线程都把自己挂到队尾，CAS就会失败，enq循环至成功</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 死循环，直到成功加到同步队列尾部才退出，返回前继节点（原tail）</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    // 自旋</span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // tail为null，说明还没初始化，创建一个空节点，CAS设为head，成功就将tail也指向它</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node())) tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则，将当前线程节点作为tail节点加入到AQS中去</span><br><span class="line">        else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                // CAS成功后将双向链表连起来</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 关于虚拟的head节点，作用是防止重复释放锁</span><br><span class="line"> * 当第一个进入队列的节点没有前驱节点的时候，就会创建一个虚拟的，再把自己挂到末尾</span><br><span class="line"> * 每个节点在休眠前，都要将前驱节点的 ws 设置成 SIGNAL，表示，当节点释放锁的时候，需要唤醒下一个节点，否则自己永远无法被唤醒</span><br><span class="line"> * 但是第一个节点，没有前置节点，那就创建一个空节点，保持一致</span><br><span class="line"> * */</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 从队列中获取锁，并返回当前线程在等待过程中有没有中断过</span><br><span class="line">// 如果获取到了锁，返回，否则，公平阻塞等待，直到唤醒并重新获取锁了才返回</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        // interrupted表示在AQS队列的调度中，线程阻塞时，有没有被中断过</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        // 自旋</span><br><span class="line">        for (; ; ) &#123;</span><br><span class="line">            // 如果当前节点因为其它节点调用unpark()而被唤醒，那么唤醒它的应该是它的前驱节点</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line"></span><br><span class="line">            // 公平</span><br><span class="line">            // 如果节点的前驱是head（空节点），就可以尝试获取锁tryAcquire()</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                // 如果获取到，则将自己设置为头节点</span><br><span class="line">                setHead(node);</span><br><span class="line">                // 原head指向自己的next设成null</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                // 返回false，没有中断</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 如果当前节点是因为中断而唤醒，那就不公平了</span><br><span class="line">            // 唤醒不表示线程能立刻运行，而是表示线程处于就绪状态，可以运行而已</span><br><span class="line"></span><br><span class="line">            // 如果可以安全阻塞（设置好前继SIGNAL了），就尝试阻塞自己等待，然后返回线程的中断状态并复位中断状态</span><br><span class="line"></span><br><span class="line">            // 如果当前线程是非中断状态，parkAndCheckInterrupt被阻塞，直到被唤醒，返回中断状态并复位，再次循环</span><br><span class="line">            // 如果当前线程是中断状态，park不起作用，会立即返回，parkAndCheckInterrupt返回true，并恢复中断状态</span><br><span class="line">            // 再次循环进来时，由于之前已经复位该线程的中断状态，再次调用park方法时会阻塞</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;</span><br><span class="line">            // 这里判断中断是为了不让循环一直执行，让当前线程进入阻塞</span><br><span class="line">            // 否则前一个线程在获取锁之后执行了耗时操作，那就要一直循环下去，造成CPU使用率飙升</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed) cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 返回当前线程是否应该阻塞</span><br><span class="line">// 挂起自己之前，需要将前驱节点的ws设成SIGNAL，让前驱释放锁的时候唤醒自己</span><br><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws = pred.waitStatus;</span><br><span class="line">    // 如果前驱节点已经是SIGNAL，当前线程可以安全被阻塞，返回true</span><br><span class="line">    if (ws == Node.SIGNAL) return true;</span><br><span class="line">    // 如果前驱节点非有效（CANCELLED），跳过并重试</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            // 将pred.prev赋值给node.prev</span><br><span class="line">            node.prev = pred = pred.prev; // 前驱节点已取消，不会再获取同步状态，把前驱节点移除</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        // 将pred.prev的 next 赋值为当前节点</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果前驱节点 0 || CONDITION || PROPAGATE，则设置前驱节点为SIGNAL</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    // false 重来</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 阻塞当前线程，并返回线程被唤醒之后的中断状态</span><br><span class="line">// 线程被阻塞后唤醒一般有两种情况：</span><br><span class="line">// 1：unpark。前驱节点用完锁之后，通过unpark()唤醒当前线程</span><br><span class="line">// 2：中断。其它线程通过interrupt()中断当前线程</span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); // 可响应中断，但是不会抛出异常</span><br><span class="line">    return Thread.interrupted(); // 这里会复位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁，并唤醒阻塞在锁上的线程</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 如果释放锁成功，返回true</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line"></span><br><span class="line">        Node h = head;</span><br><span class="line">        // 释放成功后，唤醒head的后继节点</span><br><span class="line">        // head必须不等于0，0说明已经释放过了，不能重复释放</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放失败</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 一旦头节点的后继节点被唤醒，后继节点就会尝试去获取锁</span><br><span class="line">// 在acquireQueued中node就是有效的后继节点，p就是唤醒它的头结点</span><br><span class="line">// 如果成功就会将头结点设置为自身，并且将头结点的前驱节点置空，这样前驱节点就可以被GC</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    // 此时节点是head，代表要释放锁的节点</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // ws != CANCELLED</span><br><span class="line">    // CAS将head.ws置为0，清除信号，表示已释放，不能重复释放</span><br><span class="line">    if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    // 从头结点的下一个节点开始寻找后继节点</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    // 当且仅当后继节点的waitStatus&lt;=0才是有效后继节点</span><br><span class="line">    // 否则将waitStatus&gt;0（CANCELLED）节点从队列中剔除</span><br><span class="line">    // 通常这个节点是head.next，但如果head.next==null || head.next被取消了，就会从尾部开始找</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        // 从尾部开始，向前寻找未被取消的节点，直到head</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0) s = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果找到一个有效的后继节点，就唤醒此节点</span><br><span class="line">    if (s != null) LockSupport.unpark(s.thread);</span><br><span class="line"></span><br><span class="line">    // 关于从尾部查找的逻辑：</span><br><span class="line">    // lock()的线程可能会被中断，这时已经进入CHL队列的节点就会被CANCELLED，也就是会移出队列</span><br><span class="line">    // 移出队列 cancelAcquire 就是让前驱有效节点的next指向被移出节点node的next</span><br><span class="line">    // cas(cancelled_node.pre.next, cancelled_node, cancelled_node.next);</span><br><span class="line">    // 并且将cancelled_node.next指向cancelled_node，也就是cancelled_node没有后继节点了，但是不修改前驱节点</span><br><span class="line">    // 如果从后往前遍历到被删出节点node时，根据cancelled_node.pre可以继续往前，直到head为止</span><br><span class="line">    // 如果要想从head往后遍历，逻辑就是：cas(cancelled_node.next.pre, cancelled_node, cancelled_node.pre);</span><br><span class="line">    // 差别在于，由于存在傀儡节点（head），cancelled_node.pre总是存在的，更容易处理</span><br><span class="line"></span><br><span class="line">    // 唤醒后的逻辑：拿锁，设置自己为head，断开前驱head和自己的连接</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
