<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-设计模式-其它 | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-设计模式-其它">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>Index
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-设计模式-其它</h2>
				
				<div>
					<div class="post-time">2017-01-27</div>
				</div>
				
				<div class="article-content">
				<p>参考：<br>JavaScript设计模式与开发实践 曾探<br>深入理解JavaScript 汤姆大叔</p>
<p>设计模式的作用是让人们写出可复用和可维护性高的程序。</p>
<p><strong> Constructor—— 构造器模式 </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name, id) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.getId = function() &#123;</span><br><span class="line">	return this.id;</span><br><span class="line">&#125;;</span><br><span class="line">var student = new Student(&quot;hzk&quot;, 1);</span><br></pre></td></tr></table></figure>
<p><strong> Prototype—— 原型模式 </strong></p>
<p>ES5提供了Object.create(prototype, optionalDescriptorObjects) 方法， 用于创建一个对象， 使其拥有指定的原型和可选属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">	name: &quot;hzk&quot;,</span><br><span class="line">	sayHello: function() &#123;</span><br><span class="line">		return &quot;hello, &quot; + this.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var child = Object.create(parent, &#123;</span><br><span class="line">	id: &#123;</span><br><span class="line">		value: 001</span><br><span class="line">		writable: false,</span><br><span class="line">		configurable: false,</span><br><span class="line">		enumerable: false</span><br><span class="line">	&#125;,</span><br><span class="line">	age: &#123;</span><br><span class="line">		value: 22,</span><br><span class="line">		writable: true,</span><br><span class="line">		configurable: true,</span><br><span class="line">		enumerable: true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Polyfill： Object.create方法在ES5中定义， 简单的不支持optionalDescriptorObjects如下：<br>要注意浅拷贝和深拷贝， 免得出现引用问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.create = function(parent) &#123;</span><br><span class="line">	function F() &#123;&#125;</span><br><span class="line">	F.prototype = parent;</span><br><span class="line">	return new F();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong> Mixin—— 混入模式子类化 </strong></p>
<p>子类化是指针对一个新对象， 从一个基础或超类对象中继承相关的属性。 比如B继承A， 那么B是A的子类， A是B的超类（ 父类）。<br>B的所有实例从A处继承了相关方法， 但B仍然能够定义自己的方法， 以及重写A所定义的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Student = function(name, id) &#123;</span><br><span class="line">	Person.call(this, name);</span><br><span class="line">	this.id = id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student.prototype = Object.create(Person.prototype);</span><br><span class="line"></span><br><span class="line">var student = new Student(&quot;hzk&quot;, 001);</span><br><span class="line">console.log(student);</span><br></pre></td></tr></table></figure></p>
<p>超类为Person类， 子类为Student类， 在Student类实例化时， 首先会调用超类构造函数， 将超类的属性写入到子类中， 而超类的原型也存在于子类的原型链上， 超类原型上的方法也将被子类继承。</p>
<p>可以将继承Mixin看做一种通过扩展收集功能的方式。 通过向构造函数的prototype中扩展mixin对象来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 实现扩展方法</span><br><span class="line">function extend(obj, mixin) &#123;</span><br><span class="line">	for (var item in mixin) &#123;</span><br><span class="line">		obj[item] = mixin[item];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 创建需要扩展的功能集合</span><br><span class="line">var myMixin = &#123;</span><br><span class="line">	sayHello: function() &#123;</span><br><span class="line">		console.log(this.name + &quot; says: Hello!&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">// 将扩展应用到构造函数prototype中</span><br><span class="line">extend(Student.prototype, myMixin);</span><br><span class="line"></span><br><span class="line">var student = new Student(&quot;hzk&quot;, 001);</span><br><span class="line">// 新建的实例拥有扩展方法</span><br><span class="line">student.sayHello(); //hzk says: Hello!</span><br></pre></td></tr></table></figure></p>
<p><strong> Factory—— 工厂模式 </strong></p>
<p>Factory是一种创建型模式， 它不显式地要求使用构造函数。 而Factory可以提供一个通用的接口来创建对象， 只需要告诉工厂需要创建的对象类型，比如有水平菜单和垂直菜单的构造函数， 分别为HorizontalMenu和VerticalMenu。 可以定义一个菜单工厂MenuFactory来进行菜单创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 水平菜单构造函数</span><br><span class="line"></span><br><span class="line">function HorizontalMenu(options) &#123;</span><br><span class="line">	this.color = options.color || &quot;black&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 垂直菜单构造函数</span><br><span class="line"></span><br><span class="line">function VerticalMenu(options) &#123;</span><br><span class="line">	this.color = options.color || &quot;black&quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 菜单工厂</span><br><span class="line"></span><br><span class="line">function MenuFactory() &#123;&#125;</span><br><span class="line">// 默认情况下创造的菜单类型</span><br><span class="line">MenuFactory.prototype.menuClass = VerticalMenu;</span><br><span class="line">// 工厂创建菜单的方法</span><br><span class="line">MenuFactory.prototype.createMenu = function(options) &#123;</span><br><span class="line">	if (options.type === &quot;vertical&quot;) &#123;</span><br><span class="line">		this.menuClass = VerticalMenu;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		this.menuClass = HorizontalMenu;</span><br><span class="line">	&#125;</span><br><span class="line">	return new this.menuClass(options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>工厂方法最大的好处就是提供了通用接口创建实例， 比如新增一个动画菜单AnimationMenu类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function AnimationMenu(options) &#123;</span><br><span class="line">	this.color = options.color || &quot;black&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要在工厂方法中添加一个 if就行了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 工厂创建菜单的方法</span><br><span class="line">MenuFactory.prototype.createMenu = function(options) &#123;</span><br><span class="line">	if (options.type === &quot;vertical&quot;) &#123;</span><br><span class="line">		this.menuClass = VerticalMenu;</span><br><span class="line">	&#125; else if (options.type === &quot;animation&quot;) &#123;</span><br><span class="line">		this.menuClass = AnimationMenu;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		this.menuClass = HorizontalMenu;</span><br><span class="line">	&#125;</span><br><span class="line">	return new this.menuClass(options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong> Abstract Factory—— 抽象工厂 </strong></p>
<p>Abstract Factory用于封装一组具有共同目标的单个工厂。 它能够将一组对象的实现细节从一般用法中分离出来。<br>当一个系统必须独立于它所创建的对象的生成方式， 或它需要与多种对象类型一起工作时， 应当使用抽象工厂，以之前的菜单工厂为例， 定义一个抽象菜单工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var AbstractMenuFactory = (function() &#123;</span><br><span class="line">	var constructors = &#123;&#125;;</span><br><span class="line">	// 根据type创建实例</span><br><span class="line"></span><br><span class="line">	function createMenu(type, options) &#123;</span><br><span class="line">		var menuConstructor = constructors[type];</span><br><span class="line">		return menuConstructor ? new menuConstructor(options) : null;</span><br><span class="line">	&#125;</span><br><span class="line">	// 在抽象工厂中注册新菜单类型</span><br><span class="line"></span><br><span class="line">	function registerMenu(type, constructor) &#123;</span><br><span class="line">		constructors[type] = constructor;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		createMenu: createMenu,</span><br><span class="line">		registerMenu: registerMenu</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>还是之前的三个构造函数， 首先将他们注册到抽象工厂中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbstractMenuFactory</span><br><span class="line">	.registerMenu(&quot;vertical&quot;, VerticalMenu)</span><br><span class="line">	.registerMenu(&quot;horizontal&quot;, HorizontalMenu)</span><br><span class="line">	.registerMenu(&quot;animation&quot;, AnimationMenu);</span><br></pre></td></tr></table></figure></p>
<p>使用抽象工厂创建实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">	color: &quot;blue&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var menu1 = AbstractMenuFactory.createMenu(&quot;vertical&quot;, options);</span><br><span class="line">console.log(menu1 instanceof VerticalMenu); // true</span><br><span class="line"></span><br><span class="line">var menu2 = AbstractMenuFactory.createMenu(&quot;horizontal&quot;, options);</span><br><span class="line">console.log(menu2 instanceof HorizontalMenu); // true</span><br><span class="line"></span><br><span class="line">var menu3 = AbstractMenuFactory.createMenu(&quot;animation&quot;, options);</span><br><span class="line">console.log(menu3 instanceof AnimationMenu); // true</span><br></pre></td></tr></table></figure></p>
<p><strong>Command—— 命令模式</strong></p>
<p>Command模式旨在将方法调用、 请求或操作封装到单一对象中， 从而根据不同的请求对客户进行参数化和传递可供执行的方法调用。<br>命令模式在 JavaScript语言中是一种隐形的模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var studentManager = (function() &#123;</span><br><span class="line">	var studentList = [];</span><br><span class="line"></span><br><span class="line">	function add(id, name) &#123;</span><br><span class="line">		studentList.push(&#123;</span><br><span class="line">			id: id,</span><br><span class="line">			name: name</span><br><span class="line">		&#125;);</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function remove(id) &#123;</span><br><span class="line">		var i;</span><br><span class="line">		for (i = studentList.length; i--;) &#123;</span><br><span class="line">			if (studentList[i].id === id) &#123;</span><br><span class="line">				studentList.splice(i, 1);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function get(id) &#123;</span><br><span class="line">		var i;</span><br><span class="line">		for (i = studentList.length; i--;) &#123;</span><br><span class="line">			if (studentList[i].id === id) &#123;</span><br><span class="line">				return studentList[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function count() &#123;</span><br><span class="line">		return studentList.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function getAt(index) &#123;</span><br><span class="line">		return studentList[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &#123;</span><br><span class="line">		add: add,</span><br><span class="line">		remove: remove,</span><br><span class="line">		get: get,</span><br><span class="line">		getAt: getAt,</span><br><span class="line">		count: count,</span><br><span class="line">		execute: function(name) &#123;</span><br><span class="line">			return this[name] &amp;&amp; this[name].apply(this, Array.prototype.slice.call(arguments, 1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>通过在传统的模块模式上增加了个excute方法， 用于实现Command模式， 而修改后的调用就可以变成这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studentManager.execute(&quot;add&quot;, 001, &quot;hzk&quot;);</span><br></pre></td></tr></table></figure></p>
<p>通过单一的方法进行参数化的调用， 拥有更强大的灵活性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var Ryu = &#123;</span><br><span class="line">	attack: function() &#123;</span><br><span class="line">		console.log(&apos;攻击&apos;);</span><br><span class="line">	&#125;,</span><br><span class="line">	defense: function() &#123;</span><br><span class="line">		console.log(&apos;防御&apos;);</span><br><span class="line">	&#125;,</span><br><span class="line">	jump: function() &#123;</span><br><span class="line">		console.log(&apos;跳跃&apos;);</span><br><span class="line">	&#125;,</span><br><span class="line">	crouch: function() &#123;</span><br><span class="line">		console.log(&apos;蹲下&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var commands = &#123;</span><br><span class="line">	&quot;119&quot;: &quot;jump&quot;, // W</span><br><span class="line">	&quot;115&quot;: &quot;crouch&quot;, // S</span><br><span class="line">	&quot;97&quot;: &quot;defense&quot;, // A</span><br><span class="line">	&quot;100&quot;: &quot;attack&quot; // D</span><br><span class="line">&#125;;</span><br><span class="line">var makeCommand = function(receiver, state) &#123;</span><br><span class="line">	// 创建命令</span><br><span class="line">	return function() &#123;</span><br><span class="line">		receiver[state]();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var commandStack = []; // 保存命令的堆栈</span><br><span class="line">document.onkeypress = function(ev) &#123;</span><br><span class="line">	var keyCode = ev.keyCode,</span><br><span class="line">		command = makeCommand(Ryu, commands[keyCode]);</span><br><span class="line">	if (command) &#123;</span><br><span class="line">		command(); // 执行命令</span><br><span class="line">		commandStack.push(command); // 将刚刚执行过的命令保存进堆栈</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">document.getElementById(&apos;replay&apos;).onclick = function() &#123; // 点击播放录像</span><br><span class="line">	var command;</span><br><span class="line">	while (command = commandStack.shift()) &#123; // 从堆栈里依次取出命令并执行</span><br><span class="line">		command();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当在键盘上敲下 W、 A、 S、 D这几个键来完成一些动作之后， 再按下 Replay按钮， 此时便会重复播放之前的动作。</p>
<p><strong> Singleton—— 单例模式 </strong></p>
<p>Singleton限制了类只能有一个实例。 如果实例不存在， 创建一个实例。 如果已经存在， 则返回实例的引用。<br>Singleton与静态类（ 对象） 不同的是， 它可以被延迟生成， 只有在需要的时候才会生成实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var someClass = &#123;</span><br><span class="line">	_singleton: null,</span><br><span class="line">	getSingleton: function() &#123;</span><br><span class="line">		if (!this._singleton) &#123;</span><br><span class="line">			// 如果为空则生成新的实例，并赋给_singleton属性</span><br><span class="line">			this._singleton = &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return this._singleton; // _singleton属性有值就返回这个属性，保证生成的实例都是同一个对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = someClass.getSingleton(); // 生成实例调用getSingleton方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var singleton = (function() &#123;</span><br><span class="line">	var instance;</span><br><span class="line"></span><br><span class="line">	function init() &#123;</span><br><span class="line">		// define private methods and properties</span><br><span class="line">		return &#123;</span><br><span class="line">			// define public methods and properties</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		getInstance: function() &#123;</span><br><span class="line">			if (!instance) &#123;</span><br><span class="line">				instance = init();</span><br><span class="line">			&#125;</span><br><span class="line">			return instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var getSingle = function(fn) &#123;</span><br><span class="line">	var result;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return result || (result = fn.apply(this, arguments));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bindEvent = getSingle(function() &#123;</span><br><span class="line">	document.getElementById(&apos;div1&apos;).onclick = function() &#123;</span><br><span class="line">		alert(&apos;click&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;);</span><br><span class="line">var render = function() &#123;</span><br><span class="line">	console.log(&apos;开始渲染列表&apos;);</span><br><span class="line">	bindEvent();</span><br><span class="line">&#125;;</span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">render();</span><br><span class="line">// render 函数和 bindEvent 函数都分别执行了 3 次， 但 div 实际上只被绑定了一次事件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Universe() &#123;</span><br><span class="line">	// 缓存的实例  </span><br><span class="line">	var instance = this;</span><br><span class="line">	// 重写构造函数 </span><br><span class="line">	Universe = function() &#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 测试</span><br><span class="line">var uni1 = new Universe();</span><br><span class="line">var uni2 = new Universe();</span><br><span class="line">console.log(uni1 === uni2); // true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Universe() &#123;</span><br><span class="line">	var instance;</span><br><span class="line">	Universe = function Universe() &#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;;</span><br><span class="line">	// 后期处理原型属性    </span><br><span class="line">	Universe.prototype = this;</span><br><span class="line">	// 实例    </span><br><span class="line">	instance = new Universe();</span><br><span class="line">	// 重设构造函数指针  </span><br><span class="line">	instance.constructor = Universe;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加原型属性</span><br><span class="line">Universe.prototype.nothing = true;</span><br><span class="line">var uni1 = new Universe();</span><br><span class="line">Universe.prototype.everything = true;</span><br><span class="line">var uni2 = new Universe();</span><br><span class="line">console.log(uni1 === uni2); // true</span><br><span class="line">console.log(uni1.nothing); // true</span><br><span class="line">console.log(uni2.nothing); // true</span><br><span class="line">console.log(uni1.everything); // true</span><br><span class="line">console.log(uni2.everything); // true</span><br><span class="line">console.log(uni1.constructor === Universe); // true</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Universe;</span><br><span class="line">(function() &#123;</span><br><span class="line">	var instance;</span><br><span class="line">	Universe = function Universe() &#123;</span><br><span class="line">		if (instance) &#123;</span><br><span class="line">			return instance;</span><br><span class="line">		&#125;</span><br><span class="line">		instance = this;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;());</span><br><span class="line">var a = new Universe();</span><br><span class="line">var b = new Universe();</span><br><span class="line">alert(a === b); // true</span><br></pre></td></tr></table></figure>
<p><strong> Facade—— 外观模式 </strong></p>
<p>Facade模式是一种结构型模式， 它为更大的代码体提供了一个方便的高层次接口， 能够隐藏其底层的真实复杂性。</p>
<p>在浏览器差异的时候经常会出现， 比如绑定事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function bindEvent(ele, event, callback) &#123;</span><br><span class="line">	if (ele.attachEvent) &#123;</span><br><span class="line">		ele.attachEvent(&quot;on&quot; + event, function(event) &#123;</span><br><span class="line">			event = event || window.event;</span><br><span class="line">			event.target = event.target || event.srcElement;</span><br><span class="line">			callback(event);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ele.addEventListener(event, callback, false);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样暴露给开发者的就是bindEvent方法， 上层开发者只需要去使用这个方法来完成事件绑定， 而不用关注浏览器兼容</p>
<p>Facade模式能够简化类和模块的接口， 也能从这个类或模块从使用它的代码解耦。 而且Facade易于使用， 且占用空间小。<br>Facade可能会影响到性能， 在抽象时需要考虑是否包含隐性成本</p>
<p><strong> 适配器模式 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var renderMap = function(map) &#123;</span><br><span class="line">	if (map.show instanceof Function) &#123;</span><br><span class="line">		map.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap(baiduMap); // 输出：开始渲染百度地图</span><br></pre></td></tr></table></figure></p>
<p>这段程序得以顺利运行的关键是 googleMap 和 baiduMap 提供了一致的 show 方法， 但第三方的接口方法并不在控制范围之内， 假如 baiduMap 提供的显示地图的方法不叫 show 而叫 display 呢？ 此时可以通过增加 baiduMapAdapter 来解决问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var googleMap = &#123;</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		console.log(&apos;开始渲染谷歌地图&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var baiduMap = &#123;</span><br><span class="line">	display: function() &#123;</span><br><span class="line">		console.log(&apos;开始渲染百度地图&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var baiduMapAdapter = &#123;</span><br><span class="line">	show: function() &#123;</span><br><span class="line">		return baiduMap.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">renderMap(googleMap); // 输出：开始渲染谷歌地图</span><br><span class="line">renderMap(baiduMapAdapter); // 输出：开始渲染百度地图</span><br></pre></td></tr></table></figure></p>
<p>假设编写一个渲染广东省地图的页面。 目前从第三方资源里获得了广东省的所有城市以及它们所对应的 ID， 并且成功地渲染到页面中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var getGuangdongCity = function() &#123;</span><br><span class="line">	var guangdongCity = [&#123;</span><br><span class="line">		name: &apos;shenzhen&apos;,</span><br><span class="line">		id: 11,</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		name: &apos;guangzhou&apos;,</span><br><span class="line">		id: 12,</span><br><span class="line">	&#125;];</span><br><span class="line">	return guangdongCity;</span><br><span class="line">&#125;;</span><br><span class="line">var render = function(fn) &#123;</span><br><span class="line">	console.log(&apos;开始渲染广东省地图&apos;);</span><br><span class="line">	document.write(JSON.stringify(fn()));</span><br><span class="line">&#125;;</span><br><span class="line">render(getGuangdongCity);</span><br></pre></td></tr></table></figure></p>
<p>后来发现还缺少很多城市。 于是又在网上找到了另外一些数据资源， 但数据结构和正运行在项目中的不一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var guangdongCity = &#123;</span><br><span class="line">	shenzhen: 11,</span><br><span class="line">	guangzhou: 12,</span><br><span class="line">	zhuhai: 13</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除了改写渲染页面的前端代码之外， 另外一种更轻便的解决方式就是新增一个数据格式转换的适配器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var addressAdapter = function(oldAddressfn) &#123;</span><br><span class="line">	var address = &#123;&#125;,</span><br><span class="line">		oldAddress = oldAddressfn();</span><br><span class="line">	for (var i = 0, c; c = oldAddress[i++];) &#123;</span><br><span class="line">		address[c.name] = c.id;</span><br><span class="line">	&#125;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		return address;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render(addressAdapter(getGuangdongCity));</span><br></pre></td></tr></table></figure></p>
<p>接下来是把代码中调用 getGuangdongCity 的地方， 用经过 addressAdapter适配器转换之后的新函数来代替。</p>
<p><strong>代理模式</strong></p>
<p>虚拟代理： 惰性加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var miniConsole = (function() &#123;</span><br><span class="line">	var cache = [];</span><br><span class="line">	var handler = function(ev) &#123;</span><br><span class="line">		if (ev.keyCode === 113) &#123;</span><br><span class="line">			var script = document.createElement(&apos;script&apos;);</span><br><span class="line">			script.onload = function() &#123;</span><br><span class="line">				for (var i = 0, fn; fn = cache[i++];) &#123;</span><br><span class="line">					fn();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			script.src = &apos;miniConsole.js&apos;;</span><br><span class="line">			document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</span><br><span class="line">			document.body.removeEventListener(&apos;keydown&apos;, handler); // 只加载一次 miniConsole.js</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	document.body.addEventListener(&apos;keydown&apos;, handler, false);</span><br><span class="line">	return &#123;</span><br><span class="line">		log: function() &#123;</span><br><span class="line">			var args = arguments;</span><br><span class="line">			cache.push(function() &#123;</span><br><span class="line">				return miniConsole.log.apply(miniConsole, args);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">miniConsole.log(11); // 开始打印 log</span><br><span class="line">// miniConsole.js 代码</span><br><span class="line">miniConsole = &#123;</span><br><span class="line">	log: function() &#123;</span><br><span class="line">		// 真正代码略</span><br><span class="line">		console.log(Array.prototype.join.call(arguments));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>缓存代理</p>
<p>先创建一个用于求乘积的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var mult = function() &#123;</span><br><span class="line">	var a = 1;</span><br><span class="line">	for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">		a = a * arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;;</span><br><span class="line">mult(2, 3); // 输出：6</span><br><span class="line">mult(2, 3, 4); // 输出：24</span><br></pre></td></tr></table></figure></p>
<p>现在加入缓存代理函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var proxyMult = (function() &#123;</span><br><span class="line">	var cache = &#123;&#125;;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		return cache[args] = mult.apply(this, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">proxyMult(1, 2, 3, 4); // 输出：24</span><br><span class="line">proxyMult(1, 2, 3, 4); // 输出：24</span><br></pre></td></tr></table></figure></p>
<p>当第二次调用 proxyMult(1, 2, 3, 4) 的时候， 本体 mult 函数并没有被计算， proxyMult直接返回了之前缓存好的计算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**************** 计算乘积 *****************/</span><br><span class="line">var mult = function() &#123;</span><br><span class="line">	var a = 1;</span><br><span class="line">	for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">		a = a * arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;;</span><br><span class="line">/**************** 计算加和 *****************/</span><br><span class="line">var plus = function() &#123;</span><br><span class="line">	var a = 0;</span><br><span class="line">	for (var i = 0, l = arguments.length; i &lt; l; i++) &#123;</span><br><span class="line">		a = a + arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return a;</span><br><span class="line">&#125;;</span><br><span class="line">/**************** 创建缓存代理的工厂 *****************/</span><br><span class="line">var createProxyFactory = function(fn) &#123;</span><br><span class="line">	var cache = &#123;&#125;;</span><br><span class="line">	return function() &#123;</span><br><span class="line">		var args = Array.prototype.join.call(arguments, &apos;,&apos;);</span><br><span class="line">		if (args in cache) &#123;</span><br><span class="line">			return cache[args];</span><br><span class="line">		&#125;</span><br><span class="line">		return cache[args] = fn.apply(this, arguments);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var proxyMult = createProxyFactory(mult),</span><br><span class="line">	proxyPlus = createProxyFactory(plus);</span><br><span class="line">alert(proxyMult(1, 2, 3, 4)); // 输出：24</span><br><span class="line">alert(proxyMult(1, 2, 3, 4)); // 输出：24</span><br><span class="line">alert(proxyPlus(1, 2, 3, 4)); // 输出：10</span><br><span class="line">alert(proxyPlus(1, 2, 3, 4)); // 输出：10</span><br></pre></td></tr></table></figure>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
