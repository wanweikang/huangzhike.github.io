<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		
		<title>[笔记]-设计模式-装饰者 | 一个放笔记的地方而已</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="用手记笔记，用心记笔记，用脑记笔记">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-设计模式-装饰者"/>
		
		<meta property="og:site_name" content="一个放笔记的地方而已"/>
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/favicon.ico" sizes="32x32">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">
		<script>var timeStart = new Date();</script>
		<!-- favicon end -->
		<!-- <link href="//favicon.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		
		
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>

<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">一个放笔记的地方而已</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/" title="">
						<i class="fa fa-home"></i>首页
					</a>
				</li>
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>存档
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="我的主页">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-设计模式-装饰者</h2>
				
				<div>
					<span class="post-time">2017-01-27 18:18</span>
				</div>	
				
				<div class="article-content">
				<p>参考：<br>JavaScript设计模式与开发实践 曾探<br>深入理解JavaScript 汤姆大叔<br>其它<br><strong>Decorator—— 装饰者模式</strong></p>
<p>Decorator是一种结构型模式， 旨在促进代码复用， 和Mixin相似， 同样可以被认为是一个可行的对象子类化的替代方案。<br>Decorator提供了将行为动态添加至系统现有类的的能力</p>
<p>模拟传统面向对象语言的装饰者模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Plane = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Plane.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发射普通子弹'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 增加两个装饰类， 分别是导弹和原子弹：</span></div><div class="line"><span class="keyword">var</span> MissileDecorator = <span class="function"><span class="keyword">function</span>(<span class="params">plane</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.plane = plane;</div><div class="line">&#125;</div><div class="line">MissileDecorator.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.plane.fire();</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发射导弹'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> AtomDecorator = <span class="function"><span class="keyword">function</span>(<span class="params">plane</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.plane = plane;</div><div class="line">&#125;</div><div class="line">AtomDecorator.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.plane.fire();</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发射原子弹'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> plane = <span class="keyword">new</span> Plane();</div><div class="line">plane = <span class="keyword">new</span> MissileDecorator(plane);</div><div class="line">plane = <span class="keyword">new</span> AtomDecorator(plane);</div><div class="line">plane.fire();</div><div class="line"><span class="comment">// 分别输出： 发射普通子弹、发射导弹、发射原子弹</span></div></pre></td></tr></table></figure></p>
<p>JavaScript 语言动态改变对象相当容易， 可以直接改写对象或者对象的某个方法， 并不需要“ 类” 来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> plane = &#123;</div><div class="line">	<span class="attr">fire</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'发射普通子弹'</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> missileDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发射导弹'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> atomDecorator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'发射原子弹'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fire1 = plane.fire;</div><div class="line">plane.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	fire1();</div><div class="line">	missileDecorator();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fire2 = plane.fire;</div><div class="line">plane.fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	fire2();</div><div class="line">	atomDecorator();</div><div class="line">&#125;</div><div class="line">plane.fire();</div><div class="line"><span class="comment">// 分别输出： 发射普通子弹、发射导弹、发射原子弹</span></div></pre></td></tr></table></figure></p>
<p>现在需要一个办法， 在不改变函数源代码的情况下， 能给函数增加功能， 这正是开放封闭原则。<br>通过保存原引用的方式就可以改写某个函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> _a = a;</div><div class="line">a = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	_a();</div><div class="line">	alert(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是实际开发中很常见的一种做法， 比如想给 window 绑定 onload 事件， 但是又不确定这个事件是不是已经被绑定过， 为了避免覆盖掉之前的 window.onload 函数，一般都会先保存好原先的 window.onload， 把它放入新的 window.onload 里执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> _onload = <span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	_onload();</div><div class="line">	alert(<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样当然是符合开放封闭原则的， 在增加新功能的时候， 确实没有修改原来的 window.onload 代码， 但存在以下两个问题。<br>必须维护 _onload 这个中间变量， 如果函数的装饰链较长， 或者需要装饰的函数变多， 这些中间变量的数量也会越来越多。<br>其实还遇到了 this 被劫持的问题， 在 window.onload 的例子中没有这个烦恼， 是因为调用普通函数 _onload 时， this 也指向 window， 跟调用 window.onload 时一样（ 函数作为对象的方法被调用时， this 指向该对象， 所以此处 this 也只指向 window）。<br>现在把 window.onload 换成 document.getElementById， 代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _getElementById = <span class="built_in">document</span>.getElementById;</div><div class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">	<span class="keyword">return</span> _getElementById(id); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行这段代码， 在弹出 alert(1) 之后， 紧接着控制台抛出了异常：Uncaught TypeError: Illegal invocation<br>异常发生在(1) 处的 _getElementById(id) 这句代码上， 此时 _getElementById 是一个全局函数，当调用一个全局函数时， this 是指向 window 的， 而 document.getElementById 方法的内部实现需要使用 this 引用， this 在这个方法内预期是指向 document， 而不是 window。</p>
<p>改进后的代码可以满足需求， 要手动把 document 当作上下文 this 传入 _getElementById：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _getElementById = <span class="built_in">document</span>.getElementById;</div><div class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">	<span class="keyword">return</span> _getElementById.apply(<span class="built_in">document</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用 AOP 装饰函数<br>首先给出 Function.prototype.before 方法和 Function.prototype.after 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> __self = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 返回包含了原函数和新函数的"代理"函数</span></div><div class="line">		beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行新函数，且保证 this 不被劫持，新函数接受的参数</span></div><div class="line">		<span class="comment">// 也会被原封不动地传入原函数，新函数在原函数之前执行</span></div><div class="line">		<span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 执行原函数并返回原函数的执行结果，并且保证 this 不被劫持</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> ret = __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">		afterfn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Function.prototype.before 接受一个函数当作参数， 这个函数即为新添加的函数， 它装载了新添加的功能代码。<br>接下来把当前的 this 保存起来， 这个 this 指向原函数， 然后返回一个“ 代理” 函数， 这个“ 代理” 函数只是结构上像代理而已， 并不承担代理的职责（ 比如控制对象的访问等）。<br>它的工作是把请求分别转发给新添加的函数和原函数， 且负责保证它们的执行顺序， 让新添加的函数在原函数之前执行（ 前置装饰）， 这样就实现了动态装饰的效果。<br>通过 Function.prototype.apply 来动态传入正确的 this， 保证了函数在被装饰之后， this 不会被劫持。<br>Function.prototype.after 的原理跟 Function.prototype.before 一模一样， 唯一不同的地方在于让新添加的函数在原函数执行之后再执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById = <span class="built_in">document</span>.getElementById.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'button'</span>);</div><div class="line"><span class="built_in">console</span>.log(button);</div></pre></td></tr></table></figure>
<p>再回到 window.onload 的例子， 看看用 Function.prototype.before 来增加新的 window.onload 事件是多么简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">2</span>);</div><div class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">3</span>);</div><div class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="number">4</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>许多人不喜欢这种污染原型的方式， 那么可以把原函数和新函数都作为参数传入 before 或者 after 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> before = <span class="function"><span class="keyword">function</span>(<span class="params">fn, beforefn</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">		<span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = before(</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">3</span>) &#125;,</div><div class="line">	<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">2</span>) &#125;</div><div class="line">);</div><div class="line">a = before(a, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="number">1</span>); &#125;);</div><div class="line">a();</div></pre></td></tr></table></figure></p>
<p>AOP 的应用实例<br>比如页面中有一个登录 button， 点击这个 button会弹出登录浮层， 同时要进行数据上报，统计有多少用户点击了这个登录 button：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</div><div class="line">	log(<span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">tag</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + tag);</div><div class="line">	(<span class="keyword">new</span> Image).src = <span class="string">'http:// xxx.com/report?tag='</span> + tag; <span class="comment">// 真正的上报代码略 </span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</div></pre></td></tr></table></figure></p>
<p>在 showLogin 函数里， 既要负责打开登录浮层， 又要负责数据上报， 这是两个层面的功能， 在此处却被耦合在一个函数里。<br>使用 AOP分离之后， 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'打开登录浮层'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute(<span class="string">'tag'</span>));</div><div class="line">&#125;</div><div class="line">showLogin = showLogin.after(log); <span class="comment">// 打开登录浮层之后上报数据</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).onclick = showLogin;</div></pre></td></tr></table></figure></p>
<p>用AOP动态改变函数的参数</p>
<p>观察 Function.prototype.before 方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> _self = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// (1)</span></div><div class="line">		<span class="keyword">return</span> _self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// (2)</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这段代码的(1) 处和(2) 处可以看到， beforefn 和原函数 _self 共用一组参数列表arguments， 在 beforefn 的函数体内改变 arguments 的时候， 原函数 _self 接收的参数列表自然也会变化。</p>
<p>下例展示了如何通过 Function.prototype.before 方法给函数 func 的参数 param 动态地添加属性 b：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">(param)</span> &#123;</span></div><div class="line">	console.<span class="built_in">log</span>(param)<span class="comment">; // 输出： &#123;a: "a", b: "b"&#125;</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> = <span class="title">func</span>.<span class="title">before</span><span class="params">(function(param)</span> &#123;</span></div><div class="line">	param.b = <span class="string">'b'</span><span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line"><span class="function"><span class="keyword">func</span><span class="params">(&#123; a: <span class="string">'a'</span> &#125;)</span>;</span></div></pre></td></tr></table></figure></p>
<p>现在有一个用于发起 ajax请求的函数， 这个函数负责项目中所有的 ajax异步请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type, url, param</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.dir(param);</div><div class="line">	<span class="comment">// 发送 ajax 请求的代码略</span></div><div class="line">&#125;;</div><div class="line">ajax(<span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; <span class="attr">name</span>: <span class="string">'sven'</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>上面的伪代码表示向后台 cgi 发起一个请求来获取用户信息， 传递给 cgi 的参数是 <code>{name: &#39;sven&#39;}</code>。<br>ajax 函数在项目中一直运转良好， 跟 cgi 的合作也很愉快。 有一天， 我们的网站遭受了CSRF攻击。<br>解决 CSRF攻击最简单的办法就是在 HTTP请求中带上一个 Token 参数。<br>假设已经有一个生成 Token 的函数：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'Token'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在的任务是给每个 ajax请求都加上 Token 参数：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span><span class="params">(<span class="keyword">type</span>, url, param)</span> <span class="comment">&#123;</span></span></div><div class="line">	param = param || &#123;&#125;;</div><div class="line">	Param.Token = getToken(); <span class="comment">// 发送 ajax 请求的代码略...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然解决了问题， 但 ajax 函数相对变得僵硬了， 每个从 ajax 函数里发出的请求都自动带上了 Token 参数， 如果将来把这个函数移植到其他项目上， 或者把它放到一个开源库中供其他人使用， Token 参数都将是多余的。为了解决这个问题， 先把 ajax 函数还原成一个干净的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span>(<span class="params">type, url, param</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(param); <span class="comment">// 发送 ajax 请求的代码略</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后把 Token 参数通过 Function.prototyte.before 装饰到 ajax 函数的参数 param 对象中：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getToken = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">'Token'</span>;</div><div class="line">&#125;</div><div class="line">ajax = ajax.before(<span class="function"><span class="keyword">function</span><span class="params">(type, url, param)</span> </span>&#123;</div><div class="line">	param.Token = getToken();</div><div class="line">&#125;);</div><div class="line">ajax(<span class="string">'get'</span>, <span class="string">'http:// xxx.com/userinfo'</span>, &#123; name: <span class="string">'sven'</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>插件式的表单验证<br>在一个 Web 项目中， 可能存在非常多的表单， 如注册、 登录、 修改用户信息等。 在表单数据提交给后台之前， 常常要做一些校验， 如登录的时候需要验证用户名和密码是否为空， 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">'username'</span>),</div><div class="line">	password = <span class="built_in">document</span>.getElementById(<span class="string">'password'</span>),</div><div class="line">	submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">'submitBtn'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</div><div class="line">		<span class="keyword">return</span> alert(<span class="string">'用户名不能为空'</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</div><div class="line">		<span class="keyword">return</span> alert(<span class="string">'密码不能为空'</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> param = &#123;</div><div class="line">		<span class="attr">username</span>: username.value,</div><div class="line">		<span class="attr">password</span>: password.value</div><div class="line">	&#125;</div><div class="line">	ajax(<span class="string">'http:// xxx.com/login'</span>, param); <span class="comment">// ajax 具体实现略</span></div><div class="line">&#125;</div><div class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	formSubmit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>formSubmit 函数在此处承担了两个职责， 除了提交 ajax请求之外， 还要验证用户输入的合法性。<br>这种代码一来会造成函数臃肿， 职责混乱， 二来谈不上任何可复用性。<br>目的是分离校验输入和提交 ajax 请求的代码， 把校验输入的逻辑放到 validata函数中， 并且约定当 validata 函数返回 false 的时候， 表示校验未通过：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</div><div class="line">		alert(<span class="string">'用户名不能为空'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</div><div class="line">		alert(<span class="string">'密码不能为空'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (validata() === <span class="literal">false</span>) &#123; <span class="comment">// 校验未通过</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> param = &#123;</div><div class="line">		username: username.value,</div><div class="line">		password: password.value</div><div class="line">	&#125;</div><div class="line">	ajax(<span class="string">'http:// xxx.com/login'</span>, param);</div><div class="line">&#125;</div><div class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	formSubmit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在的代码已经有了一些改进， 校验的逻辑都放到了 validata 函数中， 但 formSubmit函数的内部还要计算 validata 函数的返回值， 返回值的结果表明了是否通过校验。<br>进一步优化这段代码， 使 validata 和 formSubmit 完全分离开来。<br>首先要改写 Function.prototype.before， 如果 beforefn 的执行结果返回 false， 表示不再执行后面的原函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">beforefn</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> __self = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">if</span> (beforefn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) === <span class="literal">false</span>) &#123;</div><div class="line">			<span class="comment">// beforefn 返回 false 的情况直接 return，不再执行后面的原函数</span></div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> __self.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> validata = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (username.value === <span class="string">''</span>) &#123;</div><div class="line">		alert(<span class="string">'用户名不能为空'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (password.value === <span class="string">''</span>) &#123;</div><div class="line">		alert(<span class="string">'密码不能为空'</span>);</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> formSubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> param = &#123;</div><div class="line">		<span class="attr">username</span>: username.value,</div><div class="line">		<span class="attr">password</span>: password.value</div><div class="line">	&#125;</div><div class="line">	ajax(<span class="string">'http:// xxx.com/login'</span>, param);</div><div class="line">&#125;</div><div class="line">formSubmit = formSubmit.before(validata);</div><div class="line">submitBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	formSubmit();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中， 校验输入和提交表单的代码完全分离开来， 它们不再有任何耦合关系，<code>formSubmit = formSubmit.before(validata)</code> 这句代码， 如同把校验规则动态接在 formSubmit 函数之前， validata 成为一个即插即用的函数， 它甚至可以被写成配置文件的形式， 这有利于分开维护这两个函数。<br>再利用策略模式稍加改造， 就可以把这些校验规则都写成插件的形式，用在不同的项目当中。<br>值得注意的是， 因为函数通过 Function.prototype.before 或 Function.prototype.after 被装饰之后， 返回的是一个新的函数， 如果在原函数上保存了一些属性， 这些属性会丢失。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var <span class="function"><span class="keyword">func</span> = <span class="title">function</span><span class="params">()</span> &#123;</span></div><div class="line">	alert(<span class="number">1</span>)<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span>.<span class="title">a</span> = '<span class="title">a</span>';</span></div><div class="line"><span class="function"><span class="keyword">func</span> = <span class="title">func</span>.<span class="title">after</span><span class="params">(function()</span> &#123;</span></div><div class="line">	alert(<span class="number">2</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line">alert(<span class="function"><span class="keyword">func</span>.<span class="title">a</span>); // 输出：<span class="title">undefined</span></span></div></pre></td></tr></table></figure></p>
<p>另外， 这种装饰方式也叠加了函数的作用域， 如果装饰的链条过长， 性能上也会受到一些影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义学生类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">this</span>.getCost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">5500</span>; <span class="comment">// 学费5500，必交</span></div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义装饰器，需要宿舍，宿舍费550/年</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NeedDormitory</span>(<span class="params">student</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cost = student.getCost();</div><div class="line">	student.getCost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> cost + <span class="number">550</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 定义装饰器，需要书本，书本费400/年</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NeedBooks</span>(<span class="params">student</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cost = student.getCost();</div><div class="line">	student.getCost = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> cost + <span class="number">400</span>;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建学生对象</span></div><div class="line"><span class="keyword">var</span> hzk = <span class="keyword">new</span> Student(<span class="string">"hzk"</span>);</div><div class="line">NeedDormitory(hzk);</div><div class="line">NeedBooks(hzk);</div><div class="line"><span class="built_in">console</span>.log(hzk.getName() + <span class="string">" 每年需要："</span> + hzk.getCost());</div></pre></td></tr></table></figure>
<p>实现接口，接口的目的就是保证对象拥有特定的方法。 </p>
<p>首先需要一个接口类， 用于存放接口的名字和使用这个接口的对象必须实现的方法名称：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义接口类</span></div><div class="line"><span class="keyword">var</span> Interface = <span class="function"><span class="keyword">function</span>(<span class="params">name, methods</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.methods = [];</div><div class="line">	<span class="keyword">for</span> (i = methods.length; i--;) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> methods[i] !== <span class="string">'string'</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"接口定义错误：接口的方法名称必须是字符串"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.methods.push(methods[i]);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>静态方法， 用来确定某个对象是否实现了其参数内接口的所有方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个参数为检测对象，后面的参数为接口对象</span></div><div class="line">Interface.checkImplements = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> interfaces = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">	<span class="keyword">var</span> methods;</div><div class="line">	<span class="keyword">var</span> methodName;</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">var</span> j;</div><div class="line">	<span class="keyword">for</span> (i = interfaces.length; i--;) &#123;</div><div class="line">		<span class="keyword">if</span> (interfaces[i].constructor !== Interface) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"接口定义错误：必须传递Interface类定义的接口"</span>);</div><div class="line">		&#125;</div><div class="line">		methods = interfaces[i].methods;</div><div class="line">		<span class="keyword">for</span> (j = methods.length; j--;) &#123;</div><div class="line">			methodName = methods[j];</div><div class="line">			<span class="keyword">if</span> (!object[methodName] || <span class="keyword">typeof</span> object[methodName] !== <span class="string">'function'</span>) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"接口定义错误：未实现 "</span> + interfaces[i].name + <span class="string">" 接口的 "</span> + methodName + <span class="string">"方法"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义一个Student接口， 这个接口需要两个方法， getName和getCost：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Student = <span class="keyword">new</span> <span class="type">Interface</span>(<span class="string">"Student"</span>, [<span class="string">"getName"</span>, <span class="string">"getCost"</span>]);</div></pre></td></tr></table></figure></p>
<p>Student接口的实现，StudentImpl：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span></span> StudentImpl(<span class="keyword">name</span>) &#123;</div><div class="line">	<span class="keyword">Interface</span>.checkImplements(this, Student);</div><div class="line">	this.<span class="keyword">name</span> = <span class="keyword">name</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">StudentImpl.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> this.<span class="keyword">name</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里只定义了getName方法， 缺少了getCost方法， 在创建实例的时候将会报错：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> StudentImpl(<span class="string">"hzk"</span>));</div><div class="line"><span class="comment">// Uncaught Error: 接口定义错误：未实现 Student 接口的 getCost方法</span></div></pre></td></tr></table></figure></p>
<p>补上getCost方法：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">StudentImpl.prototype.getCost = <span class="function"><span class="keyword">function</span>(</span>) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">5500</span>;</div><div class="line">&#125;;</div><div class="line">console.<span class="built_in">log</span>(<span class="keyword">new</span> StudentImpl(<span class="string">"hzk"</span>));</div><div class="line">// StudentImpl &#123;name: <span class="string">"hzk"</span>, getName: <span class="function"><span class="keyword">function</span>, <span class="title">getCost</span>:</span> <span class="function"><span class="keyword">function</span>&#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>Abstract Decorator—— 抽象装饰者</strong></p>
<p>可以为将每个装饰者实现成一个装饰者类</p>
<p>定义原始类</p>
<p>首先定义一个接口， 里面包含了必须实现的方法：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> StudentInterface = <span class="keyword">new</span> <span class="type">Interface</span>(<span class="string">"StudentInterface"</span>, [<span class="string">"getCost"</span>, <span class="string">"getName"</span>]);</div></pre></td></tr></table></figure></p>
<p>然后根据这个接口， 定义一个需要装饰的原始类：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span><span class="params">(name)</span> </span>&#123;</div><div class="line">	Interface.checkImplements(<span class="keyword">this</span>, StudentInterface);</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Student.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Student.prototype.getCost = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">5500</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义一个装饰器基类， 所有的装饰器都继承这个装饰器基类， 它也需要实现这些上面的接口， 但由于不需要做修改， 这些接口直接调用原始类的方法就好：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> StudentDecorator = <span class="function"><span class="keyword">function</span><span class="params">(student)</span> </span>&#123;</div><div class="line">	Interface.checkImplements(student, StudentInterface);</div><div class="line">	<span class="keyword">this</span>.student = student;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">StudentDecorator.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.student.getName();</div><div class="line">&#125;;</div><div class="line"></div><div class="line">StudentDecorator.prototype.getCost = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.student.getCost();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义继承装饰器基类的装饰器， 比如定义一个学生需要宿舍， 那么装饰器应该这么定义：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 宿舍装饰器</span></div><div class="line"><span class="keyword">var</span> DormitoryDecorator = <span class="function"><span class="keyword">function</span><span class="params">(student)</span> </span>&#123;</div><div class="line">	StudentDecorator.call(<span class="keyword">this</span>, student);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extend(DormitoryDecorator.prototype, StudentDecorator.prototype);</div><div class="line"></div><div class="line">DormitoryDecorator.prototype.getCost = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.student.getCost() + <span class="number">550</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过extend和调用装饰器基类的构造函数来将基类的属性和方法复制给装饰器类， 同理构建两个新的装饰器， 书本装饰器和把妹装饰器：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 书本装饰器</span></div><div class="line"><span class="keyword">var</span> BooksDecorator = <span class="function"><span class="keyword">function</span><span class="params">(student)</span> </span>&#123;</div><div class="line">	StudentDecorator.call(<span class="keyword">this</span>, student);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extend(BooksDecorator.prototype, StudentDecorator.prototype);</div><div class="line"></div><div class="line">BooksDecorator.prototype.getCost = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.student.getCost() + <span class="number">400</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 把妹装饰器</span></div><div class="line"><span class="keyword">var</span> GirlfriendDecorator = <span class="function"><span class="keyword">function</span><span class="params">(student)</span> </span>&#123;</div><div class="line">	StudentDecorator.call(<span class="keyword">this</span>, student);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extend(GirlfriendDecorator.prototype, StudentDecorator.prototype);</div><div class="line"></div><div class="line">GirlfriendDecorator.prototype.getCost = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.student.getCost() + <span class="number">99999</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"hzk"</span>);</div><div class="line">console.log(student.getCost());</div><div class="line">student = <span class="keyword">new</span> <span class="type">DormitoryDecorator</span>(student);</div><div class="line">console.log(student.getCost());</div><div class="line">student = <span class="keyword">new</span> <span class="type">GirlfriendDecorator</span>(student);</div><div class="line">console.log(student.getCost());</div><div class="line">student = <span class="keyword">new</span> <span class="type">BooksDecorator</span>(student);</div><div class="line">console.log(student.getCost());</div><div class="line"><span class="comment">// hzk需要5500, 6050， 16049, 16449</span></div></pre></td></tr></table></figure>
<p>抽象装饰者模式可以动态的修改对象， 因此更加完美， 但内存消耗也要大得多</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			
<p>Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/wayou/hexo-theme-material">Material</a> theme modified by <b> Huangzhike </b></p>
<p>&copy; 2017 <a href="https://huangzhike.github.io"><b> Huangzhike </b></a></p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
	<script src="/js/highlight.js"></script> 
	<script>hljs.initHighlightingOnLoad();var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
