<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-MySQL-优化 | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-MySQL-优化">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-MySQL-优化</h2>
				
				<div>
					<div class="post-time">2020-05-27</div>
				</div>
				
				<div class="article-content">
				<p>合理设计表</p>
<ul>
<li><p>第一范式：表的列的具有原子性，最小的的单元，即列的信息，不能分解。</p>
</li>
<li><p>第二范式：表中的记录是唯一的，通常使用主键来实现。</p>
</li>
<li><p>第三范式：表中不要有冗余数据，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放。</p>
</li>
<li><p>反第三范式：有时为了提高查询效率，可以适当允许部分字段冗余。</p>
</li>
</ul>
<p>范式（写方便，没有冗余，节省空间，但读时关联表较多）和反范式（适当加冗余，避免JOIN关联）。</p>
<hr>
<p>字段选择：</p>
<ul>
<li><p>尽量越小越好，如字符串长度。</p>
</li>
<li><p>尽量简单，如整型比字符串代价更低。</p>
</li>
<li><p>尽量不要允许<code>NULL</code>，除非必要，可以用<code>NOT NULL</code> + <code>DEFAULT</code>代替。</p>
</li>
<li><p>尽量使用<code>TIMESTAMP</code>而非<code>DATETIME</code>，对于只需要精确到某一天的数据类型，建议使用<code>DATE</code>类型。</p>
<ul>
<li><code>DATETIME</code>和<code>TIMESTAMP</code>都可以存储时间和日期，精确到秒，但是<code>TIMESTAMP</code>占4个字节，<code>DATETIME</code>占8个字，<code>TIMESTAMP</code>以UTC格式保存，自动转化时区，<code>DATETIME</code>时间范围更广。</li>
</ul>
</li>
<li><p>少用<code>TEXT</code>和<code>BLOB</code>，都是为存储大字符串设计，分别采用二进制和字符（包含字符集）存储。</p>
</li>
<li><p>如果只存储正整数，可以选用<code>UNSIGNED</code>属性，无符号位可以提升一倍的上限。</p>
</li>
<li><p>不要使用浮点数<code>DOUBLE</code>，会存在精确性的问题，对货币等对精度敏感的数据，应该用定点数表示或存储。</p>
</li>
<li><p>因为需要额外的开销，所以尽量只在需要对小数进行精确计算时才使用<code>DECIMAL</code>，在数据量较大时，可以考虑使用<code>BIGINT</code>替代，根据小数的位数乘以对应倍数即可。</p>
</li>
<li><p>对于状态字段，可以尝试使用<code>ENUM</code>来存放，可以极大的降低存储空间，而且即使需要增加新的类型，只要增加于末尾，修改结构也不需要重建表数据。</p>
</li>
</ul>
<hr>
<p>有时候将一个复杂语句分解为多个简单语句会比较好，比如删除大量行时，如果一次性完成，可能一次性锁住很多数据，但是如果分批删除的话情况会好很多。</p>
<p>有时候将多表的JOIN关联查询改为多个单表查询，根据结果在应用层关联也是一个方法。</p>
<p>优点：</p>
<p>方便应用层做缓存。</p>
<p>如果第一步查询结果已经被缓存了，再次查询则可跳过此步骤，直接进行第二步查询，不必再重复查询第一步。</p>
<p>相当于在应用层实现了哈希关联，不再使用MySQL的嵌套循环关联，效率高很多。</p>
<p>方便数据库扩展。</p>
<hr>
<p>当分页的偏移OFFSET很大时，会出现效率问题：<code>SELECT * FROM test WHERE ... LIMIT 300000, 5;</code>。</p>
<p>查询到索引叶子节点数据，根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值。</p>
<p>需要查询300005次索引节点和聚簇索引的数据，最后过滤掉前300000条，取出最后5条，耗费了大量随机I/O时间。</p>
<p>问：为什么不先根据索引叶子节点查到最后需要的5个节点，再去聚簇索引中查询，只需要5次随机I/O？</p>
<p>改写成如下语句，走覆盖索引：</p>
<p><code>SELECT * FROM test a INNER JOIN (SELECT id from test WHERE ... LIMIT 300000, 5) b ON a.id = b.id;</code></p>
<p>延迟关联，通过覆盖索引获取主键，再通过主键进行查询。</p>
<p>还有一种就是使用主键进行查询：<code>SELECT ... WHERE primary_key &gt; xxx ORDER BY ... LIMIT ...;</code>。</p>
<p>前提是能使用唯一索引，而且单调递增，并且不支持跨页查询，只能按顺序逐页查询。</p>
<hr>
<p>如果明确知道只有一条结果返回，使用<code>LIMIT 1</code>提高效率。</p>
<p><code>SELECT ... FROM ... WHERE name = &#39;xxx&#39;;</code>可以优化为<code>SELECT ... FROM ... WHERE name = &#39;xxx&#39; LIMIT 1;</code>。</p>
<p>这样数据库遇到匹配的一行后，就可以直接停止匹配不再继续。</p>
<hr>
<p>避免使用OR。</p>
<p><code>SELECT ... FROM ... WHERE xxx = 10 OR xxx = 20;</code>。</p>
<p>可以改为：<code>SELECT ... FROM ... WHERE xxx = 10 UNION ALL SELECT ... FROM ... WHERE xxx = 20;</code>。</p>
<p>或者：<code>SELECT ... FROM ... WHERE xxx IN(10, 20);</code>。</p>
<p>IN需要避免列表过大，否则可能不使用索引，对于连续的数值，考虑用BETWEEN替代。</p>
<hr>
<p>尽量只返回需要的列。</p>
<p><code>SELECT * FROM table_a INNER JOIN table_b ON ... INNER JOIN table_c ON ...;</code>这句话会返回三个表的全部数据列。</p>
<hr>
<p>把计算放到业务层而不是数据库层，除了节省数据的CPU，还有可以利用查询缓存（传入的SQL相同）。</p>
<p>如果查询中有不确定数据，如<code>CURRENT_DATE()</code>和<code>NOW()</code>函数，查询完毕后则不会被缓存。</p>
<hr>
<p>大型数据不要写子查询，使用连接（JOIN）去替换。</p>
<hr>
<p>根据应用情况可以使用<code>REPLACE</code>语句代替<code>INSERT/DELETE</code>语句。</p>
<p>例如：如果一个表在一个字段上建立了唯一索引，当向这个表中使用已经存在的键值插入一条记录，将会抛出一个主键冲突的错误。</p>
<p>如果想用新记录的值来覆盖原来的记录值时，就可以使用<code>REPLAC</code>语句。</p>
<p>如果记录不重复（或往表里插新记录），<code>REPLACE</code>功能与<code>INSERT</code>一样，如果存在重复记录，<code>REPLACE</code>就使用新记录的值来替换原来的记录值。</p>
<p><code>REPLACE</code>的最大好处就是可以将<code>DELETE</code>和<code>INSERT</code>合二为一，形成一个原子操作。</p>
<p>这样就可以不必考虑同时使用<code>DELETE</code>和<code>INSERT</code>时添加事务等复杂操作了。</p>
<p>使用<code>REPLACE</code>时，表中必须有唯一有一个<code>PRIMARY KEY</code>或<code>UNIQUE</code>索引，否则<code>REPLACE</code>语句没有意义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 与普通INSERT一样功能</span></span><br><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> score (change_type, score, user_id) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="string">'喝茶'</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找到第一条记录，用后面的值进行替换</span></span><br><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> score (<span class="keyword">id</span>, change_type, score, user_id) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'吃饭'</span>, <span class="number">10</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用法一：不修改数据，而只是单纯做局部替换数据返还</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">REPLACE</span>(<span class="string">'喝茶'</span>, <span class="string">'茶'</span>, <span class="string">'喝'</span>);</span><br><span class="line"><span class="comment">-- 结果：喝喝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用法二：修改表数据，根据change_type字段找到做任务的数据，用bb来替换</span></span><br><span class="line"><span class="keyword">UPDATE</span> score <span class="keyword">SET</span> change_type = <span class="keyword">REPLACE</span>(change_type, <span class="string">'做任务'</span>, <span class="string">'bb'</span>)</span><br></pre></td></tr></table></figure>
<p><code>UPDATE</code>和<code>REPLACE</code>的区别：</p>
<ul>
<li><p><code>UPDATE</code>在没有匹配记录时什么都不做，而<code>REPLACE</code>在有重复记录时更新，在没有重复记录时插入。</p>
</li>
<li><p><code>UPDATE</code>可以选择性地更新记录的一部分字段，而<code>REPLACE</code>在发现有重复记录时就将这条记录彻底删除，再插入新的记录。</p>
</li>
</ul>
<hr>
<p>最左匹配原则：</p>
<p>对于联合索引<code>(a, b, c, d)</code>，由多个列组成，索引只能用于查找列是否存在（相等），遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>LIKE &#39;%xxx&#39;</code>)等就停止匹配。</p>
<p>如查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在依次命中<code>a</code>、<code>b</code>、<code>c</code>，无法命中<code>d</code>。</p>
<p>另外，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中<code>a</code>、<code>b</code>、<code>c</code>。</p>
<p>另外，如果有一个索引<code>(a, b)</code>，但是查询条件只指定了<code>b</code>，那么无法跳过<code>a</code>使用索引，只能全表扫描。</p>
<p>但是实际上根据索引树的结构，应该是可以按索引的顺序，遍历并忽视<code>a</code>列，使用<code>b</code>列进行筛选的，只是MySQL并不支持。</p>
<p>对于范围查询<code>a &gt; 1 and b = 2</code>，需要查找所有符合条件<code>a &gt; 1</code>的下级节点指针，可能需要遍历非常多的节点及其子节点。</p>
<p>这种情况下，MySQL会选择直接遍历所有满足条件<code>a &gt; 1</code>的记录，而不再使用索引上剩下的<code>b</code>字段。</p>
<hr>
<p>前缀索引：取某列的前一部分作为索引，一般是字符串类型，因为如果很长的话，全部作为索引会增加维护代价。</p>
<p>前缀索引可以使索引更小，但是无法使用前缀索引做ORDER BY和GROUP BY，也不能做覆盖扫描。</p>
<hr>
<p>哪些情况需要创建索引：</p>
<ul>
<li><p>主键自动建立唯一索引。</p>
</li>
<li><p>频繁作为查询的条件的字段，如：<code>WHERE</code>的条件、<code>JOIN</code> … <code>ON</code>的条件、<code>ORDER BY</code>或<code>GROUP BY</code>的条件。</p>
</li>
</ul>
<p>哪些情况不要创建索引：</p>
<p>包含许多重复的内容，且分布平均的字段，即区分度不大的字段，不能过滤掉大量的数据，无法进行快速查找。</p>
<p>尽量选择区分度高的列作为索引，区分度的公式是<code>COUNT(DISTINCT col)/COUNT(*)</code>，表示字段不重复的比例，唯一索引是1。</p>
<p><code>SHOW INDEX FROM table_name;</code>查看表的索引。</p>
<p>其中，Cardinality列的值体现了索引列的唯一度，应该尽可能接近1，性能最好，如果非常小，考虑删除这个索引。</p>
<p>如果要更新Cardinality列的信息，可以执行<code>ANALYZE TABLE table_name;</code>命令。</p>
<p>索引列区分度要高，即重复值少，除了平均的选择性，还要注意数据分布是否均匀。</p>
<p>一般来说，建立索引时，考虑优先把选择性高的索引放在前面。</p>
<p>更新频繁的字段不宜建索引，会导致B+树的频繁的变更，重建索引。</p>
<hr>
<p>索引列应该尽量小，一个磁盘块可以放更多的索引，减少磁盘IO。</p>
<p>索引不是越多越好，维护索引需要代价，因此只在需要的列上创建索引，尽可能扩展索引，而不是创建新的索引。</p>
<p>如，<code>(a, b)</code>可以当<code>(a)</code>来使用。</p>
<p>另外假如主键为id，那么<code>(a, id)</code>是冗余的，因为主键列已经包含在二级索引中了。</p>
<p>另外如<code>WHERE a = 5 ORDER BY id;</code>这样的查询，如果将索引扩展为<code>(a, b)</code>，那么实际上就是<code>(a, b, id)</code>，不能使用索引排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx (</span><br><span class="line">      <span class="keyword">id</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">      UINQUE(<span class="keyword">id</span>),</span><br><span class="line">      <span class="keyword">INDEX</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>这句SQL其实创建了三个重复的索引，因为唯一限制和主键限制都是通过索引实现的。</p>
<hr>
<p>三星索引：WHERE … ORDER BY … 涉及的列，以及SELECT涉及的列，使用覆盖索引。</p>
<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有的列的排列方向（正序或倒序）都一致时，才能使用索引进行排序。</p>
<p>如果关联多张表，只有当ORDER BY子句涉及的列都在第一张表时，才能使用索引排序（最左匹配原则）。</p>
<p>假设有索引<code>(a, b, c)</code>，可以使用索引排序：<code>SELECT ... WHERE a &gt; &#39;xx&#39; ORDER BY a, b;</code>。</p>
<p>特例：<code>SELECT ... WHERE a = &#39;xx&#39; ORDER BY b, c;</code>这里ORDER BY不满足最左匹配原则，但是可以使用索引排序，因为索引的第一列被指定为一个常数。</p>
<p>顺序不一致不能：<code>SELECT ... WHERE a = &#39;xx&#39; ORDER BY b DESC, c ASC;</code>，要么都是ASC排序，要么都是DESC排序。</p>
<p>不在索引的列不能：<code>SELECT ... WHERE a = &#39;xx&#39; ORDER BY b, d;</code></p>
<p>不符合最左匹配不能：<code>SELECT ... WHERE a = &#39;xx&#39; ORDER BY c;</code></p>
<p>范围查询不能：<code>SELECT ... WHERE a &gt; &#39;xx&#39; ORDER BY b, c;</code></p>
<p>范围查询不能：<code>SELECT ... WHERE a = &#39;xx&#39; AND b IN(&#39;xx&#39;, &#39;xx&#39;) ORDER BY c;</code></p>
<p>另外，如果排序的多个列不是来自一个索引里，也不能使用索引进行排序。</p>
<p>如果WHERE子句中出现了非排序使用到的索引列，也不能使用索引进行排序。</p>
<hr>
<p>如果有很多<code>JOIN</code>查询，应该确认两个表中<code>JOIN</code>的字段是被建过索引的。</p>
<p>用来<code>JOIN</code>的字段，应该是相同的类型的：如果把<code>DECIMAL</code>字段和一个<code>INT</code>字段<code>Join</code>在一起，就无法使用索引。</p>
<p>对于<code>STRING</code>类型，还需要有相同的字符集。</p>
<p>隐式类型转换：</p>
<p><code>SELECT * from ... WHERE xxx = 110717;</code>：</p>
<p>假设xxx这个字段上有索引，但执行计划却显示这条语句走全表扫描。</p>
<p>可能的原因是，xxx的字段类型是varchar，而输入的参数却是整型，所以需要做类型转换。</p>
<p>相当于：<code>SELECT * from ... WHERE CAST(xxx AS signed int) = 110717;</code>，不能使用索引。</p>
<p>隐式字符编码转换：</p>
<p><code>SELECT b.* FROM a, b WHERE a.xxx = b.xxx AND a.id = 1;</code>：</p>
<p>假设a表的字符集编码是utf8mb4，bl表的字符集编码是utf8，那么是无法走索引的。</p>
<p>根据执行计划可知，a是驱动表，b是被驱动表，也就是从a表中取xxx字段，再去b表里查询匹配字段。</p>
<p>字符集utf8mb4是utf8的超集，所以当这两个类型比较时，MySQL先把utf8字符串转成utf8mb4字符集，再做比较。</p>
<p>因此需要将被驱动数据表里的字段一个个转换成utf8mb4。</p>
<p>可以把b表上的xxx字段的字符集也改成utf8mb4。</p>
<hr>
<ul>
<li>在索引列上进行表达式计算或函数不能使用索引：</li>
</ul>
<p><code>SELECT ... FROM ... WHERE YEAR(date) &lt;= &#39;2017&#39;;</code>，可以改成<code>SELECT ... FROM ... WHERE date &lt;= CURDATE();</code>。</p>
<ul>
<li>前导模糊查询不能使用索引：</li>
</ul>
<p><code>SELECT ... FROM ... WHERE xxx LIKE &#39;%xxx&#39;;</code>，除非使用覆盖索引进行索引扫描取代全表扫描，非前导模糊查询如<code>LIKE &#39;xxx%&#39;</code>则可以。</p>
<ul>
<li>负向条件查询不能使用索引：</li>
</ul>
<p>如<code>SELECT ... FROM ... WHERE xxx != &#39;xxx&#39;;</code>，包括<code>NOT IN</code>/<code>NOT EXISTS</code>/<code>NOT LIKE</code>。</p>
<ul>
<li><code>&lt;</code>/<code>&gt;</code>不能使用索引：</li>
</ul>
<p>可以考虑使用<code>&gt;=</code>替代<code>&gt;</code>，如用<code>SELECT ... FROM ... WHERE xxx &gt;= 4;</code>替代<code>SELECT ... FROM ... WHERE xxx &gt; 3;</code>。</p>
<ul>
<li><code>IS NULL</code>/<code>IS NOT NULL</code>无法使用索引：</li>
</ul>
<p>对于<code>SELECT ... FROM ... WHERE xxx IS NULL;</code>，可以考虑在xxx字段设置NOT NULL约束，默认值0，然后这样查询：<code>SELECT ... FROM ... WHERE xxx = 0;</code>。</p>
<p>索引列建议都使用NOT NULL约束及默认值，因为单列索引不保存NULL值。</p>
<ul>
<li>避免在<code>WHERE</code>子句中使用<code>OR</code>来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</li>
</ul>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
