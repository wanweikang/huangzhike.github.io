<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <script>
            var timeStart = new Date();
        </script>
        
        <title>[笔记]-MySQL-执行计划 | 学而时习之</title>
        
        <meta name="author" content="Huangzhike">
        
        
        <meta name="description" content="K.I.S.S">
        
        
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        
        <meta property="og:title" content="[笔记]-MySQL-执行计划"/>
        
        <meta property="og:site_name" content="学而时习之"/>
        
        
        <!-- favicon -->
        <link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
        <meta name="msapplication-TileColor" content="#009688">
        <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
        <meta name="theme-color" content="#009688">
        <!-- favicon end -->
        <!-- <link href="//ok.ico" rel="icon"> -->
        
        <!-- toc -->
        <!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
        <!-- material design -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
        <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
        <!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
        <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
        <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">
        
        <!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
        <!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
    <meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-MySQL-执行计划</h2>
				
				<div>
					<div class="post-time">2020-05-27</div>
				</div>
				
				<div class="article-content">
				<h3 id="id："><a href="#id：" class="headerlink" title="id："></a>id：</h3><p>标识SELECT所属的行，如果语句没有子查询或者联合，那么都是1，否则，内层的SELECT语句会顺序标号，对应在原始语句中的位置。</p>
<p>id是按SELECT出现的顺序增长的，越大执行优先级越高，相同则从上往下执行，为NULL最后执行。</p>
<h3 id="select-type："><a href="#select-type：" class="headerlink" title="select_type："></a>select_type：</h3><p>查询分为简单（SIMPLE）和复杂（PRIMARY）类型，复杂类型可分为简单子查询、派生表（FROM子句的子查询）、UNION查询。</p>
<h4 id="SIMPLE："><a href="#SIMPLE：" class="headerlink" title="SIMPLE："></a>SIMPLE：</h4><p>简单的查询，查询中不包含子查询或者UNION。</p>
<h4 id="PRIMARY："><a href="#PRIMARY：" class="headerlink" title="PRIMARY："></a>PRIMARY：</h4><p>查询中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。</p>
<h4 id="SUBQUERY："><a href="#SUBQUERY：" class="headerlink" title="SUBQUERY："></a>SUBQUERY：</h4><p>在SELECT或WHERE中包含了子查询，如<code>EXPLAIN SELECT (SELECT 1 from user LIMIT 1) from user;</code>。</p>
<p>优化器可能对子查询进行重写，转换为连接查询，如<code>EXPLAIN SELECT * FROM user WHERE id IN (SELECT user_id FROM user_group);</code>。</p>
<h4 id="DERIVED："><a href="#DERIVED：" class="headerlink" title="DERIVED："></a>DERIVED：</h4><p>在FROM中包含的子查询被标记为DERIVED，MySQL会递归执行并将结果放入临时表中，称为派生表（从子查询派生出来的表）；</p>
<p>如<code>EXPLAIN SELECT FROM (SELECT id, count() as c from group GROUP BY name) as derived;</code>，这个查询执行时有个临时表别名为derived，外部查询引用了这个临时表。</p>
<h4 id="UNION："><a href="#UNION：" class="headerlink" title="UNION："></a>UNION：</h4><p>如<code>EXPLAIN SELECT FROM user UNION SELECT FROM user;</code>。</p>
<p>在UNION中的第二个及以后的SELECT被标记为UNION，如果UNION被FROM子句的子查询包含，那么它的第一个SELECT会被标记为DERIVED，而不是PRIMARY。</p>
<h4 id="UNION-RESULT："><a href="#UNION-RESULT：" class="headerlink" title="UNION RESULT："></a>UNION RESULT：</h4><p>使用临时表完成UNION去重。</p>
<h4 id="DEPENDENT-SUBQUERY："><a href="#DEPENDENT-SUBQUERY：" class="headerlink" title="DEPENDENT SUBQUERY："></a>DEPENDENT SUBQUERY：</h4><p>SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE，其中DEPENDENT意味着SELECT依赖于外层查询的数据，该查询可能会被执行多次。</p>
<p>包含的子查询语句为相关子查询，则该子查询的第一个SELECT就会DEPENDENT SUBQUERY。</p>
<h4 id="DEPENDENT-UNION："><a href="#DEPENDENT-UNION：" class="headerlink" title="DEPENDENT UNION："></a>DEPENDENT UNION：</h4><p>包含的子查询语句中包含了UNION或者UNION ALL的大查询，这些查询都依赖外层查询，这些子查询语句类型为DEPENDENT UNION。</p>
<p><code>EXPLAIN SELECT * FROM user WHERE id IN (SELECT user_id FROM user_group WHERE name = &#39;a&#39; UNION SELECT id FROM user WHERE name = &#39;b&#39;);</code></p>
<p><code>SELECT user_id FROM user_group WHERE name = &#39;a&#39;</code>是第一个子查询，它为DEPENDENT SUBQUERY（虽然表面上不依赖外层查询，但是MySQL会改写，谨慎使用IN子查询）。</p>
<p><code>SELECT id FROM user WHERE name = &#39;b&#39;</code>这个查询在UNION后面，它为DEPENDENT UNION。</p>
<p>一个栗子：</p>
<p><code>EXPLAIN SELECT film_id FROM (SELECT flm_id FROM film) AS derived;</code></p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center"><code>&lt;derived2&gt;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DERIVED</td>
<td align="center">film</td>
</tr>
</tbody></table>
<p>当FROM子句有子查询的时候，table列是<code>&lt;derivedN&gt;</code>的形式，其中N是子查询的id，这是向前引用，指向EXPLAIN的下面一行。</p>
<p>MySQL引入了物化，用于子查询（如在IN/NOT IN子查询及FROM子查询）优化。</p>
<p>在SQL执行过程中，第一次需要子查询结果时执行子查询并将子查询的结果保存为临时表，后续对子查询结果集的访问将直接通过临时表获得。</p>
<p>物化子查询的关键点在于对子查询只需要执行一次，相对的是对外表的每一行都对子查询进行调用，其执行计划中的查询类型为“DEPENDENT SUBQUERY”。</p>
<p>物化表的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引）。</p>
<p>一个栗子：</p>
<p><code>EXPLAIN SELECT 1 UNION SELECT 1;</code></p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">UNION</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center">UNION RESULT</td>
<td align="center"><code>&lt;union1,2&gt;</code></td>
</tr>
</tbody></table>
<p>当有UNION时，UNION RESULT的table列包含了参与UNION的id列表，这是向后引用。</p>
<p>UNION结果总是放在一个匿名临时表中，在这里名为<code>&lt;union1, 2&gt;</code>，表明这个临时表是为了合并两个查询结果集而创建的。</p>
<p>跟UNION对比，UNION ALL无需为最终结果去重，所以不会产生临时表。</p>
<p>一个栗子：</p>
<pre class=" language-SQL"><code class="language-SQL">EXPLAIN
SELECT actor_id, ( SELECT 1 FROM film_actor WHERE film_actor.actor_id = der_1.actor_id LIMIT 1 )
FROM ( SELECT actor_id FROM actor LIMIT 5 ) AS der_1 
UNION ALL
SELECT film_id, ( SELECT @var1 FROM rental LIMIT 1 )
FROM ( SELECT film_id, ( SELECT 1 FROM store LIMIT 1 ) FROM film LIMIT 5 ) AS der_2；</code></pre>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center"><code>&lt;derived3&gt;</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">DERIVED</td>
<td align="center">actor</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">film_actor</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">UNION</td>
<td align="center"><code>&lt;derived6&gt;</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">DERIVED</td>
<td align="center">film</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">SUBQUERY</td>
<td align="center">store</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">UNCACHEABLE SUBQUERY</td>
<td align="center">rental</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center">UNION RESULT</td>
<td align="center"><code>&lt;union1,4&gt;</code></td>
</tr>
</tbody></table>
<p>第1行向前引用了der_1，这个査询被标记为<code>&lt;derived3&gt;</code>。</p>
<p>第2行，它的id是3，因为它是査询中第3个SELECT的一部分，归为DERIVED类型是因为它嵌套在FROM子句中的子査询内部。</p>
<p>第3行的id为2，它在具有更高id的行后面，暗示后面再执行，它被归为DEPENDENT SUBQUERY，意味着其结果依赖于外层査询。</p>
<p>第4行被归为UNION，意味着它是UNION中的第2个或之后的SELECT，它的表为<code>&lt;derived6&gt;</code>，意味着是从子句FROM的子査询中检索数据并附加到UNION的临时表。</p>
<p>第5行是der_2子査询，EXPLAIN称其为<code>&lt;derived6&gt;</code>。</p>
<p>第6行是<code>&lt;derived6&gt;</code>的SELECT列表中的一个普通子査询，它的id为7，比下一行的id大，它显示了<code>&lt;derived6&gt;</code>子査询结束的边界。</p>
<p>当EXPLAIN输出SELECT类型为DERIVED的一行时，表示一个“嵌套范围”开始，如果后续行的id更小，意味着嵌套范围已经结束。</p>
<p>第7行是从第4行<code>&lt;derived6&gt;</code>中检索数据的SELECT列表中的部分，因为有用户变量，它被列为UNCACHEABLE SUBQUERY。</p>
<p>最后一行是UNION RESULT，代表从UNION的临时表中读取行，它会返回id是1和4的行结果，它们分别引用了<code>&lt;derived3&gt;</code>和<code>&lt;derived6&gt;</code>。</p>
<h3 id="type："><a href="#type：" class="headerlink" title="type："></a>type：</h3><p>访问类型</p>
<h4 id="ALL："><a href="#ALL：" class="headerlink" title="ALL："></a>ALL：</h4><p>全表扫描，从头到尾扫描找到需要的行（例外：查询使用了LIMIT，或Extra显示Using distinct/not exists）。</p>
<h4 id="index："><a href="#index：" class="headerlink" title="index："></a>index：</h4><p>也是扫描，不过是全索引扫描，扫描顺序是索引顺序，优点是避免了排序，缺点是需要按索引顺序读取行，通常都是随机读取，性能不好（例外：如果Extra显示Using index，说明使用的是覆盖索引，只需扫描索引即可）。</p>
<h4 id="range："><a href="#range：" class="headerlink" title="range："></a>range：</h4><p>有范围限制的索引扫描，通常见于BETWEEN或WHERE子句带有&gt;等，另外，当使用索引去查找一系列行时，如IN()和OR列表，也显示为范围扫描。</p>
<h4 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h4><p>索引访问，返回匹配单个值的所有行（可能匹配多个），见于非唯一索引或唯一索引的非唯一前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<p>称为ref是因为索引需要和某个参考值比较（参考值可能是常数，或者来自多表查询的前一个表的结果值）。</p>
<h4 id="eq-ref："><a href="#eq-ref：" class="headerlink" title="eq_ref："></a>eq_ref：</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是eq_ref。</p>
<p>只需返回一条匹配的结果，见于使用主键或唯一索引查找，性能很好。</p>
<p><code>EXPLAIN SELECT * FROM user_group INNER JOIN user ON user_group.user_id = user.id;</code>。</p>
<h4 id="const："><a href="#const：" class="headerlink" title="const："></a>const：</h4><p>可以将查询的某部分转化为一个常量，如<code>SELECT id FROM ... WHERE id = &#39;xx&#39;;</code>这个查询就是一个常量，不需要执行。</p>
<p>用于主键或唯一索引列与常数比较时，表最多有一个匹配行。</p>
<h4 id="system："><a href="#system：" class="headerlink" title="system："></a>system：</h4><p>const的特例，表里只有一条记录匹配时为system，如<code>EXPLAIN SELECT FROM (SELECT FROM xxx where id = 1) tmp;</code>。</p>
<h4 id="NULL："><a href="#NULL：" class="headerlink" title="NULL："></a>NULL：</h4><p>在优化阶段即可分解语句，执行阶段不需访问索引或行。</p>
<p>如从一个索引列选取最小值，可以通过查找索引完成，不需在执行时访问表：<code>EXPLAIN SELECT MIN(id) FROM ...;</code>。</p>
<h3 id="ref：-1"><a href="#ref：-1" class="headerlink" title="ref："></a>ref：</h3><p>上一个表的key列索引查找时用的列或常量。</p>
<h3 id="rows："><a href="#rows：" class="headerlink" title="rows："></a>rows：</h3><p>估计的需要遍历的行数，非准确值。</p>
<h3 id="Extra："><a href="#Extra：" class="headerlink" title="Extra："></a>Extra：</h3><h4 id="Using-index："><a href="#Using-index：" class="headerlink" title="Using index："></a>Using index：</h4><p>使用覆盖索引，不需要回表查询。</p>
<h4 id="Using-where："><a href="#Using-where：" class="headerlink" title="Using where："></a>Using where：</h4><p>在存储引擎检索完行后，服务器层再通过WHERE过滤，不是所有带WHERE子句的查询都会显示这个（比如WHERE条件涉及索引列，在读取索引时就被检测到了）。</p>
<h4 id="Using-index-condition："><a href="#Using-index-condition：" class="headerlink" title="Using index condition："></a>Using index condition：</h4><p>说明使用了索引条件推送。</p>
<h4 id="Using-where-Using-index："><a href="#Using-where-Using-index：" class="headerlink" title="Using where Using index："></a>Using where Using index：</h4><p>查询的列被索引覆盖，并且WHERE筛选条件是索引列之一，但并不是索引的前导列，意味着无法直接通过索引查找。</p>
<h4 id="NULL：-1"><a href="#NULL：-1" class="headerlink" title="NULL："></a>NULL：</h4><p>查询的列未被索引覆盖，并且WHERE筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过回表来查询。</p>
<h4 id="Using-temparory："><a href="#Using-temparory：" class="headerlink" title="Using temparory："></a>Using temparory：</h4><p>对查询结果排序时使用临时表，需要优化。</p>
<h4 id="Using-filesort："><a href="#Using-filesort：" class="headerlink" title="Using filesort："></a>Using filesort：</h4><p>说明不是按索引读取行的顺序，而是使用外部排序，在内存或者磁盘完成，需要优化。</p>
<h4 id="Using-join-buffer："><a href="#Using-join-buffer：" class="headerlink" title="Using join buffer："></a>Using join buffer：</h4><p>在获取JOIN条件时没有使用索引，并且需要连接缓冲区来存储中间结果，需要优化。</p>
<h4 id="Not-exists："><a href="#Not-exists：" class="headerlink" title="Not exists："></a>Not exists：</h4><p>LEFT JOIN优化，一旦找到了匹配LEFT JOIN标准的行，就不再搜索。</p>
<h4 id="Range-checked-for-each-Record："><a href="#Range-checked-for-each-Record：" class="headerlink" title="Range checked for each Record："></a>Range checked for each Record：</h4><p>没有找到理想的索引，因此对于从前面表中的每一个行组合，MySQL检查应该使用哪个索引。需要优化。</p>
<hr>
<p>索引条件推送：</p>
<p>在不使用索引条件推送（Index Condition Pushdown）的情况下，WHERE过滤条件只在服务器层作用，服务器层只是从存储引擎中取索引，然后在服务层过滤，再从存储引擎中取索引，如此循环。</p>
<p>使用了索引条件推送，索引的过滤条件推送到存储引擎，存储引擎直接返回过滤后的数据，服务层不需要过滤。</p>
<p>索引条件推送只能用于二级索引。</p>
<hr>
<p>连接：将表的一行与另一个行匹配并产生结果。</p>
<p>将一个表的每一行与另一个表的每一行得到全部组合的连接，称为笛卡尔积。</p>
<p>假设有3个表分别有100、200、300行，这种连接可能会返回100* 200 * 300 = 6000000行。</p>
<p>连接主要有三种：外连接、内连接、交叉连接。</p>
<p>外连接分为三种：左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)、全外连接(FULL OUTER JOIN或FULL JOIN)。</p>
<p>MySQL暂不支持全外连接，但是可以使用UNION和UNION ALL模拟。</p>
<p>内连接(INNER JOIN)：结合两个表中相同的字段，返回关联字段相符的记录。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">ON</span> t1<span class="token number">.c1</span> <span class="token operator">=</span> t2<span class="token number">.c2</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">WHERE</span> t1<span class="token number">.c1</span> <span class="token operator">=</span> t2<span class="token number">.c2</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> t2 <span class="token keyword">USING</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 要求x列必须同名</span></code></pre>
<p>交叉连接：CROSS JOIN，笛卡尔积在SQL中的实现。</p>
<hr>
<p>Join匹配原理</p>
<p>MySQL只支持一种算法，嵌套循环（Nested-Loop）。</p>
<ul>
<li>Simple Nested-Loop Join</li>
</ul>
<p>每扫描驱动表的一行，扫描被驱动表找匹配的数据，总扫描次数为：驱动表行数*被驱动表行数，效率最低。</p>
<p>如驱动表表有200行，被驱动表有100行，总扫描次数为200 * 100。</p>
<ul>
<li>Block Nested-Loop Join</li>
</ul>
<p>Simple Nested-Loop的优化，先扫描驱动表一定行数（根据JOIN_BUFFER_SIZE决定），放到JOIN_BUFFER，然后遍历被驱动表。</p>
<p>被驱动表每次匹配JOIN_BUFFER里的数据，减少扫描次数。</p>
<p>也就是说，一开始是不直接扫描被驱动表的，而是把驱动表的数据加载到JOIN_BUFFER，当JOIN_BUFFER加载满了，或者是最后一条记录时，才开始扫描被驱动表。</p>
<p>对于被驱动表的每一行，从JOIN_BUFFER取出驱动表的行进行匹配，即，一块JOIN_BUFFER用完时，只扫描一次被驱动表。</p>
<ul>
<li>Index Nested-Loop Join</li>
</ul>
<p>每扫描驱动表的一行，根据条件通过索引去被驱动表找，避免了扫描被驱动表，需要被驱动表有索引，比较高效。</p>
<hr>
<p>有两个表，t1和t2，表结构和内容一模一样，假设字段a是索引字段：</p>
<p><code>SELECT * FROM t1 STRAIGHT_JOIN t2 ON (t1.a = t2.a);</code></p>
<p>执行逻辑大概是：</p>
<p>从t1中读入一行R，取出a字段到表t2查找，取出表t2中满足条件的行，和R组成一行，作为结果集的一部分，重复执行，直到表t1末尾，循环结束。</p>
<p>由于使用了索引，所以在将t1表数据取出来后，根据t1表的a字段和t2表的索引，进行等值查找，使用被驱动表的索引关联称为“Index Nested-Loop Join”。</p>
<p>由于是驱动表t1去匹配被驱动表t2，匹配次数取决于t1有多少数据，所以最好使用数据量少的表作为驱动表。</p>
<p>假设关联字段上没有索引，那么使用JOIN_BUFFER来进行关联。</p>
<p>如果被驱动表上没有可用的索引，执行逻辑大概是：</p>
<p>把表t1的数据读入内存JOIN_BUFFER中，这里写的是<code>SELECT *</code>，因此是把整个表t1放入了内存。</p>
<p>扫描表t2，取出每一行，跟JOIN_BUFFER的数据对比，满足条件的作为结果集的一部分返回。</p>
<p>JOIN_BUFFER大小默认值256k，如果放不下表t1的所有数据话，那么需要分段放，被驱动表就要扫描多次。</p>
<p>两个表按照各自的条件过滤后，参与JOIN的行数小的表，就是“小表”，应该作为驱动表，减少分段的次数。</p>
<hr>
<p>假设t1和t2各自有1000行。</p>
<p><code>EXPLAIN SELECT t1.c1, t2.c2 FROM t1 INNER JOIN t2 ON t1.c1 = t2.c2;</code></p>
<p>没有索引：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">t1</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">1000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIMPLE</td>
<td align="center">t2</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">1000</td>
<td align="center">Using where; Using join buffer</td>
</tr>
</tbody></table>
<p>全表扫描，对于t1表的每一行，扫描t2表的每一行进行匹配，1000 * 1000种组合（当然这里使用了JOIN BUFFER）。</p>
<p>假设t2的列c2有一个索引：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">t1</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">1000</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIMPLE</td>
<td align="center">t2</td>
<td align="center">ref</td>
<td align="center">c2</td>
<td align="center">t1.c1</td>
<td align="center">10</td>
<td align="center">Using where; Using index</td>
</tr>
</tbody></table>
<p>可以通过t1.c1的引用完成t2表的索引查找，并且估计对于t1表里的每行，在t2表只需要检查10行即可。1000 * 10种组合。</p>
<p>实际上如果运行ANALYZE TABLE t1, t2; 这个命令，再次执行EXPLAIN命令，可以获得更精确的rows估算值，这里第二行的rows会变成1，说明估计对于t1表里的每行，在t2表只有一行匹配。</p>
<p>假设t2的列c2有一个索引，t1的列c1有一个索引：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">t1</td>
<td align="center">index</td>
<td align="center">c1</td>
<td align="center">NULL</td>
<td align="center">1000</td>
<td align="center">Using index</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">SIMPLE</td>
<td align="center">t2</td>
<td align="center">ref</td>
<td align="center">c2</td>
<td align="center">t1.c1</td>
<td align="center">10</td>
<td align="center">Using where; Using index</td>
</tr>
</tbody></table>
<p>只需扫描索引即可。</p>
<hr>
<p>Join优化原则</p>
<ul>
<li><p>尽量减少驱动表的行数；</p>
</li>
<li><p>尽量保证被驱动表的关联条件建立索引；</p>
</li>
<li><p>上面的条件都不满足，且内存资源充足，可以适当提高JOIN_BUFFER大小。</p>
</li>
</ul>
<p>优化器优先将小表作为驱动表，INNER JOIN有优化，执行计划会安排顺序，自动以小表为驱动。</p>
<p>LEFT JOIN等没有优化，因为LEFT JOIN相当于强制要求了左边为主表。</p>
<hr>
<h4 id="INNER-JOIN："><a href="#INNER-JOIN：" class="headerlink" title="INNER JOIN："></a>INNER JOIN：</h4><p>如果不涉及ORDER BY，首先考虑使用JOIN，如果关联的表是多对一，或一对一，JOIN的性能比EXISTS和IN要好。</p>
<p>如果是一对多，查出来的结果就会有重复，如果为了去重加了DISTINCT，但查询字段包括未建立索引的字段，执行计划就会出现Using temporary，性能大打折扣，除非在程序中去重。</p>
<p>MySQL在JOIN表连接时会选择结果集较小的表作为驱动表，再以此遍历被驱动表。</p>
<p>如果对驱动表的字段ORDER BY，没有问题，但如果对被驱动表ORDER BY，则会出现Using temporary，及Using filesort。</p>
<p>在有ORDER BY的情况下，可以考虑使用EXISTS或IN子查询代替。</p>
<p>但是有时候优化器会将IN转化为JOIN表连接，执行计划其实是一样的。</p>
<h4 id="EXISTS："><a href="#EXISTS：" class="headerlink" title="EXISTS："></a>EXISTS：</h4><p>关联子查询，是条件表达式的一部分，子查询不返回结果集，只返回true或false。</p>
<p>首先执行一次外部查询，对于外部查询中的每一行，分别执行一次子查询，每次执行子查询时都会引用外部查询中当前行的值。</p>
<p>根据使用子查询返回的结果，确定外部查询的结果集。</p>
<p>EXISTS适合外部查询的表数量级比内部子查询表小的情况。</p>
<h4 id="IN："><a href="#IN：" class="headerlink" title="IN："></a>IN：</h4><p>IN和EXISTS不一样，执行顺序是先执行子查询产生结果集，然后主查询再去结果集里去找符合要求的字段列表。</p>
<p>如果IN后面的列表很少，而且字段上存在索引，性能还是很高的。</p>
<p>但即使存在索引，当列表数量达到临界值时，会导致全表扫描，不走索引（避免回表的随机IO）。</p>
<p>IN适合外部查询的表数据量级比子查询表大的情况，但是子查询返回的行数一般都较多，所以通常都用EXISTS。</p>
<h4 id="NOT-EXISTS："><a href="#NOT-EXISTS：" class="headerlink" title="NOT EXISTS："></a>NOT EXISTS：</h4><p>先执行外查询，对外查询的每一行，执行子查询，可以使用索引，存在就返回true，不存在就返回false。</p>
<p>尽量使用NOT EXISTS，而不要用NOT IN。</p>
<h4 id="NOT-IN："><a href="#NOT-IN：" class="headerlink" title="NOT IN："></a>NOT IN：</h4><p>先执行子查询，然后在子查询返回的结果集中，一行行遍历，符合要求的就返回，不符合的就继续下一条，直到遍历完。</p>
<p>为了证明不在结果集里边，只能查询全部记录才能证明，不会用到索引。</p>
<p>其实和连接查询类似，都是尽量以小表为驱动表，同时被驱动表的关联字段尽量要有索引。</p>
<hr>
<p>半连接（SEMI-JOIN）：</p>
<p>和IN语句子查询有关：<code>SELECT ... FROM outer_table WHERE expr IN (SELECT ... FROM inner_table ...) AND ...</code>。</p>
<hr>
<p>理论上下面的句子是可以使用索引进行排序的，但是优化器的执行顺序是把film_actor当做关联的第二张表，所以无法使用索引排序。</p>
<p><code>EXPLAIN SELECT ... FROM film_actor INNER JOIN film USING(film_id) ORDER BY actor_id;</code>：</p>
<table>
<thead>
<tr>
<th align="center">table</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">film</td>
<td align="center">Using index; Using temparory; Using filesort</td>
</tr>
<tr>
<td align="center">film_actor</td>
<td align="center">Using index</td>
</tr>
</tbody></table>
<p>优化器可能重新定义关联表的顺序，执行顺序不一定按查询指定的顺序执行。</p>
<p><code>EXPLAIN SELECT ... FROM film INNER JOIN film_actor USING(film_id) INNER JOIN actor USING(actor_id);</code></p>
<p>表面上看，应该是从film表开始，根据film_actor的索引film_id查找对应的actor_id，再根据actor的主键找到对应的记录。</p>
<p>结果顺序是完全相反的。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">actor</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">200</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film_actor</td>
<td align="center">ref</td>
<td align="center">PRIMARY</td>
<td align="center">actor.actor_id</td>
<td align="center">1</td>
<td align="center">Using index</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">film_actor.film_id</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><code>EXPLAIN STRAIGHT_JOIN SELECT ... FROM film INNER JOIN film_actor USING(film_id) INNER JOIN actor USING(actor_id);</code></p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">951</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film_actor</td>
<td align="center">ref</td>
<td align="center">idx_film_id</td>
<td align="center">film.film_id</td>
<td align="center">1</td>
<td align="center">Using index</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">actor</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">film_actor.actor_id</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>两种关联顺序下，明显倒转后，第一个关联表只需扫描较少的行数，而第二和第三个关联都是根据索引查询，速度都很快。</p>
<p>在嵌套查询下，优化后的查询成本会更低。</p>
<p>MySQL的文件排序，数量小则在内存进行快速排序，数量大则使用磁盘，分块排序后合并，统一称为filesort。</p>
<p>在关联查询的时候如果需要排序，如果ORDER BY子句的所有列都来自关联的第一个表，那么可以在处理第一个表的时候就进行文件排序（Extra: Using filesort）。</p>
<p>否则，都会先将关联的结果放入一个临时表，在所有关联结束后，再进行文件排序（Extra: Using temporary; Using filesort），如果查询中有LIMIT的话，也要排序后才能应用。</p>
<hr>
<p>对于WHERE条件包含IN的子查询语句：</p>
<p><code>SELECT * FROM film WHERE film_id IN( SELECT film_id FROM film_actor WHERE actor_id = 1 );</code></p>
<p>一般会认为先执行子查询，返回film_id列表，然后执行IN()列表查询，但是，MySQL会将外层表压到子查询中：</p>
<p><code>SELECT * FROM film WHERE EXISTS (SELECT * FROM film_actor WHERE actor_id = 1 AND film_actor.film_id = film.film_id );</code></p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center">film</td>
<td align="center">ALL</td>
<td align="center">PRIMARY</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">film_actor</td>
<td align="center">eq_ref</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果外层表film非常大，性能会非常糟糕。</p>
<p>改写：<code>SELECT film.* FROM film INNER JOIN film_actor USING(film_id) WHERE actor_id = 1;</code>。</p>
<hr>
<p><code>EXPLAIN SELECT film.film_id, film_actor.actor_id FROM film INNER JOIN film_actor USING(film_id) WHERE film.film_id = 1;</code></p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film</td>
<td align="center">const</td>
<td align="center">PRIMARY</td>
<td align="center">const</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">film_actor</td>
<td align="center">ref</td>
<td align="center">idx_film_id</td>
<td align="center">const</td>
<td align="center">10</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>第一步查film表，因为有主键索引film_id，所以会知道只会返回一行数据。</p>
<p>第二步，将film_id当做一个已知的值处理，所以两个表的访问类型都是const。</p>
<p>语义上，IN(xx, xx, xx)完全等同于多个OR条件的子句，但是MySQL会将IN中的数据进行排序，再通过二分查找来确定列表的值是否满足条件，当IN中的数据量较大时，速度会更快。</p>
<p>对于UNION查询，MySQL先将单个查询结果放入临时表，然后载读出临时表完成查询。</p>
<p>MySQL对任何关联都执行嵌套关联，先从一个表取出一条数据，再嵌套循环到下一个表寻找匹配的行，直到找到表中所有的匹配。</p>
<p>然后根据各个表匹配的行，返回查询中需要的各个列。</p>
<p>MySQL尝试在最后一个关联表中找到所有匹配的行，如果无法找到，返回上一层关联表，以此类推。</p>
<p>MySQL在FROM子句中遇到子查询时，先执行子查询，并将结果放入一个临时表，临时表是没有索引的，对UNION也一样。</p>
<hr>
<p>EXPLAIN EXTENDED … ：显示优化后的SQL语句，来自执行计划。</p>
<p>STRAGHT_JOIN：强制优化器按特定的顺序使用数据表。</p>
<p>强制索引：<code>SELECT ... FROM ... FORCE INDEX(&#39;index_name&#39;) WHERE ...</code>。</p>
<p>忽略索引：<code>IGNORE INDEX</code>。</p>
<hr>
<pre class=" language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>  <span class="token keyword">SELECT</span>
<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>  <span class="token keyword">DISTINCT</span> <span class="token operator">&lt;</span>select_list<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>left_table<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token operator">&lt;</span>join_type<span class="token operator">></span> <span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>right_table<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token keyword">ON</span> <span class="token operator">&lt;</span>join_condition<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>  <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>where_condition<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>group_by_list<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>  <span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>having_condition<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>order_by_condition<span class="token operator">></span>
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token operator">&lt;</span>limit_number<span class="token operator">></span></code></pre>
<p>执行顺序：</p>
<p>FROM：对FROM的左边和右边的表计算笛卡尔积。产生虚表VT1。</p>
<p>ON：对虚表VT1进行ON筛选，产生虚表VT2，把符合条件的存在VT2。</p>
<p>JOIN：如果是OUTER JOIN，将添加外部行，如果是LEFT JOIN就把左表未匹配的行添加进来，如果是RIGHT JOIN，就把右表添加进来，生成新的虚表VT3。</p>
<p>WHERE：执行WHERE过滤，对上一步的虚表筛选，生成虚表VT4。</p>
<p>GROUP BY: 根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5。</p>
<p>HAVING：使用HAVING过滤，把符合条件的放在VT6。</p>
<p>SELECT：执行SELECT语句，将VT6中的结果按照SELECT进行筛选，生成VT7。</p>
<p>DISTINCT：对TV7生成的记录进行去重，生成VT8。如果应用了GROUP BY子句那么DISTINCT是多余的，分组是将列中唯一的值分成一组，同时只为每一组返回一行记录，记录都是不相同的。</p>
<p>ORDER BY：按照条件排序VT8，返回一个游标，而不是虚拟表。</p>
<p>LIMIT：取出指定行的记录，产生虚拟表，并将结果返回。</p>
<hr>
<ul>
<li>COUNT(column)：</li>
</ul>
<p>InnoDB引擎遍历表，取出每一行的该列值，返回给Server层，Server层判断不为NULL，则累加，即统计NOT NULL的行数。</p>
<ul>
<li>COUNT(primary key)：</li>
</ul>
<p>InnoDB引擎遍历表，取出每一行的主键，返回给Server层，Server层判断不为NULL，则累加，即统计NOT NULL的行数。</p>
<ul>
<li>COUNT(1)：</li>
</ul>
<p>InnoDB引擎遍历表，但不取值，返回给Server层，Server层放入数字1，判断不为NULL，则累加，即统计所有行数。</p>
<ul>
<li>COUNT(*)：</li>
</ul>
<p>统计所有行数。</p>
<p>InnoDB为何不像MyISAM一样维护住一个ROW_COUNT变量？</p>
<p>从MVCC机制与行可见性可知，每个事务所看到的行可能是不一样的。</p>
<hr>
<p>MySQL产生临时表的情况：EXPLAIN查看执行计划的Extra列中，如果出现Using Temporary就表示会用到临时表。</p>
<ul>
<li><p>使用UNION查询：UNION会去掉两个表中的重复数据，会产生临时表，对结果集去重。使用UNION ALL则不会产生临时表。</p>
</li>
<li><p>ORDER BY和GROUP BY的子句不一样时也会产生临时表。</p>
</li>
<li><p>DISTINCT查询并且加上ORDER BY时。</p>
</li>
<li><p>FROM中的子查询。</p>
</li>
</ul>
<hr>
<p>慢查询归纳：</p>
<ul>
<li><p>全表扫描。</p>
</li>
<li><p>全索引扫描。</p>
</li>
<li><p>索引过滤性不好。</p>
</li>
<li><p>频繁回表的开销。</p>
</li>
</ul>
<p>慢查询优化基本步骤：</p>
<ul>
<li><p>设置SQL_NO_CACHE，观察SQL执行结果。</p>
</li>
<li><p>WHERE条件单表查，找到返回记录最少的表，单表每个字段分别查询，看哪个字段的区分度最高。</p>
</li>
<li><p>EXPLAIN查看执行计划，是否从锁定记录较少的表开始查询。</p>
</li>
<li><p>ORDER BY LIMIT形式让排序的表优先查。</p>
</li>
<li><p>酌情加索引，继续调试。</p>
</li>
</ul>
<p>遍历的ROWS越少，速度越快。</p>
<hr>
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">来自美团的技术分享</a>：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>
   <span class="token keyword">distinct</span> cert<span class="token punctuation">.</span>emp_id 
<span class="token keyword">from</span>
   cm_log cl 
<span class="token keyword">inner</span> <span class="token keyword">join</span>
   <span class="token punctuation">(</span>
      <span class="token keyword">select</span>
         emp<span class="token punctuation">.</span>id <span class="token keyword">as</span> emp_id<span class="token punctuation">,</span>
         emp_cert<span class="token punctuation">.</span>id <span class="token keyword">as</span> cert_id 
      <span class="token keyword">from</span>
         employee emp 
      <span class="token keyword">left</span> <span class="token keyword">join</span>
         emp_certificate emp_cert 
            <span class="token keyword">on</span> emp<span class="token punctuation">.</span>id <span class="token operator">=</span> emp_cert<span class="token punctuation">.</span>emp_id 
      <span class="token keyword">where</span>
         emp<span class="token punctuation">.</span>is_deleted <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token punctuation">)</span> cert 
      <span class="token keyword">on</span> <span class="token punctuation">(</span>
         cl<span class="token punctuation">.</span>ref_table <span class="token operator">=</span> <span class="token string">'Employee'</span> 
         <span class="token operator">and</span> cl<span class="token punctuation">.</span>ref_oid <span class="token operator">=</span> cert<span class="token punctuation">.</span>emp_id
      <span class="token punctuation">)</span> 
      <span class="token operator">or</span> <span class="token punctuation">(</span>
         cl<span class="token punctuation">.</span>ref_table <span class="token operator">=</span> <span class="token string">'EmpCertificate'</span> 
         <span class="token operator">and</span> cl<span class="token punctuation">.</span>ref_oid <span class="token operator">=</span> cert<span class="token punctuation">.</span>cert_id
      <span class="token punctuation">)</span> 
<span class="token keyword">where</span>
   cl<span class="token punctuation">.</span>last_upd_date <span class="token operator">>=</span> <span class="token string">'2013-11-07 15:03:00'</span> 
   <span class="token operator">and</span> cl<span class="token punctuation">.</span>last_upd_date <span class="token operator">&lt;=</span> <span class="token string">'2013-11-08 16:00:00'</span><span class="token punctuation">;</span></code></pre>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center">cl</td>
<td align="center">range</td>
<td align="center">idx_last_upd_date</td>
<td align="center">NULL</td>
<td align="center">379</td>
<td align="center">Using where; Using temporary</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center"><code>&lt;derived2&gt;</code></td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">63727</td>
<td align="center">Using where; Using join buffer</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DERIVED</td>
<td align="center">emp</td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL</td>
<td align="center">13317</td>
<td align="center">Using where</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">DERIVED</td>
<td align="center">emp_cert</td>
<td align="center">ref</td>
<td align="center">emp_certificate_empid</td>
<td align="center">meituanorg.emp.id</td>
<td align="center">1</td>
<td align="center">Using index</td>
</tr>
</tbody></table>
<p>首先根据idx_last_upd_date索引扫描cm_log表获得379条记录；</p>
<p>然后查表扫描了63727条记录，分为两部分，derived表示构造表，一个语句形成的结果集，后面的数字表示语句的ID。</p>
<p>derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。</p>
<p>ID = 2的语句首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows为1表示，每个关联都只锁定了一条记录。</p>
<p>获得后，再和cm_log的379条记录根据规则关联。</p>
<p>可以看出返回了太多的数据，绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。</p>
<p>在运行完后还是要和cm_log做join，那么能不能之前和cm_log做join呢？</p>
<p>分析语句发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表。</p>
<p>可以拆成两部分，并用union连接起来，这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。</p>
<p>如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p>
<p>优化过的语句如下：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>
    emp<span class="token punctuation">.</span>id 
<span class="token keyword">from</span>
    cm_log cl 
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    employee emp 
        <span class="token keyword">on</span> cl<span class="token punctuation">.</span>ref_table <span class="token operator">=</span> <span class="token string">'Employee'</span> 
        <span class="token operator">and</span> cl<span class="token punctuation">.</span>ref_oid <span class="token operator">=</span> emp<span class="token punctuation">.</span>id  
<span class="token keyword">where</span>
    cl<span class="token punctuation">.</span>last_upd_date <span class="token operator">>=</span> <span class="token string">'2013-11-07 15:03:00'</span> 
    <span class="token operator">and</span> cl<span class="token punctuation">.</span>last_upd_date<span class="token operator">&lt;=</span> <span class="token string">'2013-11-08 16:00:00'</span> 
    <span class="token operator">and</span> emp<span class="token punctuation">.</span>is_deleted <span class="token operator">=</span> <span class="token number">0</span>  
<span class="token keyword">union</span>
<span class="token keyword">select</span>
    emp<span class="token punctuation">.</span>id 
<span class="token keyword">from</span>
    cm_log cl 
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    emp_certificate <span class="token number">ec</span> 
        <span class="token keyword">on</span> cl<span class="token punctuation">.</span>ref_table <span class="token operator">=</span> <span class="token string">'EmpCertificate'</span> 
        <span class="token operator">and</span> cl<span class="token punctuation">.</span>ref_oid <span class="token operator">=</span> <span class="token number">ec</span><span class="token punctuation">.</span>id 
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    employee emp 
        <span class="token keyword">on</span> emp<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">ec</span><span class="token punctuation">.</span>emp_id  
<span class="token keyword">where</span>
    cl<span class="token punctuation">.</span>last_upd_date <span class="token operator">>=</span> <span class="token string">'2013-11-07 15:03:00'</span> 
    <span class="token operator">and</span> cl<span class="token punctuation">.</span>last_upd_date <span class="token operator">&lt;=</span> <span class="token string">'2013-11-08 16:00:00'</span> 
    <span class="token operator">and</span> emp<span class="token punctuation">.</span>is_deleted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center">cl</td>
<td align="center">range</td>
<td align="center">idx_last_upd_date</td>
<td align="center">NULL</td>
<td align="center">379</td>
<td align="center">Using where</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">PRIMARY</td>
<td align="center">emp</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">meituanorg.cl.ref_oid</td>
<td align="center">1</td>
<td align="center">Using where</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">UNION</td>
<td align="center">cl</td>
<td align="center">range</td>
<td align="center">idx_last_upd_date</td>
<td align="center">NULL</td>
<td align="center">379</td>
<td align="center">Using where</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">UNION</td>
<td align="center">ec</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">meituanorg.cl.ref_oid</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">UNION</td>
<td align="center">emp</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">meituanorg.ec.emp_id</td>
<td align="center">1</td>
<td align="center">Using where</td>
</tr>
<tr>
<td align="center">NULL</td>
<td align="center">UNION RESULT</td>
<td align="center"><code>&lt;union1,2&gt;</code></td>
<td align="center">ALL</td>
<td align="center">NULL</td>
<td align="center">NULL.emp.id</td>
<td align="center">NULL</td>
<td align="center"></td>
</tr>
</tbody></table>
<hr>
<p>一般认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这是有局限性的。</p>
<p>无法优化的语句：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>
    <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>position<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>sex<span class="token punctuation">,</span>
    from_unixtime<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>created_time<span class="token punctuation">)</span> <span class="token keyword">as</span> created_time<span class="token punctuation">,</span>
    from_unixtime<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>last_modified<span class="token punctuation">)</span> <span class="token keyword">as</span> last_modified<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>last_modified_user_id  
<span class="token keyword">from</span>
    contact <span class="token number">c</span>  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    contact_branch <span class="token number">cb</span> 
        <span class="token keyword">on</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">cb</span><span class="token punctuation">.</span>contact_id  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    branch_user bu 
       <span class="token keyword">on</span> <span class="token number">cb</span><span class="token punctuation">.</span>branch_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>branch_id 
       <span class="token operator">and</span> bu<span class="token punctuation">.</span><span class="token keyword">status</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    org_emp_info oei 
        <span class="token keyword">on</span> oei<span class="token punctuation">.</span>data_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>user_id 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_left <span class="token operator">>=</span> <span class="token number">2875</span> 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_right <span class="token operator">&lt;=</span> <span class="token number">10802</span> 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>org_category <span class="token operator">=</span> <span class="token operator">-</span> <span class="token number">1</span> 
<span class="token keyword">order</span> <span class="token keyword">by</span>
    <span class="token number">c</span><span class="token punctuation">.</span>created_time <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>返回10条记录用了13秒。</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">table</th>
<th align="center">type</th>
<th align="center">key</th>
<th align="center">ref</th>
<th align="center">rows</th>
<th align="center">Extra</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">oei</td>
<td align="center">ref</td>
<td align="center">idx_category_left_right</td>
<td align="center">const</td>
<td align="center">8849</td>
<td align="center">Using where; Using temporary; Using filesort</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">bu</td>
<td align="center">ref</td>
<td align="center">idx_userid_status</td>
<td align="center">meituancrm.oei.data_id</td>
<td align="center">76</td>
<td align="center">Using where; Using index</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">cb</td>
<td align="center">ref</td>
<td align="center">idx_branch_id</td>
<td align="center">meituancrm.bu.branch_id</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">c</td>
<td align="center">eq_ref</td>
<td align="center">PRIMARY</td>
<td align="center">meituancrm.cb.contact_id</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。</p>
<p>返回的行都非常少，会不会是排序量太大？于是简化SQL，看看到底用了多少记录来排序。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>
    <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">from</span>
    contact <span class="token number">c</span>  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    contact_branch <span class="token number">cb</span> 
        <span class="token keyword">on</span> <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">cb</span><span class="token punctuation">.</span>contact_id  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    branch_user bu 
        <span class="token keyword">on</span> <span class="token number">cb</span><span class="token punctuation">.</span>branch_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>branch_id 
        <span class="token operator">and</span> bu<span class="token punctuation">.</span><span class="token keyword">status</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  
<span class="token keyword">inner</span> <span class="token keyword">join</span>
    org_emp_info oei 
        <span class="token keyword">on</span> oei<span class="token punctuation">.</span>data_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>user_id 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_left <span class="token operator">>=</span> <span class="token number">2875</span> 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_right <span class="token operator">&lt;=</span> <span class="token number">10802</span> 
        <span class="token operator">and</span> oei<span class="token punctuation">.</span>org_category <span class="token operator">=</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre>
<table>
<thead>
<tr>
<th align="center">count(*)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">778878</td>
</tr>
</tbody></table>
<p>发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的。</p>
<p>那能不能换个思路，先根据contact的created_time排序，再来join？</p>
<p>于是改造成下面的语句，也可以用straight_join来优化：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span>
    <span class="token number">c</span><span class="token punctuation">.</span>id<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>position<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>sex<span class="token punctuation">,</span>
    from_unixtime<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>created_time<span class="token punctuation">)</span> <span class="token keyword">as</span> created_time<span class="token punctuation">,</span>
    from_unixtime<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>last_modified<span class="token punctuation">)</span> <span class="token keyword">as</span> last_modified<span class="token punctuation">,</span>
    <span class="token number">c</span><span class="token punctuation">.</span>last_modified_user_id   
<span class="token keyword">from</span>
    contact <span class="token number">c</span>  
<span class="token keyword">where</span>
    <span class="token keyword">exists</span> <span class="token punctuation">(</span>
        <span class="token keyword">select</span>
            <span class="token number">1</span> 
        <span class="token keyword">from</span>
            contact_branch <span class="token number">cb</span> 
        <span class="token keyword">inner</span> <span class="token keyword">join</span>
            branch_user bu
                <span class="token keyword">on</span>  <span class="token number">cb</span><span class="token punctuation">.</span>branch_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>branch_id 
                <span class="token operator">and</span> bu<span class="token punctuation">.</span><span class="token keyword">status</span> <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">inner</span> <span class="token keyword">join</span>
            org_emp_info oei
                <span class="token keyword">on</span>  oei<span class="token punctuation">.</span>data_id <span class="token operator">=</span> bu<span class="token punctuation">.</span>user_id  
                <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_left <span class="token operator">>=</span> <span class="token number">2875</span> 
                <span class="token operator">and</span> oei<span class="token punctuation">.</span>node_right <span class="token operator">&lt;=</span> <span class="token number">10802</span>
                <span class="token operator">and</span> oei<span class="token punctuation">.</span>org_category <span class="token operator">=</span> <span class="token operator">-</span> <span class="token number">1</span> 
        <span class="token keyword">where</span>
            <span class="token number">c</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">cb</span><span class="token punctuation">.</span>contact_id
    <span class="token punctuation">)</span> 
<span class="token keyword">order</span> <span class="token keyword">by</span>
    <span class="token number">c</span><span class="token punctuation">.</span>created_time <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre>
<p>结果在1ms内，但前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何差别这么多是因为有一个limit。</p>
<p>大致执行过程是：先按索引排序得到前10条记录，然后再去join过滤，当发现匹配结果不够10条的时候，再次取10条，再次join。</p>
<p>显然在内层的数据非常多的时候，极端情况，内层一条数据都不匹配，还要每次取10条去匹配，几乎遍历了这个数据表。</p>
<p>由于MySQL的嵌套循环机制，遇到这种情况，基本无法优化。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>
    <!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
    <!-- material design -->
    <!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
    <!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
    <!-- toc -->
    <!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
    <!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
    <!-- <script src="/js/main.js"></script> -->
    <script src="/js/prism.js"></script>
</body>
</html>
