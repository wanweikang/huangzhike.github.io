<!DOCTYPE HTML>
<html>

<head>
    <script>
        var timeStart = new Date();
    </script>
    <meta charset="utf-8">
    
    <title>[笔记]-MySQL | Reunion...</title>
    
    <meta name="author" content="huangzhike">
    
    
    <meta name="description"
        content="一个人最好的生活状态：


该看书时看书，该玩时尽情玩；


看见优秀的人欣赏，看见落魄的人也不轻视；


有自己的小生活和小情趣，不用去想改变世界，努力去活出自己；


没有人爱时专注自己，有人爱时有能力拥抱彼此。

本来我对鸡汤是不屑一顾的，但是这几句话不知道为什么特别戳中我心，所以，哈哈，特别">
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta property="og:title" content="[笔记]-MySQL" />
    
    <meta property="og:site_name" content="Reunion..." />
    
    
    <!-- favicon -->
    <link rel="icon" type="image/ico" href="/logo.ico" sizes="32x32">
    <meta name="msapplication-TileColor" content="#009688">
    <meta name="msapplication-TileImage" content="/mstile-144x144.ico">
    <meta name="theme-color" content="#009688">
    <!-- favicon end -->
    <!-- <link href="//ok.ico" rel="icon"> -->
    

    <!-- <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
    <link rel="stylesheet" href="/css/prism.css" media="screen" type="text/css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    <nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" title="早く来い、クラウド" href="/">Reunion...</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" target="_blank" rel="noopener" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

    <div class="container" >
        <div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-MySQL</h2>
				
				<div>
					<div class="post-time">2020-05-27</div>
				</div>
				
				<div class="article-content">
				<blockquote>
<p>一个人最好的生活状态：</p>
</blockquote>
<blockquote>
<p>该看书时看书，该玩时尽情玩；</p>
</blockquote>
<blockquote>
<p>看见优秀的人欣赏，看见落魄的人也不轻视；</p>
</blockquote>
<blockquote>
<p>有自己的小生活和小情趣，不用去想改变世界，努力去活出自己；</p>
</blockquote>
<blockquote>
<p>没有人爱时专注自己，有人爱时有能力拥抱彼此。</p>
</blockquote>
<p>本来我对鸡汤是不屑一顾的，但是这几句话不知道为什么特别戳中我心，所以，哈哈，特别写在了文章前面（是不是暴露了什么？）。</p>
<hr>
<p>最近在看MySQL，整理了一些笔记，看过的书包括：</p>
<ul>
<li><p>MySQL技术内幕 InnoDB存储引擎 第2版</p>
</li>
<li><p>MySQL技术内幕 第5版</p>
</li>
<li><p>高性能MySQL 第3版</p>
</li>
<li><p>数据库索引优化与设计（瞄了一遍）</p>
</li>
</ul>
<p>基本把豆瓣上MySQL评分比较高的书过了一遍，跳过了偏运维的部分。</p>
<p>书里的MySQL版本比较老，现在不一定正确，我也没一一验证，但还是可以作为参考的。</p>
<p>这里默认谈论的都是InnoDB存储引擎。</p>
<p>最后推荐两个网站：</p>
<p><a href="https://www.mysqlzh.com/doc/65/340.html" target="_blank" rel="noopener">MySQL中文文档，版本比较旧，有能力的看一看官方的英文原版文档，很有用</a></p>
<p><a href="http://mysql.taobao.org/monthly/" target="_blank" rel="noopener">应该是淘宝团队的MySQL月报？干货满满</a></p>
<hr>
<p>MySQL可分为Server层和存储引擎层。</p>
<p>Server层：内置函数（如日期、时间等），以及存储过程、触发器、视图等跨存储引擎的实现，另外，还有一个缓存层。</p>
<ul>
<li><p>连接器：负责跟客户端建立连接、获取权限、维持和管理连接。</p>
</li>
<li><p>分析器：SQL词法语法分析</p>
</li>
<li><p>优化器：索引选择，决定表的连接顺序，生成执行计划</p>
</li>
<li><p>执行器：操作引擎，返回执行结果</p>
</li>
</ul>
<p>存储引擎层：</p>
<p>负责数据的存储和提取，如InnoDB、MyISAM等。</p>
<p>连接层 - 缓存 - SQL解析预处理 - 优化器生成执行计划 - 存储引擎 - 生成结果</p>
<p>每个客户端连接都会在MySQL服务器进程中对应一个线程。</p>
<p>MySQL客户端和服务端的通信是半双工的，即同一时刻只能单向传输，客户端发送请求和服务端发送响应无法同时发生。</p>
<p>客户端发送完请求后，只能等待完整的接收结果。</p>
<hr>
<p>事务的隔离性由锁实现，原子性，一致性，持久性由REDO LOG和UNDO LOG实现，REDO LOG称为重做日志，保证事务的原子性和持久性，UNDO LOG保证事务的一致性。</p>
<p>REDO和UNDO可以视为是恢复操作，REDO恢复提交事务修改的页操作，而UNDO回滚行记录到某个特定版本（MVCC）。</p>
<p>REDO通常是物理日志，记录的是页的物理修改操作，UNDO是逻辑日志，根据每行记录进行记录。</p>
<p>重做日志用来实现事务的持久性：内存中的重做日志缓冲是易失的，但是重做日志文件是持久的。</p>
<p>Write Ahead Log：事务提交时，必须先写重做日志（顺序IO）持久化，再修改页，宕机后通过重做日志完成数据恢复。</p>
<p>BIN LOG用来进行时间点的恢复和主备复制，是由MySQL服务器上层实现的，记录的是逻辑日志，即对应的SQL语句，只在事务提交后一次写入。</p>
<p>REDO LOG用来保护脏数据，在InnoDB存储引擎层生成，记录的是物理日志，即对页的更改，在日志进行中不断写入。</p>
<p>重做日志基本都是顺序写的，数据库运行时不需读取重做日志文件。</p>
<p>重做日志以块的方式保存，和磁盘扇区大小一样，写入可以保证原子性，不需要DoubleWrite。</p>
<p>InnoDB在启动时，不管上次有没有正常关闭，都会尝试根据重做日志进行恢复。</p>
<p>UNDO LOG需要随机读写，是逻辑日志，只是逻辑上恢复修改，但是页本身和回滚之前可能大不相同。</p>
<p>对于每个INSERT，完成一个DELETE，对于每个DELETE，完成一个INSERT，对于每个UPDATE，完成一个相反的UPDATE。</p>
<p>除了回滚，UNDO LOG的另一个作用是MVCC，MVCC通过UNDO完成。</p>
<p>当读取一行时，若已被其它事务占用，当前事务可以通过UNDO读取之前的行版本信息，实现非锁定读。</p>
<p>UNDO LOG会产生REDO LOG，因为UNDO LOG也需要持久化保护。</p>
<hr>
<p>二进制日志</p>
<p>BIN LOG记录了更改操作，但是不包括SELECT等查询。</p>
<p>主库按事务提交的顺序，把更改记录到二进制日志BINARY LOG，并通过IO线程异步复制给备库的中继日志RELAY LOG。</p>
<p>备库的SQL线程重放日志，应用到数据库。</p>
<p>主备复制不能解决写操作的压力，并且备库的读操作有延迟，负载高时有主备数据不一致的情况。</p>
<p>原因可能是：慢SQL语句过多、从库的硬件比主库差、网络延迟等。</p>
<p>作用：</p>
<ul>
<li><p>基于时间点的数据备份恢复；</p>
</li>
<li><p>主备复制同步；</p>
</li>
<li><p>语句审查监听（比如Canal，伪装成Slave，增量监听二进制日志，提供订阅和消费功能）。</p>
</li>
</ul>
<p>模式：</p>
<ul>
<li>基于语句（Statement）：</li>
</ul>
<p>默认，记录的是SQL语句，其实就是把主库执行过的SQL再执行一遍，好处是简单，但是更新必须是串行的，需要更多的锁，如果使用了某些函数、存储过程或触发器，复制时可能会有问题。</p>
<ul>
<li>基于行（Row）：</li>
</ul>
<p>以行为单位，记录的是对每行的修改，避免了执行SQL的相关上下文（重放主库的查询，如更新语句包含了查询），效率高，缺点是体积庞大。</p>
<p>正常情况下，读是非阻塞的，但是在使用语句的复制方式时，执行INSERT … SELECT … 操作会锁定原表所有行，因为需要保证主库和备库的执行结果是一致的。</p>
<p>基于行的复制则不会有这个问题。</p>
<ul>
<li>混合（Mixed）</li>
</ul>
<p>MySQL默认采用Statement格式，在一些情况下会使用Row格式，比如使用了UUID()等不确定函数时。</p>
<hr>
<p>一般先优化慢查询，优化业务逻辑，或者加入缓存，实在不行再集群，先读写分离，读写分离顶不住后再分库分表。</p>
<h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p>优点：</p>
<ul>
<li><p>行数据变小，一个数据块（Block）能存放更多数据，查询时I/O次数变少；</p>
</li>
<li><p>最大化利用Cache，垂直拆分的时候可以将不常变的字段放一起，将常变的放一起；</p>
</li>
<li><p>数据维护简单。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>主键出现冗余，需要管理冗余列；</p>
</li>
<li><p>增加JOIN操作，可以通过在应用层进行JOIN来减少数据库压力；</p>
</li>
<li><p>依然存在单表数据量过大的问题；</p>
</li>
<li><p>事务问题。</p>
</li>
</ul>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>优点:</p>
<ul>
<li>不存在单库大数据和高并发瓶颈；</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>分片事务一致性问题；</p>
</li>
<li><p>跨节点Join性能差，逻辑复杂；</p>
</li>
<li><p>数据多次扩展难度跟维护量极大。</p>
</li>
</ul>
<p>实际情况中往往会是垂直拆分和水平拆分的结合。</p>
<h4 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h4><p>如果某个表的数据有明显的时间特征，比如订单、交易记录等，通常比较合适用时间范围分片，因为具有时效性的数据，往往关注近期的数据，查询条件中往往带有时间字段进行过滤。</p>
<p>比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p>
<p>分片的选择取决于最频繁的查询SQL的条件，因为不带任何WHERE语句的查询，会遍历所有的分片，性能最差。</p>
<hr>
<p>水平拆分比较复杂，方案分为两大类：客户端架构和代理架构。</p>
<h4 id="客户端架构："><a href="#客户端架构：" class="headerlink" title="客户端架构："></a>客户端架构：</h4><p>通过修改数据访问层，如JDBC、DataSource、MyBatis，通过配置管理多个数据源，直连数据库，并在模块内完成数据的分片整合。</p>
<p>典型如ShardingJDBC。</p>
<p>优点：</p>
<ul>
<li><p>应用直连数据库，没有外围依赖；</p>
</li>
<li><p>成本低，无需额外运维。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能在数据库访问层上处理，扩展性一般。</li>
</ul>
<h4 id="代理架构："><a href="#代理架构：" class="headerlink" title="代理架构："></a>代理架构：</h4><p>通过独立的中间件来统一管理所有数据源和数据分片整合，需要独立部署和运维代理组件。</p>
<p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理。</p>
<p>典型如MyCat或者Atlas。</p>
<p>优点：</p>
<ul>
<li><p>能够处理复杂的需求，扩展性强；</p>
</li>
<li><p>对于应用透明，没有增加任何额外负载。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>需部署和运维独立的代理中间件，成本高；</p>
</li>
<li><p>应用需经过代理连接数据库，多了一层网络转发，性能有损失且有额外风险。</p>
</li>
</ul>
<hr>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


        <footer>
             
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

        </footer>
    </div>
    <!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
    <!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->
    <script>
        var timeEnd = new Date();
        console.log('耗时：' + (timeEnd - timeStart));
        document.addEventListener('DOMContentLoaded', (event) => {
            document.querySelectorAll('pre').forEach((block) => {
                block.classList.add("line-numbers");
            });
        });
    </script>

    <script src="/js/prism.js"></script>
</body>
</html>
