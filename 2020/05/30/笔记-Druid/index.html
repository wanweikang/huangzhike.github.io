<!DOCTYPE HTML>
<html>
	<head><meta name="generator" content="Hexo 3.9.0">
		<meta charset="utf-8">
		<script src="/js/highlight.js"></script>
				<script>hljs.initHighlightingOnLoad();var timeStart = new Date();</script>
		
		<title>[笔记]-Druid | 学而时习之</title>
		
		<meta name="author" content="Huangzhike">
		
		
		<meta name="description" content="K.I.S.S">
		
		
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		
		<meta property="og:title" content="[笔记]-Druid">
		
		<meta property="og:site_name" content="学而时习之">
		
		
		<!-- favicon -->
		<link rel="icon" type="image/ico" href="/ok.ico" sizes="32x32">
 


		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.ico">
		<meta name="theme-color" content="#009688">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Didact+Gothic"> 

		<!-- favicon end -->
		<!-- <link href="//ok.ico" rel="icon"> -->
		
		<!-- toc -->
		<!-- <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">-->
		<!-- material design -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css"> -->
		<!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css"> -->
		<!--<link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">-->
		<link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
		 
		 
		<!-- <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>-->
		<!-- <script>window.jQuery || document.write('<script src="/libs/jquery-3.1.1.slim.min.js" type="text/javascript"><\/script>')</script>-->
	</head>
</html>
<body>
	<nav class="navbar navbar-default">
	<div class="container">
		<div class="navbar-header">
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
				<span class="sr-only">菜单</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="/">学而时习之</a>
           
		</div>
		<div id="navbar" class="collapse navbar-collapse">
			<ul class="nav navbar-nav navbar-right">
				
				<li>
					<a href="https://huangzhike.github.io/archives" title="">
						<i class="fa fa-list"></i>Archives
					</a>
				</li>
				
				<li>
					<a href="https://github.com/huangzhike" title="">
						<i class="fa fa-github"></i>GitHub
					</a>
				</li>
				
			</ul>
		</div>
	</div>
</nav>

	<div class="container" >
		<div class="row">
	
		<div class="col-md-9 center-content">
			
			<div class="content">
				<!-- index -->
				
				<h2>[笔记]-Druid</h2>
				
				<div>
					<div class="post-time">2020-05-30</div>
				</div>
				
				<div class="article-content">
				<p>版本1.1.21。</p>
<p>吭，说句题外话，之前面试某大厂的时候，面试官问了我一个问题，连接池是怎么实现的，我的回答是用一个阻塞队列，AOP拦截关闭方法，将连接返回连接池。</p>
<p>当时我没太关注这方面，所以只是简单说了我的想法，不过面试官听到我用阻塞队列实现的时候，惊讶地叫了出来，额，难道不可以么。</p>
<p>看Druid的实现，也是用数组保存连接，然后通过锁和条件控制并发，这不就是阻塞队列ArrayBlockingQueue的基本思路么。</p>
<p>虽然直接用阻塞队列可能不灵活，但是应该也能用吧（可能的问题就是比较难回收闲置的连接，因为是FIFO）。。。</p>
<p>返还连接时，Druid也是在连接的代理对象内包了一层过滤链，在调用关闭方法的时候将连接放回连接池。</p>
<p><del>所以就是有点疑惑。。。</del></p>
<p>好吧，我已经会自问自答了，我觉得应该是因为阻塞队列这种队尾进队头出的结构不适合连接池的业务逻辑，比如回收连接时，不能跳过前面的连接（其实应该可以做个懒处理的，但是性能不好）。</p>
<hr>
<p>DruidDataSource#getConnection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">getConnection</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">// 有配置Filter的就走过滤链</span></span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> filterChain.dataSource_connect(<span class="keyword">this</span>, maxWaitMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接获取</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getConnectionDirect(maxWaitMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource#init</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁才能继续</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 从SPI加载Filter</span></span><br><span class="line">        initFromSPIServiceLoader();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.driver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> (MockDriver.class.getName().equals(driverClass)) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 反射初始化JDBC驱动</span></span><br><span class="line">                driver = JdbcUtils.createDriver(driverClassLoader, driverClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        connections = <span class="keyword">new</span> DruidConnectionHolder[maxActive];</span><br><span class="line">        evictConnections = <span class="keyword">new</span> DruidConnectionHolder[maxActive];</span><br><span class="line">        keepAliveConnections = <span class="keyword">new</span> DruidConnectionHolder[maxActive];</span><br><span class="line"></span><br><span class="line">        SQLException connectError = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 配置了创建连接的计划线程池 &amp;&amp; 异步初始化</span></span><br><span class="line">        <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span> &amp;&amp; asyncInit) &#123;</span><br><span class="line">            <span class="comment">// 提交任务给线程池异步执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; ++i) &#123;</span><br><span class="line">                submitCreateTask(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!asyncInit) &#123;</span><br><span class="line">            <span class="comment">// 初始化连接池</span></span><br><span class="line">            <span class="keyword">while</span> (poolingCount &lt; initialSize) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建连接</span></span><br><span class="line">                    PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();</span><br><span class="line">                    DruidConnectionHolder holder = <span class="keyword">new</span> DruidConnectionHolder(<span class="keyword">this</span>, pyConnectInfo);</span><br><span class="line">                    connections[poolingCount++] = holder;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动日志线程</span></span><br><span class="line">        createAndLogThread();</span><br><span class="line">        <span class="comment">// 启动创建Connection的后台线程，如果没有配置计划线程池</span></span><br><span class="line">        createAndStartCreatorThread();</span><br><span class="line">        <span class="comment">// 启动销毁Connection的后台线程，如果没有配置计划线程池</span></span><br><span class="line">        createAndStartDestroyThread();</span><br><span class="line">        <span class="comment">// 等待初始化完成</span></span><br><span class="line">        initedLatch.await();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 默认关闭</span></span><br><span class="line">        <span class="keyword">if</span> (keepAlive) &#123;</span><br><span class="line">            <span class="comment">// async fill to minIdle</span></span><br><span class="line">            <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 提交任务，创建最小闲置数的Connection</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minIdle; ++i) &#123;</span><br><span class="line">                    submitCreateTask(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.emptySignal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        inited = <span class="keyword">true</span>;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource#getConnectionDirect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">getConnectionDirect</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> notFullTimeoutRetryCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// handle notFullTimeoutRetry</span></span><br><span class="line">        DruidPooledConnection poolableConnection;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取Connection</span></span><br><span class="line">            poolableConnection = getConnectionInternal(maxWaitMillis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (GetConnectionTimeoutException ex) &#123;</span><br><span class="line">            <span class="comment">// 小于超时重试次数 &amp;&amp; 连接池没满</span></span><br><span class="line">            <span class="keyword">if</span> (notFullTimeoutRetryCnt &lt;= <span class="keyword">this</span>.notFullTimeoutRetryCount &amp;&amp; !isFull()) &#123;</span><br><span class="line">                notFullTimeoutRetryCnt++;</span><br><span class="line">                <span class="comment">// 重试</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则抛异常</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 借取Connection时是否检测，默认不检测，可能会返回已经被数据库关闭的无效Connection</span></span><br><span class="line">        <span class="keyword">if</span> (testOnBorrow) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolableConnection.conn.isClosed()) &#123;</span><br><span class="line">                discardConnection(poolableConnection.holder); <span class="comment">// 传入null，避免重复关闭</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检测闲置过久的Connection</span></span><br><span class="line">            <span class="keyword">if</span> (testWhileIdle) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要移除废弃Connection</span></span><br><span class="line">        <span class="keyword">if</span> (removeAbandoned) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            activeConnectionLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 先加入活跃Connection集合</span></span><br><span class="line">                activeConnections.put(poolableConnection, PRESENT);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                activeConnectionLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultAutoCommit) &#123;</span><br><span class="line">            poolableConnection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poolableConnection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource#getConnectionInternal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DruidPooledConnection <span class="title">getConnectionInternal</span><span class="params">(<span class="keyword">long</span> maxWait)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 连接池已关闭</span></span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接池已禁用，禁用后还要唤醒等待获取连接的线程后才能关闭</span></span><br><span class="line">    <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nanos = TimeUnit.MILLISECONDS.toNanos(maxWait);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxWaitThreadCount = <span class="keyword">this</span>.maxWaitThreadCount;</span><br><span class="line"></span><br><span class="line">    DruidConnectionHolder holder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直到获取到Connection</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> createDirect = <span class="keyword">false</span>; ; ) &#123;</span><br><span class="line">        <span class="comment">// 如果直接创建</span></span><br><span class="line">        <span class="keyword">if</span> (createDirect) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 当前不能有正在创建的</span></span><br><span class="line">            <span class="keyword">if</span> (creatingCountUpdater.compareAndSet(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 创建Connection</span></span><br><span class="line">                PhysicalConnectionInfo pyConnInfo = DruidDataSource.<span class="keyword">this</span>.createPhysicalConnection();</span><br><span class="line">                holder = <span class="keyword">new</span> DruidConnectionHolder(<span class="keyword">this</span>, pyConnInfo);</span><br><span class="line">                holder.lastActiveTimeMillis = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 创建完减回去</span></span><br><span class="line">                creatingCountUpdater.decrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                directCreateCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">boolean</span> discard = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 获取锁，保证数量更新的原子性</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 当前使用中的Connection数量，从连接池获取到就算激活</span></span><br><span class="line">                    <span class="keyword">if</span> (activeCount &lt; maxActive) &#123;</span><br><span class="line">                        activeCount++;</span><br><span class="line">                        <span class="keyword">if</span> (activeCount &gt; activePeak) &#123;</span><br><span class="line">                            <span class="comment">// 更新巅峰的使用数量</span></span><br><span class="line">                            activePeak = activeCount;</span><br><span class="line">                            activePeakTime = System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        discard = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建超过数量的Connection要废弃，关闭Connection</span></span><br><span class="line">                <span class="keyword">if</span> (discard) &#123;</span><br><span class="line">                    JdbcUtils.close(pyConnInfo.getPhysicalConnection());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须获取锁才能继续</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (maxWaitThreadCount &gt; <span class="number">0</span> &amp;&amp; notEmptyWaitThreadCount &gt;= maxWaitThreadCount) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (onFatalError &amp;&amp; onFatalErrorMaxActive &gt; <span class="number">0</span> &amp;&amp; activeCount &gt;= onFatalErrorMaxActive) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 全局的获取Connection次数，只增不减</span></span><br><span class="line">            connectCount++;</span><br><span class="line">            <span class="comment">// 当前连接池没有Connection &amp;&amp; 正在使用的Connection数量没有超过限制 &amp;&amp; 当前没有在创建Connection</span></span><br><span class="line">            <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span> &amp;&amp; poolingCount == <span class="number">0</span> &amp;&amp; activeCount &lt; maxActive &amp;&amp; creatingCountUpdater.get(<span class="keyword">this</span>) == <span class="number">0</span> &amp;&amp; createScheduler <span class="keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;</span><br><span class="line">                ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) createScheduler;</span><br><span class="line">                <span class="comment">// 创建Connection的计划任务线程池的任务队列还有任务</span></span><br><span class="line">                <span class="keyword">if</span> (executor.getQueue().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 直接创建</span></span><br><span class="line">                    createDirect = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞等待从队列尾获取Connection</span></span><br><span class="line">            <span class="keyword">if</span> (maxWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                holder = pollLast(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                holder = takeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="comment">// LOOP ENDS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有获取到Connection</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该Connection的使用量增加</span></span><br><span class="line">    holder.incrementUseCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再包装Connection</span></span><br><span class="line">    DruidPooledConnection poolalbeConnection = <span class="keyword">new</span> DruidPooledConnection(holder);</span><br><span class="line">    <span class="keyword">return</span> poolalbeConnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource#pollLast</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DruidConnectionHolder <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> estimate = nanos;</span><br><span class="line">    <span class="comment">// 自旋重试</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 当前连接池已经没有Connection了</span></span><br><span class="line">        <span class="keyword">if</span> (poolingCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有设置创建Connection的计划线程池，则唤醒默认的创建Connection的后台线程，交给它创建，否则提交创建任务给计划线程池</span></span><br><span class="line">            emptySignal(); <span class="comment">// send signal to CreateThread create connection</span></span><br><span class="line">            <span class="comment">// 设置了快速失败 &amp;&amp; 已经被标记为创建Connection持续性失败</span></span><br><span class="line">            <span class="keyword">if</span> (failFast &amp;&amp; isFailContinuous()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceNotAvailableException(createError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (estimate &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitNanosLocal.set(nanos - estimate);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连接池为空，等待创建的线程计数自增</span></span><br><span class="line">            notEmptyWaitThreadCount++;</span><br><span class="line">            <span class="comment">// 更新该巅峰值</span></span><br><span class="line">            <span class="keyword">if</span> (notEmptyWaitThreadCount &gt; notEmptyWaitThreadPeak) &#123;</span><br><span class="line">                notEmptyWaitThreadPeak = notEmptyWaitThreadCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> startEstimate = estimate;</span><br><span class="line">                <span class="comment">// 等待归还或创建Connection时唤醒</span></span><br><span class="line">                estimate = notEmpty.awaitNanos(estimate); <span class="comment">// signal by recycle or creator</span></span><br><span class="line">                <span class="comment">// 全局的等待创建次数，只增不减</span></span><br><span class="line">                notEmptyWaitCount++;</span><br><span class="line">                notEmptyWaitNanos += (startEstimate - estimate);</span><br><span class="line">                <span class="comment">// 连接池被禁用了</span></span><br><span class="line">                <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                notEmpty.signal(); <span class="comment">// propagate to non-interrupted thread</span></span><br><span class="line">                notEmptySignalCount++;</span><br><span class="line">                <span class="keyword">throw</span> ie;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 等待创建的线程计数自减</span></span><br><span class="line">                notEmptyWaitThreadCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超时后仍未创建Connection</span></span><br><span class="line">            <span class="keyword">if</span> (poolingCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (estimate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                waitNanosLocal.set(nanos - estimate);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接池还有Connection，先减计数</span></span><br><span class="line">        decrementPoolingCount();</span><br><span class="line">        <span class="comment">// 栈 FILO</span></span><br><span class="line">        DruidConnectionHolder last = connections[poolingCount];</span><br><span class="line">        <span class="comment">// 移出连接池</span></span><br><span class="line">        connections[poolingCount] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource$CreateConnectionThread#run</p>
<p>默认的创建连接的线程，如果配置了专门的创建连接的线程池的话，则是另外以提交任务的方式创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initedLatch.countDown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> lastDiscardCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> errorCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Loop直到被中断</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// addLast</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待获取锁</span></span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e2) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> discardCount = DruidDataSource.<span class="keyword">this</span>.discardCount;</span><br><span class="line">        <span class="comment">// 上次LOOP到现在有新的Connection被抛弃</span></span><br><span class="line">        <span class="keyword">boolean</span> discardChanged = discardCount - lastDiscardCount &gt; <span class="number">0</span>;</span><br><span class="line">        lastDiscardCount = discardCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> emptyWait = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 没有发生创建错误 &amp;&amp; 当前连接池没有Connection &amp;&amp; 没有新的Connection被废弃</span></span><br><span class="line">            <span class="keyword">if</span> (createError != <span class="keyword">null</span> &amp;&amp; poolingCount == <span class="number">0</span> &amp;&amp; !discardChanged) &#123;</span><br><span class="line">                <span class="comment">// 不需要等待连接池为空时才创建</span></span><br><span class="line">                emptyWait = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 异步初始化相关</span></span><br><span class="line">            <span class="keyword">if</span> (emptyWait &amp;&amp; asyncInit &amp;&amp; createCount &lt; initialSize) &#123;</span><br><span class="line">                emptyWait = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待Connection用完才创建</span></span><br><span class="line">            <span class="keyword">if</span> (emptyWait) &#123;</span><br><span class="line">                <span class="comment">// 现存的Connection数量 &gt;= 等待创建Connection线程数量 &amp;&amp; 从连接池拿出正在使用的Connection数量 + 连接池现存的数量 &lt; 最小闲置数量</span></span><br><span class="line">                <span class="keyword">if</span> (poolingCount &gt;= notEmptyWaitThreadCount &amp;&amp; (!(keepAlive &amp;&amp; activeCount + poolingCount &lt; minIdle)) &amp;&amp; !isFailContinuous()) &#123;</span><br><span class="line">                    <span class="comment">// 阻塞等待连接池被用完时唤醒</span></span><br><span class="line">                    empty.await();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 防止创建超过maxActive数量的连接</span></span><br><span class="line">                <span class="keyword">if</span> (activeCount + poolingCount &gt;= maxActive) &#123;</span><br><span class="line">                    empty.await();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PhysicalConnectionInfo connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建数据库的Connection，并包装FilterChain和PhysicalConnectionInfo</span></span><br><span class="line">            connection = createPhysicalConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            errorCount++;</span><br><span class="line">            <span class="comment">// 创建失败重试次数过多 &amp;&amp; 配置了间隔值，默认500</span></span><br><span class="line">            <span class="keyword">if</span> (errorCount &gt; connectionErrorRetryAttempts &amp;&amp; timeBetweenConnectErrorMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// fail over retry attempts</span></span><br><span class="line">                setFailContinuous(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 唤醒阻塞等待获取Connection的线程，快速失败</span></span><br><span class="line">                        notEmpty.signalAll();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 默认获取失败不跳出</span></span><br><span class="line">                <span class="keyword">if</span> (breakAfterAcquireFailure) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 在间隔配置的时间后再重试</span></span><br><span class="line">                    Thread.sleep(timeBetweenConnectErrorMillis);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException interruptEx) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            setFailContinuous(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没创建成功，下个循环继续</span></span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将Connection加入连接池，并唤醒等待的线程</span></span><br><span class="line">        <span class="keyword">boolean</span> result = put(connection);</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            JdbcUtils.close(connection.getPhysicalConnection());</span><br><span class="line">        &#125;</span><br><span class="line">        errorCount = <span class="number">0</span>; <span class="comment">// reset errorCount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>DruidPooledConnection#close</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// Connection发生异常或者已经关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.disable) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DruidConnectionHolder holder = <span class="keyword">this</span>.holder;</span><br><span class="line">    <span class="comment">// 说明Connection已经被关闭，重复关闭</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DruidAbstractDataSource dataSource = holder.getDataSource();</span><br><span class="line">    <span class="keyword">boolean</span> isSameThread = <span class="keyword">this</span>.getOwnerThread() == Thread.currentThread();</span><br><span class="line">    <span class="comment">// 关闭Connection的当前线程不是获取Connection的Owner线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isSameThread) &#123;</span><br><span class="line">        dataSource.setAsyncCloseConnectionEnable(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非Owner线程只有获取了Connection的锁才能执行关闭，场景是？</span></span><br><span class="line">    <span class="keyword">if</span> (dataSource.isAsyncCloseConnectionEnable()) &#123;</span><br><span class="line">        syncClose();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发Connection关闭事件监听器</span></span><br><span class="line">    <span class="keyword">for</span> (ConnectionEventListener listener : holder.getConnectionEventListeners()) &#123;</span><br><span class="line">        listener.connectionClosed(<span class="keyword">new</span> ConnectionEvent(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Filter&gt; filters = dataSource.getProxyFilters();</span><br><span class="line">    <span class="comment">// 有配置过滤器的走过滤链，否则直接回收</span></span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(dataSource);</span><br><span class="line">        filterChain.dataSource_recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.disable = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.disable) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DruidConnectionHolder holder = <span class="keyword">this</span>.holder;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.abandoned) &#123;</span><br><span class="line">        DruidAbstractDataSource dataSource = holder.getDataSource();</span><br><span class="line">        <span class="comment">// 放回连接池</span></span><br><span class="line">        dataSource.recycle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.holder = <span class="keyword">null</span>;</span><br><span class="line">    conn = <span class="keyword">null</span>;</span><br><span class="line">    transactionInfo = <span class="keyword">null</span>;</span><br><span class="line">    closed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DruidDataSource#recycle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(DruidPooledConnection pooledConnection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DruidConnectionHolder holder = pooledConnection.holder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Connection physicalConnection = holder.conn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pooledConnection.traceEnable) &#123;</span><br><span class="line">        Object oldInfo = <span class="keyword">null</span>;</span><br><span class="line">        activeConnectionLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pooledConnection.traceEnable) &#123;</span><br><span class="line">                <span class="comment">// 从当前活跃的连接列表移除，活跃指的是从连接池借出去</span></span><br><span class="line">                oldInfo = activeConnections.remove(pooledConnection);</span><br><span class="line">                pooledConnection.traceEnable = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            activeConnectionLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isAutoCommit = holder.underlyingAutoCommit;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isReadOnly = holder.underlyingReadOnly;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">this</span>.testOnReturn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果Connection没有打开自动提交，并且允许写操作，那么回滚</span></span><br><span class="line">        <span class="keyword">if</span> ((!isAutoCommit) &amp;&amp; (!isReadOnly)) &#123;</span><br><span class="line">            pooledConnection.rollback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Holder的信息，方便下次复用</span></span><br><span class="line">        <span class="keyword">boolean</span> isSameThread = pooledConnection.ownerThread == Thread.currentThread();</span><br><span class="line">        <span class="comment">// 关闭和获取Connection的线程不是同一个，即非Owner线程必须获取Connection的锁才能向下执行</span></span><br><span class="line">        <span class="keyword">if</span> (!isSameThread) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock lock = pooledConnection.lock;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                holder.reset();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            holder.reset();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被标记为废弃的Connection不会再回收</span></span><br><span class="line">        <span class="keyword">if</span> (holder.discard) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Connection使用次数超过了最大的限制则废弃，不再回收</span></span><br><span class="line">        <span class="keyword">if</span> (phyMaxUseCount &gt; <span class="number">0</span> &amp;&amp; holder.useCount &gt;= phyMaxUseCount) &#123;</span><br><span class="line">            discardConnection(holder);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被包装的数据库的物理连接已经被关闭，则更新一下计数，不再继续</span></span><br><span class="line">        <span class="keyword">if</span> (physicalConnection.isClosed()) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                activeCount--;</span><br><span class="line">                closeCount++;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果配置开启了返回连接池时检测连接，默认关闭，检测不通过则不放回连接池</span></span><br><span class="line">        <span class="keyword">if</span> (testOnReturn) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> validate = testConnectionInternal(holder, physicalConnection);</span><br><span class="line">            <span class="keyword">if</span> (!validate) &#123;</span><br><span class="line">                JdbcUtils.close(physicalConnection);</span><br><span class="line"></span><br><span class="line">                destroyCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    activeCount--;</span><br><span class="line">                    closeCount++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果连接池已经被禁用了，那么废弃连接，不再回收</span></span><br><span class="line">        <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">            discardConnection(holder);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Connection到现在时间过长，那么废弃连接，不再回收</span></span><br><span class="line">        <span class="keyword">if</span> (phyTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> phyConnectTimeMillis = currentTimeMillis - holder.connectTimeMillis;</span><br><span class="line">            <span class="keyword">if</span> (phyConnectTimeMillis &gt; phyTimeoutMillis) &#123;</span><br><span class="line">                discardConnection(holder);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先获取连接池的锁才能放回连接</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取时自增，返回时自减，代表正在使用的Connection数量</span></span><br><span class="line">            activeCount--;</span><br><span class="line">            closeCount++;</span><br><span class="line">            <span class="comment">// 放回连接池</span></span><br><span class="line">            result = putLast(holder, currentTimeMillis);</span><br><span class="line">            recycleCount++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放回连接池失败，要把Connection关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            JdbcUtils.close(holder.conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>总结：</p>
<p>Druid是一个非常繁重的数据库连接池，维护了大量的统计参数和状态，扩展通过过滤链实现。</p>
<p>数组实现的栈（FILO），加锁和条件唤醒进行并发和流程控制。</p>
<p>话说为什么是FILO不是FIFO，大概是尽量获取最新的连接？</p>
<p>另外我觉得一个类写了太多的逻辑，DruidDataSource这个主类就有近四千行代码，拆分一下是不是对维护和阅读更加友好呢？</p>
<p>水平有限，不说太多。</p>

				</div>
				<!-- about -->
				
			</div>
			<!-- pagination -->
			
			<div class="comment-section">
	
	


</div>
		</div>
		
	</div>


		<footer>
			 
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	</div>
	<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script> -->

	<script>var timeEnd = new Date();console.log('耗时：' + (timeEnd - timeStart));</script>
	<!-- <script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>-->
	<!-- material design -->
	<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script> -->
	<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>-->
	<!-- toc -->
	<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
	<!-- <script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script> -->
	<!-- <script src="/libs/tocify/jquery.tocify.custom.js"></script> -->
	<!-- <script src="/js/main.js"></script> -->
</body>
</html>
